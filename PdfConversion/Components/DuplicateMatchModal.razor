@using System.Xml.Linq
@using PdfConversion.Models
@using Microsoft.AspNetCore.Components

<!-- Modal Backdrop -->
@if (IsVisible)
{
    <div class="modal-backdrop fade show"></div>
    <div class="modal fade show d-block" tabindex="-1" role="dialog" aria-labelledby="duplicateMatchModalTitle" aria-modal="true">
        <div class="modal-dialog modal-custom-wide modal-dialog-centered" role="document">
            <div class="modal-content">
                <!-- Header -->
                <div class="modal-header">
                    <h5 class="modal-title" id="duplicateMatchModalTitle">Multiple Headers Found</h5>
                    <button type="button" class="btn-close" @onclick="HandleCancel" aria-label="Close"></button>
                </div>

                <!-- Body -->
                <div class="modal-body">
                    @if (DuplicateMatches != null && DuplicateMatches.Any())
                    {
                        <div class="alert alert-info mb-3" role="alert">
                            <i class="bi bi-info-circle"></i>
                            <strong>Section boundary unclear:</strong> Found multiple "@DuplicateMatches.First().HierarchyItem.LinkName" headers.
                            Please select which one marks the end of the "@CurrentHierarchyItem?.LinkName" section.
                            <button type="button" class="btn btn-sm btn-warning skip-button" @onclick="HandleSkip">
                                <i class="bi bi-skip-forward"></i> Skip This Section
                            </button>
                            <button type="button" class="btn btn-sm btn-danger skip-button" @onclick="HandleStopConversion">
                                <i class="bi bi-stop-circle"></i> Stop Conversion
                            </button>
                        </div>

                        <div class="two-column-layout">
                            <!-- Column 1: Hierarchy Tree (25%) -->
                            <div class="hierarchy-tree-column">
                                <h6 class="column-title">Document Hierarchy</h6>
                                <div class="hierarchy-tree">
                                    @if (AllHierarchyItems != null && AllHierarchyItems.Any())
                                    {
                                        @foreach (var item in AllHierarchyItems)
                                        {
                                            var isProcessed = ProcessedMatches?.Any(m => m.HierarchyItem.Id == item.Id) == true;
                                            var isCurrent = CurrentHierarchyItem?.Id == item.Id;
                                            var isParentOfCurrent = CurrentHierarchyItem != null && IsParentOf(item, CurrentHierarchyItem, AllHierarchyItems);

                                            var statusClass = isProcessed ? "processed" :
                                                            (isCurrent ? "current" :
                                                            (isParentOfCurrent ? "processing" : "upcoming"));

                                            var statusIcon = isProcessed ? "✓" :
                                                           (isCurrent ? "►" :
                                                           (isParentOfCurrent ? "⚙" : "□"));

                                            var levelClass = $"level-{item.Level}";

                                            <div class="hierarchy-item @statusClass @levelClass" id="@(isCurrent ? "current-hierarchy-item" : $"hierarchy-item-{item.Id}")">
                                                <span class="status-icon">@statusIcon</span>
                                                <span class="item-name">@item.LinkName</span>
                                                @if (isCurrent)
                                                {
                                                    <span class="current-label">CURRENT</span>
                                                }
                                            </div>
                                        }
                                    }
                                    else
                                    {
                                        <div class="text-muted small">No hierarchy information available.</div>
                                    }
                                </div>
                            </div>

                            <!-- Column 2: Document Preview (75%) -->
                            <div class="preview-column">
                                <div class="document-context-header">
                                    <h6 class="column-title">Full Document Preview</h6>
                                    <p class="text-muted small mb-1">
                                        <strong>Gray:</strong> Already processed |
                                        <strong>Yellow:</strong> Current section being extracted |
                                        <strong>Blue:</strong> Duplicate headers - click to select |
                                        <strong>Normal:</strong> Future sections (not yet processed)
                                    </p>
                                    <p class="text-muted small">
                                        Click on a blue header to select it, or use the Skip button above.
                                    </p>
                                </div>
                                <div id="document-preview" class="document-preview">
                                    @RenderDocumentWithContext()
                                </div>
                            </div>
                        </div>

                        <!-- Hidden buttons for Blazor event handling -->
                        <div style="display: none;">
                            @for (int i = 0; i < DuplicateMatches.Count; i++)
                            {
                                var index = i; // Capture for closure
                                <button id="confirm-match-@i" @onclick="@(() => SelectAndConfirmMatch(index))"></button>
                            }
                        </div>

                        <!-- JavaScript for handling header clicks and auto-scroll -->
                        <script>
                            (function() {
                                // Setup click handlers for duplicate headers
                                document.querySelectorAll('[data-match-index]').forEach(element => {
                                    element.addEventListener('click', function() {
                                        const matchIndex = parseInt(this.getAttribute('data-match-index'));
                                        // Trigger the hidden button click
                                        const button = document.getElementById('confirm-match-' + matchIndex);
                                        if (button) button.click();
                                    });
                                });

                                // Auto-scroll to both current hierarchy item and first duplicate header
                                setTimeout(() => {
                                    // Scroll hierarchy tree to current item
                                    const currentHierarchyItem = document.getElementById('current-hierarchy-item');
                                    if (currentHierarchyItem) {
                                        const hierarchyTree = currentHierarchyItem.closest('.hierarchy-tree');
                                        if (hierarchyTree) {
                                            // Calculate the position to center the current item
                                            const itemTop = currentHierarchyItem.offsetTop;
                                            const itemHeight = currentHierarchyItem.offsetHeight;
                                            const treeHeight = hierarchyTree.clientHeight;
                                            const scrollPosition = itemTop - (treeHeight / 2) + (itemHeight / 2);
                                            hierarchyTree.scrollTop = Math.max(0, scrollPosition);
                                        }
                                    }

                                    // Scroll document preview to first duplicate header
                                    const firstDuplicate = document.querySelector('[data-match-index="0"]');
                                    if (firstDuplicate) {
                                        firstDuplicate.scrollIntoView({ behavior: 'smooth', block: 'center' });
                                    }
                                }, 100);
                            })();
                        </script>
                    }
                </div>
            </div>
        </div>
    </div>
}

@code {
    [Parameter]
    public List<HeaderMatch>? DuplicateMatches { get; set; }

    [Parameter]
    public XDocument? TransformedDocument { get; set; }

    [Parameter]
    public List<HeaderMatch>? ProcessedMatches { get; set; }

    [Parameter]
    public List<HierarchyItem>? AllHierarchyItems { get; set; }

    [Parameter]
    public HierarchyItem? CurrentHierarchyItem { get; set; }

    [Parameter]
    public EventCallback<HeaderMatch?> OnSelectionConfirmed { get; set; }

    [Parameter]
    public bool IsVisible { get; set; }

    [Parameter]
    public CancellationTokenSource? CancellationTokenSource { get; set; }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && IsVisible && DuplicateMatches != null && DuplicateMatches.Any())
        {
            // Auto-scroll to the first duplicate header
            await ScrollToFirstDuplicate();
        }
    }

    private async Task ScrollToFirstDuplicate()
    {
        // Use JavaScript interop to scroll to the first duplicate header element
        // The first duplicate header will have a data-match-index="0" attribute
        var script = @"
            const preview = document.getElementById('document-preview');
            if (preview) {
                const firstDuplicate = preview.querySelector('[data-match-index=""0""]');
                if (firstDuplicate) {
                    firstDuplicate.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            }
        ";
        // Note: In a real implementation, you'd use IJSRuntime to execute this
        // For now, we'll add the script inline in the rendered HTML
    }

    private async Task SelectAndConfirmMatch(int matchIndex)
    {
        if (DuplicateMatches == null || matchIndex < 0 || matchIndex >= DuplicateMatches.Count)
            return;

        var selectedMatch = DuplicateMatches[matchIndex];
        await OnSelectionConfirmed.InvokeAsync(selectedMatch);
    }

    private async Task HandleSkip()
    {
        // Skip is treated as null (continue conversion, skip this section)
        await OnSelectionConfirmed.InvokeAsync(null);
    }

    private async Task HandleStopConversion()
    {
        // Stop the entire conversion process
        if (CancellationTokenSource != null && !CancellationTokenSource.IsCancellationRequested)
        {
            CancellationTokenSource.Cancel();
        }

        // Also close the modal and return null
        await OnSelectionConfirmed.InvokeAsync(null);
    }

    private async Task HandleCancel()
    {
        // X button - stop the entire conversion process
        if (CancellationTokenSource != null && !CancellationTokenSource.IsCancellationRequested)
        {
            CancellationTokenSource.Cancel();
        }

        // Close the modal and return null
        await OnSelectionConfirmed.InvokeAsync(null);
    }

    private bool IsParentOf(HierarchyItem potentialParent, HierarchyItem child, List<HierarchyItem> allItems)
    {
        // A parent must have a lower level number (higher in hierarchy)
        if (potentialParent.Level >= child.Level)
            return false;

        // Find indices in the list
        var parentIndex = allItems.IndexOf(potentialParent);
        var childIndex = allItems.IndexOf(child);

        if (parentIndex < 0 || childIndex < 0 || parentIndex >= childIndex)
            return false;

        // Check if there's any item between parent and child with same or lower level as parent
        // If there is, then potentialParent is not the direct parent
        for (int i = parentIndex + 1; i < childIndex; i++)
        {
            if (allItems[i].Level <= potentialParent.Level)
            {
                // Found another item at same or higher level, so potentialParent is not the parent
                return false;
            }
        }

        // Check if the child is a direct descendant (one level difference)
        // For now, we consider any item with lower level that comes before as a parent
        return true;
    }

    private string GetHeaderLevel(HeaderMatch match)
    {
        if (match.MatchedHeader == null) return "Unknown";

        var elementName = match.MatchedHeader.Name.LocalName.ToUpperInvariant();
        return elementName; // e.g., "H1", "H2", "H3"
    }

    private string? GetPrecedingHeaderText(HeaderMatch match)
    {
        if (match.MatchedHeader == null) return null;

        try
        {
            // Navigate backwards to find previous header (h1-h6)
            var currentElement = match.MatchedHeader;
            var previousElement = currentElement.ElementsBeforeSelf().LastOrDefault();

            while (previousElement != null)
            {
                var localName = previousElement.Name.LocalName.ToLowerInvariant();
                if (localName.StartsWith("h") && localName.Length == 2 &&
                    char.IsDigit(localName[1]))
                {
                    // Found a header element
                    var text = previousElement.Value?.Trim();
                    if (!string.IsNullOrEmpty(text))
                    {
                        // Truncate if too long
                        return text.Length > 80 ? text.Substring(0, 77) + "..." : text;
                    }
                }

                previousElement = previousElement.ElementsBeforeSelf().LastOrDefault();
            }

            return null;
        }
        catch
        {
            return null;
        }
    }

    private string DetermineElementContext(XElement element, HashSet<XElement?> processedHeaders, XElement? firstDuplicate, XElement? lastDuplicate)
    {
        // Get the body element for document order comparison
        var body = element.Ancestors().FirstOrDefault(a => a.Name.LocalName.ToLowerInvariant() == "body");
        if (body == null)
        {
            return "upcoming-content";
        }

        // Get all elements in document order
        var allElements = body.Descendants().ToList();
        var elementIndex = allElements.IndexOf(element);

        if (elementIndex == -1)
        {
            return "upcoming-content";
        }

        // Find the last processed header's position
        int lastProcessedIndex = -1;
        if (processedHeaders != null && processedHeaders.Any())
        {
            foreach (var processed in processedHeaders)
            {
                if (processed != null)
                {
                    var index = allElements.IndexOf(processed);
                    if (index > lastProcessedIndex)
                    {
                        lastProcessedIndex = index;
                    }
                }
            }
        }

        // Find first and last duplicate positions
        int firstDuplicateIndex = firstDuplicate != null ? allElements.IndexOf(firstDuplicate) : -1;
        int lastDuplicateIndex = lastDuplicate != null ? allElements.IndexOf(lastDuplicate) : -1;

        // IMPORTANT: Check in priority order to ensure correct coloring
        // Priority 1: After last duplicate = upcoming content (everything after duplicates should be normal)
        if (lastDuplicateIndex >= 0 && elementIndex > lastDuplicateIndex)
        {
            return "upcoming-content";
        }
        // Priority 2: Before or at last processed = processed content (gray)
        else if (lastProcessedIndex >= 0 && elementIndex <= lastProcessedIndex)
        {
            return "processed-content";
        }
        // Priority 3: After processed but before first duplicate = current section (yellow)
        else if (firstDuplicateIndex >= 0 && elementIndex < firstDuplicateIndex)
        {
            return "current-section";
        }
        // Priority 4: Between duplicates or other = upcoming content
        else
        {
            return "upcoming-content";
        }
    }

    private MarkupString RenderDocumentWithContext()
    {
        if (TransformedDocument == null || DuplicateMatches == null || !DuplicateMatches.Any())
        {
            return new MarkupString("<p class='text-muted'>No document context available.</p>");
        }

        try
        {
            // Get the body content (namespace-agnostic)
            var bodyElement = TransformedDocument.Descendants()
                .FirstOrDefault(e => e.Name.LocalName.ToLowerInvariant() == "body");

            if (bodyElement == null)
            {
                return new MarkupString("<p class='text-muted'>No body content found in document.</p>");
            }

            var htmlBuilder = new System.Text.StringBuilder();

            // Get all duplicate header elements for quick lookup
            var duplicateHeaderElements = DuplicateMatches
                .Where(m => m.MatchedHeader != null)
                .Select(m => m.MatchedHeader)
                .ToHashSet();

            // Get all processed header elements for quick lookup
            var processedHeaderElements = ProcessedMatches?
                .Where(m => m.MatchedHeader != null)
                .Select(m => m.MatchedHeader)
                .ToHashSet() ?? new HashSet<XElement?>();

            // Find the position of duplicate headers in the document
            var firstDuplicateHeader = DuplicateMatches.First().MatchedHeader;
            var lastDuplicateHeader = DuplicateMatches.Last().MatchedHeader;

            // Render each element in the body
            foreach (var element in bodyElement.Elements())
            {
                RenderElementWithContext(element, htmlBuilder, duplicateHeaderElements, processedHeaderElements, firstDuplicateHeader, lastDuplicateHeader);
            }

            return new MarkupString(htmlBuilder.ToString());
        }
        catch (Exception ex)
        {
            return new MarkupString($"<p class='text-danger'>Error rendering document: {ex.Message}</p>");
        }
    }

    private void RenderElementWithContext(
        XElement element,
        System.Text.StringBuilder htmlBuilder,
        HashSet<XElement?> duplicateHeaders,
        HashSet<XElement?> processedHeaders,
        XElement? firstDuplicate,
        XElement? lastDuplicate,
        int depth = 0)
    {
        var elementName = element.Name.LocalName.ToLowerInvariant();
        var cssClass = "";
        var isClickable = false;
        var matchIndex = -1;

        // List of content elements that should receive contextual styling
        var contentElements = new[] { "p", "h1", "h2", "h3", "h4", "h5", "h6", "li", "td", "th" };
        var shouldApplyContextStyles = contentElements.Contains(elementName);

        // Determine the context class for this element
        if (duplicateHeaders.Contains(element))
        {
            cssClass = "duplicate-option-preview";
            isClickable = true;
            matchIndex = DuplicateMatches!.FindIndex(m => m.MatchedHeader == element);
            shouldApplyContextStyles = true; // Always style duplicate headers
        }
        else if (shouldApplyContextStyles)
        {
            // Determine context for content elements based on position
            // This correctly handles processed headers by checking their position relative to duplicates
            cssClass = DetermineElementContext(element, processedHeaders, firstDuplicate, lastDuplicate);
        }

        // Build the HTML element with inline styles
        var styleAttr = "";
        if (shouldApplyContextStyles)
        {
            switch (cssClass)
            {
                case "processed-content":
                    styleAttr = "color: #6c757d; opacity: 0.5; background-color: #f8f9fa; padding: 0.25rem 0.5rem; margin: 0.25rem 0; border-left: 3px solid #dee2e6;";
                    break;
                case "current-section":
                    styleAttr = "color: #856404; background-color: #fff3cd; padding: 0.5rem; margin: 0.5rem 0; border-left: 4px solid #ffc107; font-weight: 500;";
                    break;
                case "duplicate-option-preview":
                    styleAttr = "color: #004085; background-color: #cfe2ff; padding: 0.5rem; margin: 0.5rem 0; border: 2px solid #0d6efd; border-radius: 0.25rem; font-weight: bold; cursor: pointer; box-shadow: 0 2px 4px rgba(13, 110, 253, 0.2);";
                    break;
                case "upcoming-content":
                    // Normal appearance - white background, normal text color, no opacity reduction
                    styleAttr = "color: #212529; background-color: #ffffff; padding: 0.25rem 0.5rem; margin: 0.25rem 0; border-right: 3px solid #e9ecef;";
                    break;
            }
        }

        var attributes = "";
        if (!string.IsNullOrEmpty(styleAttr))
        {
            attributes = $" style=\"{styleAttr}\"";
        }

        if (isClickable && matchIndex >= 0)
        {
            var uniqueId = $"duplicate-header-{matchIndex}";
            attributes += $" id=\"{uniqueId}\" data-match-index=\"{matchIndex}\"";
            if (string.IsNullOrEmpty(styleAttr))
            {
                attributes += " style=\"cursor: pointer;\"";
            }
        }

        // Add indentation for readability (optional)
        var indent = depth > 0 ? new string(' ', depth * 2) : "";

        htmlBuilder.Append($"{indent}<{elementName}{attributes}>");

        // Check if element has child elements
        var childElements = element.Elements().ToList();
        var hasChildren = childElements.Any();

        if (hasChildren)
        {
            // Element has children - recursively render them
            foreach (var childElement in childElements)
            {
                htmlBuilder.Append("<br/>");
                RenderElementWithContext(childElement, htmlBuilder, duplicateHeaders, processedHeaders, firstDuplicate, lastDuplicate, depth + 1);
            }
        }
        else
        {
            // No children - render direct text content
            var textContent = element.Nodes().OfType<XText>().FirstOrDefault()?.Value?.Trim();
            if (!string.IsNullOrEmpty(textContent))
            {
                htmlBuilder.Append(System.Net.WebUtility.HtmlEncode(textContent));
            }
        }

        htmlBuilder.Append($"</{elementName}>");
    }


}
