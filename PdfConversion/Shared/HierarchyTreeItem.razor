@using PdfConversion.Models
@using PdfConversion.Utils
@using System.Text.Json
@inject IJSRuntime JSRuntime

<div class="tree-item @GetDragClasses() @(Item.IsHallucinated ? "hallucinated" : "") @(SelectedItemIds?.Contains(Item.Id) == true ? "selected" : "")"
     style="margin-left: @(Level * 20)px"
     draggable="@(AllowDragDrop && Level > 0 ? "true" : "false")"
     @ondragstart="HandleDragStart"
     @ondragend="HandleDragEnd"
     @ondragover="HandleDragOver"
     @ondragover:preventDefault="true"
     @ondragleave="HandleDragLeave"
     @ondrop="HandleDrop"
     @ondrop:preventDefault="true"
     @onclick="HandleItemClick"
     @onclick:stopPropagation="true">
    <div class="tree-item-content">
        @if (Item.SubItems.Any())
        {
            <button class="btn btn-sm tree-toggle" @onclick="ToggleExpanded" @onclick:stopPropagation="true">
                <i class="bi @(Item.IsExpanded ? "bi-chevron-down" : "bi-chevron-right")"></i>
            </button>
        }
        else
        {
            <span class="tree-spacer"></span>
        }

        @* Always show sequential order badge (falls back to "?" if null) *@
        <span class="order-badge">@(Item.SequentialOrder?.ToString() ?? "?")</span>

        @* Always show header type badge (infer from Level if null) *@
        @{
            var headerType = !string.IsNullOrEmpty(Item.HeaderType)
                ? Item.HeaderType
                : $"H{Math.Min(Item.Level + 1, 6)}"; // Infer from Level (0-based to h1-h6)
        }
        <span class="header-type-badge header-type-@headerType.ToLower()">@headerType.ToUpper()</span>

        <span class="tree-item-label">@Item.LinkName</span>
        <button class="btn btn-sm btn-link tree-edit-icon"
                @onclick="OpenEditor"
                @onclick:stopPropagation="true"
                title="Edit item properties">
            <i class="bi bi-pencil-square"></i>
        </button>

        @if (Item.Confidence.HasValue)
        {
            <span class="confidence-badge confidence-@GetConfidenceClass(Item.Confidence.Value)">
                @Item.Confidence%
            </span>
        }

        @if (Item.IsHallucinated)
        {
            <i class="bi bi-exclamation-circle-fill text-danger" title="Not found in source document"></i>
            <span class="badge bg-danger ms-1">Hallucination</span>
        }

        @if (Item.IsUncertain)
        {
            <i class="bi bi-exclamation-triangle text-warning" title="Uncertain placement"></i>
        }
    </div>
</div>

@if (Item.IsExpanded && Item.SubItems.Any())
{
    @foreach (var subItem in Item.SubItems)
    {
        <HierarchyTreeItem Item="subItem"
                          Level="Level + 1"
                          ParentItem="Item"
                          OnItemSelected="OnItemSelected"
                          OnItemSelectedWithModifiers="OnItemSelectedWithModifiers"
                          OnItemEdited="OnItemEdited"
                          OnEditRequest="OnEditRequest"
                          AllowDragDrop="AllowDragDrop"
                          SelectedItemIds="SelectedItemIds"
                          RootItem="RootItem" />
    }
}

@code {
    [Parameter, EditorRequired]
    public HierarchyItem Item { get; set; } = null!;

    [Parameter]
    public int Level { get; set; }

    [Parameter]
    public HierarchyItem? ParentItem { get; set; }

    [Parameter]
    public EventCallback<HierarchyItem> OnItemSelected { get; set; }

    [Parameter]
    public EventCallback<ItemSelectionEventArgs> OnItemSelectedWithModifiers { get; set; }

    [Parameter]
    public EventCallback<HierarchyItem> OnItemEdited { get; set; }

    [Parameter]
    public EventCallback<HierarchyItem> OnEditRequest { get; set; }

    [Parameter]
    public bool AllowDragDrop { get; set; } = true;

    [Parameter]
    public HashSet<string>? SelectedItemIds { get; set; }

    [Parameter]
    public HierarchyItem? RootItem { get; set; }

    protected override void OnParametersSet()
    {
        base.OnParametersSet();

        // Diagnostic logging for badge rendering
        if (Item != null)
        {
            var sequentialOrder = Item.SequentialOrder?.ToString() ?? "NULL";
            var headerType = Item.HeaderType ?? "NULL";
            Console.WriteLine($"[Badge] Item '{Item.LinkName}': SequentialOrder={sequentialOrder}, HeaderType={headerType}, Level={Item.Level}");
        }
    }

    // Drag-drop state (static to share across instances)
    private static HierarchyItem? DraggedItem { get; set; }
    private static HierarchyItem? DraggedItemParent { get; set; }
    private static DocumentHeader? DraggedHeader { get; set; }
    private bool IsDragOver { get; set; }
    private bool IsBeingDragged { get; set; }

    // Drop position tracking for sibling reordering
    private enum DropPosition { None, Before, Into, After }
    private DropPosition CurrentDropPosition { get; set; } = DropPosition.None;

    private async Task HandleItemClick(MouseEventArgs e)
    {
        // If OnItemSelectedWithModifiers is bound, use it (Manual Mode with shift-click support)
        if (OnItemSelectedWithModifiers.HasDelegate)
        {
            var args = new ItemSelectionEventArgs
            {
                Item = Item,
                ShiftKey = e.ShiftKey,
                CtrlKey = e.CtrlKey || e.MetaKey
            };
            await OnItemSelectedWithModifiers.InvokeAsync(args);
        }
        else if (OnItemSelected.HasDelegate)
        {
            // Fallback to old callback (Load Existing Mode)
            await OnItemSelected.InvokeAsync(Item);
        }
    }

    private void ToggleExpanded()
    {
        Item.IsExpanded = !Item.IsExpanded;
    }

    private async Task OpenEditor()
    {
        await OnEditRequest.InvokeAsync(Item);
    }

    private string GetConfidenceClass(int confidence)
    {
        return confidence >= 80 ? "high" : confidence >= 70 ? "medium" : "low";
    }

    // Drag-drop event handlers
    private void HandleDragStart(DragEventArgs e)
    {
        if (!AllowDragDrop || Level == 0) return; // Don't allow drag if disabled or at root
        DraggedItem = Item;
        DraggedItemParent = ParentItem;
        IsBeingDragged = true;
    }

    private void HandleDragEnd()
    {
        IsBeingDragged = false;
        IsDragOver = false;
        CurrentDropPosition = DropPosition.None;
    }

    private async Task HandleDragOver(DragEventArgs e)
    {
        if (!CanDropHere())
        {
            IsDragOver = false;
            CurrentDropPosition = DropPosition.None;
            return;
        }

        // Log only occasionally to avoid flooding console
        if (!IsDragOver)
        {
            await JSRuntime.InvokeVoidAsync("console.log", "[HierarchyTreeItem] Drag over:", Item.LinkName, "DraggedHeader:", DraggedHeader?.Id ?? "null");
        }

        IsDragOver = true;

        // Calculate drop position based on mouse Y offset
        // Use fixed pixel thresholds for tree items (typically ~45px height)
        // Top 12px = insert before, Bottom 12px = insert after, Middle = insert into
        var offsetY = e.OffsetY;

        if (offsetY < 12)
        {
            // Top zone - insert before
            CurrentDropPosition = DropPosition.Before;
        }
        else if (offsetY > 33) // Assuming ~45px height, this is bottom 12px
        {
            // Bottom zone - insert after
            CurrentDropPosition = DropPosition.After;
        }
        else
        {
            // Middle zone - insert into (make child)
            CurrentDropPosition = DropPosition.Into;
        }
    }

    private void HandleDragLeave()
    {
        IsDragOver = false;
        CurrentDropPosition = DropPosition.None;
    }

    private async Task HandleDrop(DragEventArgs e)
    {
        await JSRuntime.InvokeVoidAsync("console.log", "[HierarchyTreeItem] HandleDrop called on:", Item.LinkName, "DraggedHeader:", DraggedHeader?.Id ?? "null", "DraggedItem:", DraggedItem?.LinkName ?? "null");

        // Check if we're dropping a header from the panel
        if (DraggedHeader != null)
        {
            await JSRuntime.InvokeVoidAsync("console.log", "[HierarchyTreeItem] Dropping header:", DraggedHeader.Id, "onto:", Item.LinkName);
            await HandleHeaderDrop();
            return;
        }

        // Otherwise handle tree item drop (existing logic)
        if (DraggedItem == null || !CanDropHere())
        {
            await JSRuntime.InvokeVoidAsync("console.log", "[HierarchyTreeItem] Cannot drop here. DraggedItem null?", DraggedItem == null, "CanDropHere?", CanDropHere());
            IsDragOver = false;
            CurrentDropPosition = DropPosition.None;
            return;
        }

        // Remove from old parent
        if (DraggedItemParent != null)
        {
            DraggedItemParent.SubItems.Remove(DraggedItem);
            if (OnItemEdited.HasDelegate)
            {
                await OnItemEdited.InvokeAsync(DraggedItemParent);
            }
        }

        // Handle different drop positions
        if (CurrentDropPosition == DropPosition.Before || CurrentDropPosition == DropPosition.After)
        {
            // Insert as sibling (before or after current item)
            if (ParentItem != null)
            {
                var siblings = ParentItem.SubItems;
                var currentIndex = siblings.IndexOf(Item);

                if (currentIndex >= 0)
                {
                    var insertIndex = CurrentDropPosition == DropPosition.Before
                        ? currentIndex
                        : currentIndex + 1;

                    siblings.Insert(insertIndex, DraggedItem);
                    if (OnItemEdited.HasDelegate)
                    {
                        await OnItemEdited.InvokeAsync(ParentItem);
                    }
                }
            }
        }
        else // DropPosition.Into
        {
            // Add as child (existing behavior)
            Item.SubItems.Add(DraggedItem);
            if (OnItemEdited.HasDelegate)
            {
                await OnItemEdited.InvokeAsync(Item);
            }
        }

        // Clear state
        IsDragOver = false;
        CurrentDropPosition = DropPosition.None;
        DraggedItem = null;
        DraggedItemParent = null;

        StateHasChanged();
    }

    /// <summary>
    /// Generates a unique ID for a new hierarchy item based on the link name.
    /// Uses normalized filename as base, appends random suffix if duplicate.
    /// </summary>
    private string GenerateUniqueId(string linkName, HierarchyItem rootItem)
    {
        // Normalize the linkname to create base ID (without extension)
        var baseId = FilenameUtils.NormalizeFileName(linkName);

        // Check if unique
        if (!IdExistsInTree(baseId, rootItem))
            return baseId;

        // Append short random string (6 characters)
        var random = new Random();
        var chars = "abcdefghijklmnopqrstuvwxyz0123456789";
        var suffix = new string(Enumerable.Repeat(chars, 6)
            .Select(s => s[random.Next(s.Length)]).ToArray());

        return $"{baseId}-{suffix}";
    }

    /// <summary>
    /// Generates a unique data-ref (filename) for a new hierarchy item.
    /// Uses normalized filename with sequential numbering if duplicate.
    /// </summary>
    private string GenerateUniqueDataRef(string linkName, HierarchyItem rootItem)
    {
        // Normalize the linkname to create base filename
        var baseFilename = FilenameUtils.NormalizeFileName(linkName);
        var filename = $"{baseFilename}.xml";

        // Check if unique
        if (!DataRefExistsInTree(filename, rootItem))
            return filename;

        // Add sequential numbering
        int counter = 1;
        while (DataRefExistsInTree($"{baseFilename}-{counter}.xml", rootItem))
        {
            counter++;
        }

        return $"{baseFilename}-{counter}.xml";
    }

    /// <summary>
    /// Recursively checks if an ID exists anywhere in the tree.
    /// </summary>
    private bool IdExistsInTree(string id, HierarchyItem item)
    {
        if (item.Id == id)
            return true;

        return item.SubItems.Any(child => IdExistsInTree(id, child));
    }

    /// <summary>
    /// Recursively checks if a data-ref exists anywhere in the tree.
    /// </summary>
    private bool DataRefExistsInTree(string dataRef, HierarchyItem item)
    {
        if (item.DataRef == dataRef)
            return true;

        return item.SubItems.Any(child => DataRefExistsInTree(dataRef, child));
    }

    /// <summary>
    /// Gets the root item of the hierarchy tree.
    /// Uses the RootItem parameter if provided, otherwise falls back to current Item.
    /// </summary>
    private HierarchyItem GetRootItem()
    {
        // Use the RootItem parameter if provided (preferred approach)
        if (RootItem != null)
            return RootItem;

        // Fallback: if RootItem not provided, assume current Item is root or close enough
        // This maintains backwards compatibility
        return Item;
    }

    private async Task HandleHeaderDrop()
    {
        await JSRuntime.InvokeVoidAsync("console.log", "[HierarchyTreeItem] HandleHeaderDrop START");

        if (DraggedHeader == null)
        {
            await JSRuntime.InvokeVoidAsync("console.log",
                "[HierarchyTreeItem] HandleHeaderDrop: DraggedHeader is null");
            return;
        }

        await JSRuntime.InvokeVoidAsync("console.log", "[HierarchyTreeItem] DraggedHeader validated");

        // Validate header title
        if (string.IsNullOrWhiteSpace(DraggedHeader.Title))
        {
            await JSRuntime.InvokeVoidAsync("console.log",
                "[HierarchyTreeItem] HandleHeaderDrop: DraggedHeader.Title is null or empty");
            return;
        }

        await JSRuntime.InvokeVoidAsync("console.log", "[HierarchyTreeItem] Title validated");

        // CRITICAL: Check for root-level sibling drop scenario
        if ((CurrentDropPosition == DropPosition.Before || CurrentDropPosition == DropPosition.After) && ParentItem == null)
        {
            await JSRuntime.InvokeVoidAsync("console.log",
                $"[HierarchyTreeItem] WARNING: Cannot insert as sibling at root level. Converting {CurrentDropPosition} to Into.");
            CurrentDropPosition = DropPosition.Into;
        }

        // Log drop position for debugging
        await JSRuntime.InvokeVoidAsync("console.log",
            $"[HierarchyTreeItem] Drop position: {CurrentDropPosition}, adding header '{DraggedHeader.Id}' as {(CurrentDropPosition == DropPosition.Into ? "child" : "sibling")}");

        // Get root item for uniqueness checks
        var rootItem = GetRootItem();
        if (rootItem == null)
        {
            await JSRuntime.InvokeVoidAsync("console.log",
                "[HierarchyTreeItem] HandleHeaderDrop: GetRootItem returned null");
            return;
        }

        await JSRuntime.InvokeVoidAsync("console.log", "[HierarchyTreeItem] RootItem validated, generating unique ID...");

        // Generate unique ID
        string uniqueId;
        try
        {
            uniqueId = GenerateUniqueId(DraggedHeader.Title, rootItem);
            await JSRuntime.InvokeVoidAsync("console.log", $"[HierarchyTreeItem] Generated unique ID: {uniqueId}");
        }
        catch (Exception ex)
        {
            await JSRuntime.InvokeVoidAsync("console.log", $"[HierarchyTreeItem] ERROR in GenerateUniqueId: {ex.Message}");
            return;
        }

        // Generate unique DataRef
        string uniqueDataRef;
        try
        {
            uniqueDataRef = GenerateUniqueDataRef(DraggedHeader.Title, rootItem);
            await JSRuntime.InvokeVoidAsync("console.log", $"[HierarchyTreeItem] Generated unique DataRef: {uniqueDataRef}");
        }
        catch (Exception ex)
        {
            await JSRuntime.InvokeVoidAsync("console.log", $"[HierarchyTreeItem] ERROR in GenerateUniqueDataRef: {ex.Message}");
            return;
        }

        // Calculate level
        int newLevel = CurrentDropPosition == DropPosition.Into ? Item.Level + 1 : Item.Level;
        await JSRuntime.InvokeVoidAsync("console.log", $"[HierarchyTreeItem] Calculated level: {newLevel}");

        // Create a new hierarchy item from the header with properly generated data
        var newItem = new HierarchyItem
        {
            Id = uniqueId,
            LinkName = DraggedHeader.Title,
            Level = newLevel,
            DataRef = uniqueDataRef,
            Path = "/",  // Always use root path for new items
            SubItems = new List<HierarchyItem>()
        };

        await JSRuntime.InvokeVoidAsync("console.log", "[HierarchyTreeItem] New item created successfully");

        // Handle different drop positions (same logic as tree item drops)
        if (CurrentDropPosition == DropPosition.Before || CurrentDropPosition == DropPosition.After)
        {
            // Insert as sibling (before or after current item)
            if (ParentItem != null)
            {
                var siblings = ParentItem.SubItems;
                if (siblings == null)
                {
                    await JSRuntime.InvokeVoidAsync("console.log",
                        "[HierarchyTreeItem] HandleHeaderDrop: ParentItem.SubItems is null");
                    return;
                }

                var currentIndex = siblings.IndexOf(Item);

                if (currentIndex >= 0)
                {
                    var insertIndex = CurrentDropPosition == DropPosition.Before
                        ? currentIndex
                        : currentIndex + 1;

                    siblings.Insert(insertIndex, newItem);
                    await JSRuntime.InvokeVoidAsync("console.log",
                        $"[HierarchyTreeItem] Inserted header as sibling at index {insertIndex} (position: {CurrentDropPosition})");

                    if (OnItemEdited.HasDelegate)
                    {
                        await OnItemEdited.InvokeAsync(ParentItem);
                    }
                }
                else
                {
                    await JSRuntime.InvokeVoidAsync("console.log",
                        "[HierarchyTreeItem] Warning: Could not find current item index in parent's SubItems");
                }
            }
            else
            {
                // Fallback: If no parent (root level), add as child instead
                await JSRuntime.InvokeVoidAsync("console.log",
                    "[HierarchyTreeItem] Warning: Cannot insert as sibling - no parent item. Adding as child instead.");
                newItem.Level = Item.Level + 1; // Adjust level since we're making it a child
                Item.SubItems.Add(newItem);

                if (OnItemEdited.HasDelegate)
                {
                    await OnItemEdited.InvokeAsync(Item);
                }
            }
        }
        else // DropPosition.Into
        {
            // Add as child
            Item.SubItems.Add(newItem);
            await JSRuntime.InvokeVoidAsync("console.log",
                $"[HierarchyTreeItem] Added header as child of '{Item.LinkName}'");

            if (OnItemEdited.HasDelegate)
            {
                await OnItemEdited.InvokeAsync(Item);
            }
        }

        // Clear state
        IsDragOver = false;
        CurrentDropPosition = DropPosition.None;
        DraggedHeader = null;

        StateHasChanged();
    }

    private bool CanDropHere()
    {
        // Allow header drops anywhere
        if (DraggedHeader != null)
            return true;

        if (DraggedItem == null || DraggedItem == Item)
            return false;

        // Check for circular reference (cannot drop parent into its own descendants)
        return !IsDescendantOf(Item, DraggedItem);
    }

    private bool IsDescendantOf(HierarchyItem potential, HierarchyItem ancestor)
    {
        if (potential == ancestor)
            return true;

        return ancestor.SubItems.Any(child => IsDescendantOf(potential, child));
    }

    private string GetDragClasses()
    {
        var classes = new List<string>();
        if (IsBeingDragged) classes.Add("dragging");

        if (IsDragOver && CanDropHere())
        {
            // Add specific class based on drop position
            switch (CurrentDropPosition)
            {
                case DropPosition.Before:
                    classes.Add("drop-indicator-before");
                    break;
                case DropPosition.After:
                    classes.Add("drop-indicator-after");
                    break;
                case DropPosition.Into:
                    classes.Add("drop-zone-valid");
                    break;
            }
        }

        if (IsDragOver && !CanDropHere())
        {
            classes.Add("drop-zone-invalid");
        }

        return string.Join(" ", classes);
    }

    /// <summary>
    /// Public method for external components (like AvailableHeadersPanel) to set the dragged header.
    /// Called when a header is being dragged from the panel.
    /// </summary>
    public static void SetDraggedHeader(DocumentHeader? header)
    {
        DraggedHeader = header;
        // Note: Cannot use JSRuntime here as it's a static method and JSRuntime requires instance context
    }
}
