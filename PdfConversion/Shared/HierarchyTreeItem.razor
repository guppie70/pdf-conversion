@using PdfConversion.Models
@using PdfConversion.Utils
@using System.Text.Json
@inject IJSRuntime JSRuntime

<div class="tree-item @GetDragClasses() @(Item.IsHallucinated ? "hallucinated" : "") @(SelectedItemIds?.Contains(Item.Id) == true ? "selected" : "")"
     style="margin-left: @(Level * 20)px"
     draggable="@(AllowDragDrop && Level > 0 ? "true" : "false")"
     @ondragstart="HandleDragStart"
     @ondragend="HandleDragEnd"
     @ondragover="HandleDragOver"
     @ondragover:preventDefault="true"
     @ondragleave="HandleDragLeave"
     @ondrop="HandleDrop"
     @ondrop:preventDefault="true"
     @onclick="HandleItemClick"
     @onclick:stopPropagation="true">
    <div class="tree-item-content">
        @if (Item.SubItems.Any())
        {
            <button class="btn btn-sm tree-toggle" @onclick="ToggleExpanded" @onclick:stopPropagation="true">
                <i class="bi @(IsExpanded ? "bi-chevron-down" : "bi-chevron-right")"></i>
            </button>
        }
        else
        {
            <span class="tree-spacer"></span>
        }

        @if (Item.SequentialOrder.HasValue)
        {
            <span class="order-badge">@Item.SequentialOrder</span>
        }

        @if (!string.IsNullOrEmpty(Item.HeaderType))
        {
            <span class="header-type-badge">@Item.HeaderType</span>
        }

        <span class="level-badge">L@(Item.Level)</span>

        @if (IsEditing)
        {
            <input type="text"
                   class="form-control form-control-sm tree-edit-input"
                   @bind="EditedLinkName"
                   @onblur="SaveEdit"
                   @onkeydown="HandleKeyDown"
                   @onclick:stopPropagation="true" />
        }
        else
        {
            <span class="tree-item-label" @ondblclick="StartEdit" @ondblclick:stopPropagation="true">@Item.LinkName</span>
            <button class="btn btn-sm btn-link tree-edit-icon"
                    @onclick="OpenEditor"
                    @onclick:stopPropagation="true"
                    title="Edit item properties">
                <i class="bi bi-pencil-square"></i>
            </button>
        }

        @if (Item.Confidence.HasValue)
        {
            <span class="confidence-badge confidence-@GetConfidenceClass(Item.Confidence.Value)">
                @Item.Confidence%
            </span>
        }

        @if (Item.IsHallucinated)
        {
            <i class="bi bi-exclamation-circle-fill text-danger" title="Not found in source document"></i>
            <span class="badge bg-danger ms-1">Hallucination</span>
        }

        @if (Item.IsUncertain)
        {
            <i class="bi bi-exclamation-triangle text-warning" title="Uncertain placement"></i>
        }
    </div>
</div>

@if (IsExpanded && Item.SubItems.Any())
{
    @foreach (var subItem in Item.SubItems)
    {
        <HierarchyTreeItem Item="subItem"
                          Level="Level + 1"
                          ParentItem="Item"
                          OnItemSelected="OnItemSelected"
                          OnItemEdited="OnItemEdited"
                          OnEditRequest="OnEditRequest"
                          AllowDragDrop="AllowDragDrop"
                          SelectedItemIds="SelectedItemIds" />
    }
}

@code {
    [Parameter, EditorRequired]
    public HierarchyItem Item { get; set; } = null!;

    [Parameter]
    public int Level { get; set; }

    [Parameter]
    public HierarchyItem? ParentItem { get; set; }

    [Parameter]
    public EventCallback<HierarchyItem> OnItemSelected { get; set; }

    [Parameter]
    public EventCallback<HierarchyItem> OnItemEdited { get; set; }

    [Parameter]
    public EventCallback<HierarchyItem> OnEditRequest { get; set; }

    [Parameter]
    public bool AllowDragDrop { get; set; } = true;

    [Parameter]
    public HashSet<string>? SelectedItemIds { get; set; }

    private bool IsExpanded { get; set; } = true;
    private bool IsEditing { get; set; }
    private string EditedLinkName { get; set; } = string.Empty;

    // Drag-drop state (static to share across instances)
    private static HierarchyItem? DraggedItem { get; set; }
    private static HierarchyItem? DraggedItemParent { get; set; }
    private static DocumentHeader? DraggedHeader { get; set; }
    private bool IsDragOver { get; set; }
    private bool IsBeingDragged { get; set; }

    // Drop position tracking for sibling reordering
    private enum DropPosition { None, Before, Into, After }
    private DropPosition CurrentDropPosition { get; set; } = DropPosition.None;

    private async Task HandleItemClick()
    {
        await OnItemSelected.InvokeAsync(Item);
    }

    private void ToggleExpanded()
    {
        IsExpanded = !IsExpanded;
    }

    private void StartEdit()
    {
        IsEditing = true;
        EditedLinkName = Item.LinkName;
    }

    private async Task SaveEdit()
    {
        if (EditedLinkName != Item.LinkName)
        {
            Item.LinkName = EditedLinkName;
            await OnItemEdited.InvokeAsync(Item);
        }
        IsEditing = false;
    }

    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Enter")
        {
            await SaveEdit();
        }
        else if (e.Key == "Escape")
        {
            IsEditing = false;
        }
    }

    private async Task OpenEditor()
    {
        await OnEditRequest.InvokeAsync(Item);
    }

    private string GetConfidenceClass(int confidence)
    {
        return confidence >= 80 ? "high" : confidence >= 70 ? "medium" : "low";
    }

    // Drag-drop event handlers
    private void HandleDragStart(DragEventArgs e)
    {
        if (!AllowDragDrop || Level == 0) return; // Don't allow drag if disabled or at root
        DraggedItem = Item;
        DraggedItemParent = ParentItem;
        IsBeingDragged = true;
    }

    private void HandleDragEnd()
    {
        IsBeingDragged = false;
        IsDragOver = false;
        CurrentDropPosition = DropPosition.None;
    }

    private async Task HandleDragOver(DragEventArgs e)
    {
        if (!CanDropHere())
        {
            IsDragOver = false;
            CurrentDropPosition = DropPosition.None;
            return;
        }

        // Log only occasionally to avoid flooding console
        if (!IsDragOver)
        {
            await JSRuntime.InvokeVoidAsync("console.log", "[HierarchyTreeItem] Drag over:", Item.LinkName, "DraggedHeader:", DraggedHeader?.Id ?? "null");
        }

        IsDragOver = true;

        // Calculate drop position based on mouse Y offset
        // Use fixed pixel thresholds for tree items (typically ~45px height)
        // Top 12px = insert before, Bottom 12px = insert after, Middle = insert into
        var offsetY = e.OffsetY;

        if (offsetY < 12)
        {
            // Top zone - insert before
            CurrentDropPosition = DropPosition.Before;
        }
        else if (offsetY > 33) // Assuming ~45px height, this is bottom 12px
        {
            // Bottom zone - insert after
            CurrentDropPosition = DropPosition.After;
        }
        else
        {
            // Middle zone - insert into (make child)
            CurrentDropPosition = DropPosition.Into;
        }
    }

    private void HandleDragLeave()
    {
        IsDragOver = false;
        CurrentDropPosition = DropPosition.None;
    }

    private async Task HandleDrop(DragEventArgs e)
    {
        await JSRuntime.InvokeVoidAsync("console.log", "[HierarchyTreeItem] HandleDrop called on:", Item.LinkName, "DraggedHeader:", DraggedHeader?.Id ?? "null", "DraggedItem:", DraggedItem?.LinkName ?? "null");

        // Check if we're dropping a header from the panel
        if (DraggedHeader != null)
        {
            await JSRuntime.InvokeVoidAsync("console.log", "[HierarchyTreeItem] Dropping header:", DraggedHeader.Id, "onto:", Item.LinkName);
            await HandleHeaderDrop();
            return;
        }

        // Otherwise handle tree item drop (existing logic)
        if (DraggedItem == null || !CanDropHere())
        {
            await JSRuntime.InvokeVoidAsync("console.log", "[HierarchyTreeItem] Cannot drop here. DraggedItem null?", DraggedItem == null, "CanDropHere?", CanDropHere());
            IsDragOver = false;
            CurrentDropPosition = DropPosition.None;
            return;
        }

        // Remove from old parent
        if (DraggedItemParent != null)
        {
            DraggedItemParent.SubItems.Remove(DraggedItem);
            await OnItemEdited.InvokeAsync(DraggedItemParent);
        }

        // Handle different drop positions
        if (CurrentDropPosition == DropPosition.Before || CurrentDropPosition == DropPosition.After)
        {
            // Insert as sibling (before or after current item)
            if (ParentItem != null)
            {
                var siblings = ParentItem.SubItems;
                var currentIndex = siblings.IndexOf(Item);

                if (currentIndex >= 0)
                {
                    var insertIndex = CurrentDropPosition == DropPosition.Before
                        ? currentIndex
                        : currentIndex + 1;

                    siblings.Insert(insertIndex, DraggedItem);
                    await OnItemEdited.InvokeAsync(ParentItem);
                }
            }
        }
        else // DropPosition.Into
        {
            // Add as child (existing behavior)
            Item.SubItems.Add(DraggedItem);
            await OnItemEdited.InvokeAsync(Item);
        }

        // Clear state
        IsDragOver = false;
        CurrentDropPosition = DropPosition.None;
        DraggedItem = null;
        DraggedItemParent = null;

        StateHasChanged();
    }

    /// <summary>
    /// Generates a unique ID for a new hierarchy item based on the link name.
    /// Uses normalized filename as base, appends random suffix if duplicate.
    /// </summary>
    private string GenerateUniqueId(string linkName, HierarchyItem rootItem)
    {
        // Normalize the linkname to create base ID (without extension)
        var baseId = FilenameUtils.NormalizeFileName(linkName);

        // Check if unique
        if (!IdExistsInTree(baseId, rootItem))
            return baseId;

        // Append short random string (6 characters)
        var random = new Random();
        var chars = "abcdefghijklmnopqrstuvwxyz0123456789";
        var suffix = new string(Enumerable.Repeat(chars, 6)
            .Select(s => s[random.Next(s.Length)]).ToArray());

        return $"{baseId}-{suffix}";
    }

    /// <summary>
    /// Generates a unique data-ref (filename) for a new hierarchy item.
    /// Uses normalized filename with sequential numbering if duplicate.
    /// </summary>
    private string GenerateUniqueDataRef(string linkName, HierarchyItem rootItem)
    {
        // Normalize the linkname to create base filename
        var baseFilename = FilenameUtils.NormalizeFileName(linkName);
        var filename = $"{baseFilename}.xml";

        // Check if unique
        if (!DataRefExistsInTree(filename, rootItem))
            return filename;

        // Add sequential numbering
        int counter = 1;
        while (DataRefExistsInTree($"{baseFilename}-{counter}.xml", rootItem))
        {
            counter++;
        }

        return $"{baseFilename}-{counter}.xml";
    }

    /// <summary>
    /// Recursively checks if an ID exists anywhere in the tree.
    /// </summary>
    private bool IdExistsInTree(string id, HierarchyItem item)
    {
        if (item.Id == id)
            return true;

        return item.SubItems.Any(child => IdExistsInTree(id, child));
    }

    /// <summary>
    /// Recursively checks if a data-ref exists anywhere in the tree.
    /// </summary>
    private bool DataRefExistsInTree(string dataRef, HierarchyItem item)
    {
        if (item.DataRef == dataRef)
            return true;

        return item.SubItems.Any(child => DataRefExistsInTree(dataRef, child));
    }

    /// <summary>
    /// Gets the root item of the hierarchy tree by traversing upward.
    /// Note: Cannot traverse beyond component hierarchy boundaries, so returns
    /// the highest accessible ancestor (which should be root when ParentItem is null).
    /// </summary>
    private HierarchyItem GetRootItem()
    {
        // Traverse up to find root
        var current = Item;
        var checkParent = ParentItem;

        while (checkParent != null)
        {
            current = checkParent;
            // In practice, we can't traverse further up through the component tree
            // This will return the item at the level where ParentItem is null (root level)
            break;
        }

        return current;
    }

    private async Task HandleHeaderDrop()
    {
        if (DraggedHeader == null)
        {
            return;
        }

        // Log drop position for debugging
        await JSRuntime.InvokeVoidAsync("console.log",
            $"[HierarchyTreeItem] Drop position: {CurrentDropPosition}, adding header '{DraggedHeader.Id}' as {(CurrentDropPosition == DropPosition.Into ? "child" : "sibling")}");

        // Get root item for uniqueness checks
        var rootItem = GetRootItem();

        // Create a new hierarchy item from the header with properly generated data
        var newItem = new HierarchyItem
        {
            Id = GenerateUniqueId(DraggedHeader.Title, rootItem),
            LinkName = DraggedHeader.Title,
            Level = CurrentDropPosition == DropPosition.Into ? Item.Level + 1 : Item.Level,
            DataRef = GenerateUniqueDataRef(DraggedHeader.Title, rootItem),
            Path = "/",  // Always use root path for new items
            SubItems = new List<HierarchyItem>()
        };

        // Handle different drop positions (same logic as tree item drops)
        if (CurrentDropPosition == DropPosition.Before || CurrentDropPosition == DropPosition.After)
        {
            // Insert as sibling (before or after current item)
            if (ParentItem != null)
            {
                var siblings = ParentItem.SubItems;
                var currentIndex = siblings.IndexOf(Item);

                if (currentIndex >= 0)
                {
                    var insertIndex = CurrentDropPosition == DropPosition.Before
                        ? currentIndex
                        : currentIndex + 1;

                    siblings.Insert(insertIndex, newItem);
                    await JSRuntime.InvokeVoidAsync("console.log",
                        $"[HierarchyTreeItem] Inserted header as sibling at index {insertIndex} (position: {CurrentDropPosition})");
                    await OnItemEdited.InvokeAsync(ParentItem);
                }
                else
                {
                    await JSRuntime.InvokeVoidAsync("console.log",
                        "[HierarchyTreeItem] Warning: Could not find current item index in parent's SubItems");
                }
            }
            else
            {
                // Fallback: If no parent (root level), add as child instead
                await JSRuntime.InvokeVoidAsync("console.log",
                    "[HierarchyTreeItem] Warning: Cannot insert as sibling - no parent item. Adding as child instead.");
                newItem.Level = Item.Level + 1; // Adjust level since we're making it a child
                Item.SubItems.Add(newItem);
                await OnItemEdited.InvokeAsync(Item);
            }
        }
        else // DropPosition.Into
        {
            // Add as child
            Item.SubItems.Add(newItem);
            await JSRuntime.InvokeVoidAsync("console.log",
                $"[HierarchyTreeItem] Added header as child of '{Item.LinkName}'");
            await OnItemEdited.InvokeAsync(Item);
        }

        // Clear state
        IsDragOver = false;
        CurrentDropPosition = DropPosition.None;
        DraggedHeader = null;

        StateHasChanged();
    }

    private bool CanDropHere()
    {
        // Allow header drops anywhere
        if (DraggedHeader != null)
            return true;

        if (DraggedItem == null || DraggedItem == Item)
            return false;

        // Check for circular reference (cannot drop parent into its own descendants)
        return !IsDescendantOf(Item, DraggedItem);
    }

    private bool IsDescendantOf(HierarchyItem potential, HierarchyItem ancestor)
    {
        if (potential == ancestor)
            return true;

        return ancestor.SubItems.Any(child => IsDescendantOf(potential, child));
    }

    private string GetDragClasses()
    {
        var classes = new List<string>();
        if (IsBeingDragged) classes.Add("dragging");

        if (IsDragOver && CanDropHere())
        {
            // Add specific class based on drop position
            switch (CurrentDropPosition)
            {
                case DropPosition.Before:
                    classes.Add("drop-indicator-before");
                    break;
                case DropPosition.After:
                    classes.Add("drop-indicator-after");
                    break;
                case DropPosition.Into:
                    classes.Add("drop-zone-valid");
                    break;
            }
        }

        if (IsDragOver && !CanDropHere())
        {
            classes.Add("drop-zone-invalid");
        }

        return string.Join(" ", classes);
    }

    /// <summary>
    /// Public method for external components (like AvailableHeadersPanel) to set the dragged header.
    /// Called when a header is being dragged from the panel.
    /// </summary>
    public static void SetDraggedHeader(DocumentHeader? header)
    {
        DraggedHeader = header;
        // Note: Cannot use JSRuntime here as it's a static method and JSRuntime requires instance context
    }
}
