@namespace PdfConversion.Shared
@using Microsoft.AspNetCore.Components.Forms
@using PdfConversion.Services
@using PdfConversion.Models
@inject IProjectArchiveService ArchiveService
@inject ILogger<ProjectFilesModal> Logger
@inject NavigationManager NavigationManager

@if (IsVisible)
{
    <div class="modal-backdrop" @onclick="HandleBackdropClick"></div>
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Project Files: @ProjectDisplayString</h5>
                <button type="button" class="btn-close" @onclick="Cancel" aria-label="Close"></button>
            </div>

            <div class="modal-tabs">
                <button type="button"
                        class="tab-button @(ActiveTab == "upload" ? "active" : "")"
                        @onclick='() => SetActiveTab("upload")'>
                    Upload
                </button>
                <button type="button"
                        class="tab-button @(ActiveTab == "download" ? "active" : "")"
                        @onclick='() => SetActiveTab("download")'
                        disabled="@(!HasPackages)">
                    Download
                </button>
            </div>

            <div class="modal-body">
                @if (!string.IsNullOrEmpty(ErrorMessage))
                {
                    <div class="alert alert-danger">
                        <i class="oi oi-warning"></i> @ErrorMessage
                    </div>
                }

                @if (!string.IsNullOrEmpty(SuccessMessage))
                {
                    <div class="alert alert-success">
                        <i class="oi oi-check"></i> @SuccessMessage
                    </div>
                }

                @if (ActiveTab == "upload")
                {
                    <div class="upload-section">
                        <div class="section-header">
                            <h6>Adobe Professional Export</h6>
                        </div>
                        <div class="upload-group">
                            <label class="upload-label">XML File</label>
                            <InputFile OnChange="HandleXmlUpload" accept=".xml" class="file-input" />
                            <small class="help-text">Upload XML file exported from Adobe Acrobat</small>
                        </div>
                        <div class="upload-group">
                            <label class="upload-label">Images</label>
                            <InputFile OnChange="HandleImagesUpload" accept=".png,.jpg,.jpeg" multiple class="file-input" />
                            <small class="help-text">Upload multiple images (PNG, JPG, JPEG)</small>
                        </div>

                        <div class="section-header">
                            <h6>PDF/Word Upload</h6>
                        </div>
                        <div class="upload-group">
                            <label class="upload-label">Document File</label>
                            <InputFile OnChange="HandleDocumentUpload" accept=".pdf,.docx,.doc" class="file-input" />
                            <small class="help-text">Upload PDF or Word document for conversion</small>
                        </div>

                        @if (IsUploading)
                        {
                            <div class="upload-progress">
                                <span class="spinner-border spinner-border-sm me-2"></span>
                                <span>Uploading files...</span>
                            </div>
                        }

                        @if (UploadedFiles.Any())
                        {
                            <div class="uploaded-files">
                                <strong>Uploaded Files:</strong>
                                <ul>
                                    @foreach (var file in UploadedFiles)
                                    {
                                        <li>@file</li>
                                    }
                                </ul>
                            </div>
                        }
                    </div>
                }

                @if (ActiveTab == "download")
                {
                    <div class="download-section">
                        <p class="download-description">
                            Download a pre-generated package containing all project output files:
                        </p>

                        <!-- Package Selector -->
                        <div class="form-group mb-3">
                            <label class="form-label fw-bold">Download Package</label>
                            @if (IsLoadingPackages)
                            {
                                <div class="text-muted">
                                    <span class="spinner-border spinner-border-sm me-2"></span>
                                    Loading packages...
                                </div>
                            }
                            else if (!AvailablePackages.Any())
                            {
                                <div class="alert alert-warning">
                                    <i class="oi oi-warning"></i> No packages available. Run Section Generation first to create a downloadable package.
                                </div>
                            }
                            else
                            {
                                <select class="form-select" @bind="SelectedPackage" required>
                                    @if (AvailablePackages.Count > 1 && string.IsNullOrEmpty(SelectedPackage))
                                    {
                                        <option value="">-- Select package --</option>
                                    }
                                    @foreach (var package in AvailablePackages)
                                    {
                                        <option value="@package">@package</option>
                                    }
                                </select>
                                <small class="form-text text-muted">
                                    @AvailablePackages.Count package(s) available
                                </small>
                            }
                        </div>

                        <!-- Package Contents -->
                        <ul class="download-contents">
                            <li>Selected package: <strong>@(SelectedPackage ?? "none selected")</strong></li>
                            <li>Section XML files (data/*.xml)</li>
                            <li>Hierarchy XML (metadata/*.xml)</li>
                            <li>All images (images/*)</li>
                            <li>Package manifest (manifest.yml)</li>
                        </ul>

                        <button type="button"
                                class="btn btn-primary btn-download"
                                @onclick="DownloadPackage"
                                disabled="@(IsDownloading || string.IsNullOrEmpty(SelectedPackage))">
                            @if (IsDownloading)
                            {
                                <span class="spinner-border spinner-border-sm me-2"></span>
                                <span>Preparing download...</span>
                            }
                            else
                            {
                                <i class="oi oi-data-transfer-download me-2"></i>
                                <span>Download ZIP</span>
                            }
                        </button>

                        @if (!HasPackages)
                        {
                            <div class="alert alert-info mt-3">
                                <i class="oi oi-info"></i> No packages available yet. Run Section Generation to create downloadable packages.
                            </div>
                        }
                    </div>
                }
            </div>

            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" @onclick="Cancel">Close</button>
            </div>
        </div>
    </div>
}

@code {
    [Parameter]
    public bool IsVisible { get; set; }

    [Parameter]
    public string Customer { get; set; } = string.Empty;

    [Parameter]
    public string ProjectId { get; set; } = string.Empty;

    [Parameter]
    public string ProjectDisplayString { get; set; } = string.Empty;

    [Parameter]
    public EventCallback OnClose { get; set; }

    [Parameter]
    public EventCallback OnFilesUploaded { get; set; }

    private string ActiveTab { get; set; } = "upload";
    private bool IsUploading { get; set; } = false;
    private bool IsDownloading { get; set; } = false;
    private bool HasPackages { get; set; } = false;
    private string? ErrorMessage { get; set; }
    private string? SuccessMessage { get; set; }
    private List<string> UploadedFiles { get; set; } = new();
    private List<string> AvailablePackages { get; set; } = new();
    private string? SelectedPackage { get; set; }
    private bool IsLoadingPackages { get; set; } = false;

    private const long MaxFileSize = 100 * 1024 * 1024; // 100MB

    protected override async Task OnParametersSetAsync()
    {
        if (IsVisible && !string.IsNullOrEmpty(Customer) && !string.IsNullOrEmpty(ProjectId))
        {
            // Check if project has packages to download
            var packages = await ArchiveService.GetAvailablePackagesAsync(Customer, ProjectId);
            HasPackages = packages.Any();

            // Always start on Upload tab
            ActiveTab = "upload";
        }
    }

    private async Task SetActiveTab(string tab)
    {
        ActiveTab = tab;
        ErrorMessage = null;
        SuccessMessage = null;

        if (tab == "download")
        {
            await LoadPackagesAsync();
        }
    }

    private async Task HandleXmlUpload(InputFileChangeEventArgs e)
    {
        try
        {
            IsUploading = true;
            ErrorMessage = null;
            SuccessMessage = null;

            var file = e.File;

            // Validate file type
            if (!file.Name.EndsWith(".xml", StringComparison.OrdinalIgnoreCase))
            {
                ErrorMessage = "Only .xml files are allowed";
                return;
            }

            // Validate file size
            if (file.Size > MaxFileSize)
            {
                ErrorMessage = $"File exceeds maximum size of {MaxFileSize / (1024 * 1024)}MB";
                return;
            }

            // Normalize filename (use "adobe.xml" as default)
            var targetFileName = "adobe.xml";
            var targetPath = Path.Combine("/app/data/input", Customer, "projects", ProjectId, "source", targetFileName);

            // Ensure directory exists
            var directory = Path.GetDirectoryName(targetPath);
            if (!string.IsNullOrEmpty(directory))
            {
                Directory.CreateDirectory(directory);
            }

            // Save file
            await using var fileStream = new FileStream(targetPath, FileMode.Create);
            await file.OpenReadStream(MaxFileSize).CopyToAsync(fileStream);

            UploadedFiles.Add($"{targetFileName} ({FormatFileSize(file.Size)})");
            SuccessMessage = "XML file uploaded successfully";

            Logger.LogInformation("Uploaded XML file: {FileName} to {Path}", file.Name, targetPath);
        }
        catch (Exception ex)
        {
            ErrorMessage = $"Failed to upload XML: {ex.Message}";
            Logger.LogError(ex, "Error uploading XML file");
        }
        finally
        {
            IsUploading = false;
            StateHasChanged();
        }
    }

    private async Task HandleImagesUpload(InputFileChangeEventArgs e)
    {
        try
        {
            IsUploading = true;
            ErrorMessage = null;
            SuccessMessage = null;

            var validExtensions = new[] { ".png", ".jpg", ".jpeg" };
            var uploadedCount = 0;

            foreach (var file in e.GetMultipleFiles(100)) // Max 100 files
            {
                // Validate file type
                var extension = Path.GetExtension(file.Name).ToLowerInvariant();
                if (!validExtensions.Contains(extension))
                {
                    Logger.LogWarning("Skipped invalid file type: {FileName}", file.Name);
                    continue;
                }

                // Validate file size
                if (file.Size > MaxFileSize)
                {
                    Logger.LogWarning("Skipped oversized file: {FileName}", file.Name);
                    continue;
                }

                // Keep original filename
                var targetPath = Path.Combine("/app/data/input", Customer, "projects", ProjectId, "images", "from-conversion", file.Name);

                // Ensure directory exists
                var directory = Path.GetDirectoryName(targetPath);
                if (!string.IsNullOrEmpty(directory))
                {
                    Directory.CreateDirectory(directory);
                }

                // Save file
                await using var fileStream = new FileStream(targetPath, FileMode.Create);
                await file.OpenReadStream(MaxFileSize).CopyToAsync(fileStream);

                UploadedFiles.Add($"{file.Name} ({FormatFileSize(file.Size)})");
                uploadedCount++;

                Logger.LogInformation("Uploaded image: {FileName} to {Path}", file.Name, targetPath);
            }

            SuccessMessage = $"Uploaded {uploadedCount} image(s) successfully";
        }
        catch (Exception ex)
        {
            ErrorMessage = $"Failed to upload images: {ex.Message}";
            Logger.LogError(ex, "Error uploading images");
        }
        finally
        {
            IsUploading = false;
            StateHasChanged();
        }
    }

    private async Task HandleDocumentUpload(InputFileChangeEventArgs e)
    {
        try
        {
            IsUploading = true;
            ErrorMessage = null;
            SuccessMessage = null;

            var file = e.File;

            // Validate file type
            var extension = Path.GetExtension(file.Name).ToLowerInvariant();
            var validExtensions = new[] { ".pdf", ".docx", ".doc" };
            if (!validExtensions.Contains(extension))
            {
                ErrorMessage = "Only PDF, DOCX, and DOC files are allowed";
                return;
            }

            // Validate file size
            if (file.Size > MaxFileSize)
            {
                ErrorMessage = $"File exceeds maximum size of {MaxFileSize / (1024 * 1024)}MB";
                return;
            }

            // Normalize filename based on extension
            var targetFileName = extension == ".pdf" ? "docling-source.pdf" : $"docling-source{extension}";
            var targetPath = Path.Combine("/app/data/input", Customer, "projects", ProjectId, targetFileName);

            // Ensure directory exists
            var directory = Path.GetDirectoryName(targetPath);
            if (!string.IsNullOrEmpty(directory))
            {
                Directory.CreateDirectory(directory);
            }

            // Save file
            await using var fileStream = new FileStream(targetPath, FileMode.Create);
            await file.OpenReadStream(MaxFileSize).CopyToAsync(fileStream);

            UploadedFiles.Add($"{targetFileName} ({FormatFileSize(file.Size)})");
            SuccessMessage = "Document uploaded successfully";

            Logger.LogInformation("Uploaded document: {FileName} to {Path}", file.Name, targetPath);
        }
        catch (Exception ex)
        {
            ErrorMessage = $"Failed to upload document: {ex.Message}";
            Logger.LogError(ex, "Error uploading document");
        }
        finally
        {
            IsUploading = false;
            StateHasChanged();
        }
    }

    private void DownloadPackage()
    {
        try
        {
            IsDownloading = true;
            ErrorMessage = null;

            if (string.IsNullOrEmpty(SelectedPackage))
            {
                ErrorMessage = "Please select a package first.";
                return;
            }

            Logger.LogInformation("Downloading package: {Customer}/{ProjectId}/{Package}",
                Customer, ProjectId, SelectedPackage);

            // Validate package exists
            var packagePath = ArchiveService.GetPackagePath(Customer, ProjectId, SelectedPackage);

            if (packagePath == null || !File.Exists(packagePath))
            {
                ErrorMessage = "Package not found. It may have been deleted or moved.";
                return;
            }

            // Build download URL - the endpoint will stream the file
            var downloadUrl = $"/api/packages/download/{Uri.EscapeDataString(Customer)}/{Uri.EscapeDataString(ProjectId)}/{Uri.EscapeDataString(SelectedPackage)}";

            Logger.LogInformation("Triggering download via URL: {Url}", downloadUrl);

            // Navigate to download URL (browser handles file download)
            NavigationManager.NavigateTo(downloadUrl, forceLoad: true);

            SuccessMessage = $"Package download started: {SelectedPackage}";
            Logger.LogInformation("Package download triggered: {Filename}", SelectedPackage);
        }
        catch (Exception ex)
        {
            ErrorMessage = $"Failed to download package: {ex.Message}";
            Logger.LogError(ex, "Error downloading package");
        }
        finally
        {
            IsDownloading = false;
            StateHasChanged();
        }
    }

    private async Task Cancel()
    {
        // Reset state
        ActiveTab = "upload";
        ErrorMessage = null;
        SuccessMessage = null;
        UploadedFiles.Clear();

        await OnClose.InvokeAsync();
    }

    private async Task HandleBackdropClick()
    {
        await Cancel();
    }

    private string FormatFileSize(long bytes)
    {
        string[] sizes = { "B", "KB", "MB", "GB" };
        double len = bytes;
        int order = 0;
        while (len >= 1024 && order < sizes.Length - 1)
        {
            order++;
            len = len / 1024;
        }
        return $"{len:0.##} {sizes[order]}";
    }


    private async Task LoadPackagesAsync()
    {
        IsLoadingPackages = true;
        ErrorMessage = null;

        try
        {
            AvailablePackages = await ArchiveService.GetAvailablePackagesAsync(Customer, ProjectId);

            // Auto-select if only one package
            if (AvailablePackages.Count == 1)
            {
                SelectedPackage = AvailablePackages[0];
            }
            else if (AvailablePackages.Count == 0)
            {
                ErrorMessage = "No packages available. Run Section Generation first.";
            }

            HasPackages = AvailablePackages.Any();

            Logger.LogInformation("Found {Count} packages for {Customer}/{ProjectId}",
                AvailablePackages.Count, Customer, ProjectId);
        }
        catch (Exception ex)
        {
            ErrorMessage = $"Failed to load packages: {ex.Message}";
            Logger.LogError(ex, "Error loading packages for {Customer}/{ProjectId}", Customer, ProjectId);
        }
        finally
        {
            IsLoadingPackages = false;
            StateHasChanged();
        }
    }
}
