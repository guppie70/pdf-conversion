@page "/generate-hierarchy"
@using PdfConversion.Models
@using PdfConversion.Services
@using PdfConversion.Shared
@inject IHierarchyService HierarchyService
@inject IProjectLabelService ProjectLabelService
@inject IUserSelectionService UserSelectionService
@inject IHeaderExtractionService HeaderExtractionService
@inject IXsltTransformationService XsltTransformationService
@inject ILogger<GenerateHierarchy> Logger

<PageTitle>Generate Hierarchy</PageTitle>

<div class="generate-hierarchy-page">
    <div class="page-header">
        <h3>Document Hierarchy Editor</h3>
        <div class="header-actions">
            <button class="btn btn-success" @onclick="SaveHierarchyAsync" disabled="@(!HasChanges || string.IsNullOrEmpty(SelectedProject))">
                <i class="bi bi-save"></i> Save
            </button>
            <button class="btn btn-secondary" disabled="true">
                <i class="bi bi-magic"></i> Generate with AI (Coming Soon)
            </button>
        </div>
    </div>

    <div class="settings-panel">
        <label>Source XML:</label>
        <ProjectFileSelector
            FileGroups="@ProjectFileGroups"
            SelectedValue="@GetSelectedFilePath()"
            OnSelectionChanged="@OnFilePathChangedFromComponent"
            CssClass="form-select"
            PlaceholderText="Select XML..." />

        <label>Hierarchy XML:</label>
        <select class="form-select"
                @bind="SelectedHierarchyXml"
                @bind:after="OnHierarchyXmlChangedAsync"
                disabled="@string.IsNullOrEmpty(SelectedSourceXml)">
            <option value="">Select hierarchy...</option>
            @foreach (var file in HierarchyXmlFiles)
            {
                <option value="@file">@Path.GetFileName(file)</option>
            }
        </select>
    </div>

    @if (!string.IsNullOrEmpty(AlertMessage))
    {
        <div class="alert alert-@AlertType alert-dismissible fade show mt-2" role="alert">
            @AlertMessage
            <button type="button" class="btn-close" @onclick="() => AlertMessage = null" aria-label="Close"></button>
        </div>
    }

    <div class="hierarchy-workspace">
        <div class="left-panel">
            <div class="panel-header">
                <h5>Hierarchy Tree</h5>
            </div>
            <div class="panel-content">
                @if (CurrentHierarchy != null)
                {
                    <HierarchyTreeView RootItem="CurrentHierarchy.Root"
                                     OnItemSelected="HandleItemSelected"
                                     OnItemEdited="HandleItemEdited"
                                     OnEditRequest="HandleEditRequest" />
                }
                else
                {
                    <div class="text-center p-5 text-muted">
                        <i class="bi bi-file-earmark-text" style="font-size: 3rem;"></i>
                        <p class="mt-3">Load a hierarchy file to get started</p>
                    </div>
                }
            </div>
        </div>

        <div class="right-panel">
            <AvailableHeadersPanel @ref="HeadersPanel"
                                  NormalizedXmlPath="@NormalizedXmlPath"
                                  HierarchyXmlPath="@HierarchyXmlPath"
                                  OnHeadersChanged="HandleHeadersChanged" />
        </div>
    </div>

    @if (ShowEditor && EditingItem != null)
    {
        <HierarchyItemEditor SelectedItem="EditingItem"
                            OnItemUpdated="HandleItemUpdated"
                            OnClosed="CloseEditor" />
    }
</div>

@code {
    private HierarchyStructure? CurrentHierarchy { get; set; }
    private HierarchyItem? SelectedItem { get; set; }
    private bool HasChanges { get; set; }
    private AvailableHeadersPanel? HeadersPanel { get; set; }

    // Editor panel state
    private HierarchyItem? EditingItem { get; set; }
    private bool ShowEditor => EditingItem != null;

    // Project and file selection state
    private List<ProjectInfo> Projects { get; set; } = new();
    private string? SelectedProject { get; set; } // Format: "customer/project-id"
    private string? SelectedSourceXml { get; set; } // Full path to XML file
    private string? SelectedXsltFile { get; set; } // XSLT file path from user selections
    private List<string> HierarchyXmlFiles { get; set; } = new();
    private string? SelectedHierarchyXml { get; set; }
    private bool IsLoadingDocument { get; set; }
    private bool IsLoadingHierarchy { get; set; }

    // ProjectFileSelector helper properties
    private List<ProjectFileGroup> ProjectFileGroups
    {
        get
        {
            if (Projects == null || !Projects.Any())
                return new();

            var groups = new List<ProjectFileGroup>();

            foreach (var project in Projects)
            {
                var customer = project.Customer;
                var projectId = project.ProjectId;

                // Group 1: Input files for this project
                var inputDir = $"/app/data/input/{customer}/projects/{projectId}";
                if (Directory.Exists(inputDir))
                {
                    var inputFiles = Directory.GetFiles(inputDir, "*.xml")
                        .Where(f => !f.Contains("/metadata/"))
                        .Select(f => new ProjectFile
                        {
                            FileName = Path.GetFileName(f),
                            FullPath = f
                        })
                        .ToList();

                    if (inputFiles.Any())
                    {
                        groups.Add(new ProjectFileGroup
                        {
                            Customer = customer,
                            ProjectId = projectId,
                            ProjectName = $"{project.CustomLabel ?? project.ProjectId} - Input Files",
                            Files = inputFiles
                        });
                    }
                }

                // Group 2: Output files for this project
                var outputDir = $"/app/data/output/{customer}/projects/{projectId}";
                if (Directory.Exists(outputDir))
                {
                    var outputFiles = Directory.GetFiles(outputDir, "*.xml")
                        .Where(f => !Path.GetFileName(f).Equals("hierarchy.xml", StringComparison.OrdinalIgnoreCase))
                        .Select(f => new ProjectFile
                        {
                            FileName = Path.GetFileName(f),
                            FullPath = f
                        })
                        .ToList();

                    if (outputFiles.Any())
                    {
                        groups.Add(new ProjectFileGroup
                        {
                            Customer = customer,
                            ProjectId = projectId,
                            ProjectName = $"{project.CustomLabel ?? project.ProjectId} - Output Files",
                            Files = outputFiles
                        });
                    }
                }
            }

            return groups;
        }
    }

    private string GetSelectedFilePath() =>
        !string.IsNullOrEmpty(SelectedSourceXml) ? SelectedSourceXml : string.Empty;

    private async Task OnFilePathChangedFromComponent(string filePath)
    {
        if (!string.IsNullOrEmpty(filePath))
        {
            SelectedSourceXml = filePath;

            // Extract project from file path
            // Path format: /app/data/input/{customer}/projects/{projectId}/file.xml
            // or: /app/data/output/{customer}/projects/{projectId}/file.xml
            var match = System.Text.RegularExpressions.Regex.Match(
                filePath,
                @"/app/data/(input|output)/([^/]+)/projects/([^/]+)/"
            );

            if (match.Success)
            {
                var customer = match.Groups[2].Value;
                var projectId = match.Groups[3].Value;
                SelectedProject = $"{customer}/{projectId}";
                Logger.LogInformation("Auto-selected project from file path: {Project}", SelectedProject);

                // Save project selection
                await UserSelectionService.UpdateSelectionAsync(projectId: SelectedProject);
                Logger.LogInformation("Saved project selection: {Project}", SelectedProject);
            }

            // Save source XML selection (just filename for portability)
            var filename = Path.GetFileName(filePath);
            await UserSelectionService.UpdateSelectionAsync(sourceXml: filename);
            Logger.LogInformation("Saved source XML selection: {File}", filename);

            await OnSourceXmlChangedAsync();
            LoadHierarchyXmlFiles();
        }
    }

    private void LoadHierarchyXmlFiles()
    {
        HierarchyXmlFiles.Clear();
        SelectedHierarchyXml = null;

        if (string.IsNullOrEmpty(SelectedSourceXml))
            return;

        // Extract project directory from source XML path
        // e.g., /app/data/input/taxxor/projects/ar25-1/docling-output.xml
        // -> /app/data/input/taxxor/projects/ar25-1
        var projectDir = Path.GetDirectoryName(SelectedSourceXml);
        if (string.IsNullOrEmpty(projectDir))
            return;

        var metadataDir = Path.Combine(projectDir, "metadata");
        if (!Directory.Exists(metadataDir))
            return;

        // Get all XML files in metadata folder
        HierarchyXmlFiles = Directory.GetFiles(metadataDir, "*.xml")
            .OrderBy(f => Path.GetFileName(f))
            .ToList();

        Logger.LogInformation("Found {Count} hierarchy XML files in {Dir}", HierarchyXmlFiles.Count, metadataDir);

        // Force Blazor to re-render the dropdown
        StateHasChanged();
    }

    private async Task OnHierarchyXmlChangedAsync()
    {
        if (!string.IsNullOrEmpty(SelectedHierarchyXml))
        {
            // Save to user selections (save just the filename for portability)
            var filename = Path.GetFileName(SelectedHierarchyXml);
            await UserSelectionService.UpdateSelectionAsync(hierarchyXml: filename);
            Logger.LogInformation("Saved hierarchy XML selection: {File}", filename);

            await LoadExistingHierarchyAsync();
        }
    }

    // Alert state
    private string? AlertMessage { get; set; }
    private string AlertType { get; set; } = "info"; // success, warning, danger, info

    // File paths for the headers panel - dynamic based on selection
    private string? NormalizedXmlPath { get; set; }
    private string? HierarchyXmlPath
    {
        get
        {
            if (string.IsNullOrEmpty(SelectedProject)) return null;
            var parts = SelectedProject.Split('/');
            if (parts.Length != 2) return null;
            return $"/app/data/output/{parts[0]}/projects/{parts[1]}/hierarchy.xml";
        }
    }

    protected override async Task OnInitializedAsync()
    {
        Logger.LogInformation("[OnInitializedAsync] Starting initialization");

        try
        {
            // Load all projects
            Projects = await ProjectLabelService.GetAllProjectsAsync("/app/data/input");
            Logger.LogInformation("[OnInitializedAsync] Loaded {Count} projects", Projects.Count);

            // Try to restore last selection
            var selection = await UserSelectionService.GetSelectionAsync();
            if (selection != null)
            {
                Logger.LogInformation("[OnInitializedAsync] Found user selections");

                // Restore project selection
                if (!string.IsNullOrEmpty(selection.LastSelectedProject))
                {
                    SelectedProject = selection.LastSelectedProject;
                    Logger.LogInformation("[OnInitializedAsync] Restored project: {Project}", SelectedProject);
                }

                // Restore source XML if available - reconstruct full path
                if (!string.IsNullOrEmpty(selection.LastSelectedSourceXml) && !string.IsNullOrEmpty(SelectedProject))
                {
                    var sourceXmlFilename = selection.LastSelectedSourceXml;
                    var parts = SelectedProject.Split('/');
                    if (parts.Length == 2)
                    {
                        var customer = parts[0];
                        var projectId = parts[1];

                        // Try input directory first
                        var inputPath = $"/app/data/input/{customer}/projects/{projectId}/{sourceXmlFilename}";
                        if (File.Exists(inputPath))
                        {
                            SelectedSourceXml = inputPath;
                            Logger.LogInformation("[OnInitializedAsync] Restored source XML from input: {File}", SelectedSourceXml);
                        }
                        else
                        {
                            // Try output directory as fallback
                            var outputPath = $"/app/data/output/{customer}/projects/{projectId}/{sourceXmlFilename}";
                            if (File.Exists(outputPath))
                            {
                                SelectedSourceXml = outputPath;
                                Logger.LogInformation("[OnInitializedAsync] Restored source XML from output: {File}", SelectedSourceXml);
                            }
                            else
                            {
                                Logger.LogWarning("[OnInitializedAsync] Source XML file not found: {File}", sourceXmlFilename);
                            }
                        }
                    }
                }

                // Restore XSLT selection
                if (!string.IsNullOrEmpty(selection.LastSelectedXslt))
                {
                    SelectedXsltFile = selection.LastSelectedXslt;
                    Logger.LogInformation("[OnInitializedAsync] Restored XSLT: {File}", SelectedXsltFile);
                }

                // If source XML was restored, load hierarchy files and transform
                if (!string.IsNullOrEmpty(SelectedSourceXml))
                {
                    // Load hierarchy XML files from metadata folder
                    LoadHierarchyXmlFiles();

                    // Auto-transform and load if XSLT is available
                    if (!string.IsNullOrEmpty(SelectedXsltFile))
                    {
                        await AutoTransformAndLoadAsync();
                    }

                    // Restore hierarchy XML selection if available
                    if (!string.IsNullOrEmpty(selection.LastSelectedHierarchyXml))
                    {
                        var hierarchyFilename = selection.LastSelectedHierarchyXml;

                        // Find matching file in HierarchyXmlFiles list
                        var matchingFile = HierarchyXmlFiles.FirstOrDefault(f =>
                            Path.GetFileName(f).Equals(hierarchyFilename, StringComparison.OrdinalIgnoreCase));

                        if (matchingFile != null)
                        {
                            SelectedHierarchyXml = matchingFile;
                            Logger.LogInformation("[OnInitializedAsync] Restored hierarchy XML: {File}", matchingFile);

                            // Auto-load the hierarchy
                            await OnHierarchyXmlChangedAsync();
                        }
                        else
                        {
                            Logger.LogWarning("[OnInitializedAsync] Hierarchy file not found: {File}", hierarchyFilename);
                        }
                    }
                }
                else
                {
                    Logger.LogInformation("[OnInitializedAsync] No source XML to restore");
                }
            }
            else
            {
                Logger.LogWarning("[OnInitializedAsync] No user selections found");
            }

            StateHasChanged();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "[OnInitializedAsync] Error during initialization");
            ToastNotification.ShowError($"Initialization error: {ex.Message}");
        }
    }

    private async Task OnSourceXmlChangedAsync()
    {
        try
        {
            if (!string.IsNullOrEmpty(SelectedSourceXml))
            {
                await UserSelectionService.UpdateSelectionAsync(sourceXml: SelectedSourceXml);
                await AutoTransformAndLoadAsync();
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error updating source XML selection");
            ShowAlert("danger", $"Error: {ex.Message}");
        }
    }

    private async Task LoadDocumentAsync(bool showToast = true)
    {
        if (string.IsNullOrEmpty(SelectedSourceXml)) return;

        IsLoadingDocument = true;
        try
        {
            // Warn if unsaved changes
            if (HasChanges && CurrentHierarchy != null)
            {
                // TODO: Show confirmation dialog
                Logger.LogWarning("Loading new document with unsaved changes");
            }

            // Clear current hierarchy
            CurrentHierarchy = null;
            HasChanges = false;

            // Load headers
            if (HeadersPanel != null)
            {
                await HeadersPanel.LoadHeadersAsync();
            }

            if (showToast)
            {
                ToastNotification.ShowSuccess($"Loaded document: {Path.GetFileName(SelectedSourceXml)}");
            }
            Logger.LogInformation("Loaded document headers from {Path}", SelectedSourceXml);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to load document");
            ToastNotification.ShowError($"Failed to load document: {ex.Message}");
        }
        finally
        {
            IsLoadingDocument = false;
        }
    }

    private async Task LoadExistingHierarchyAsync()
    {
        if (string.IsNullOrEmpty(SelectedHierarchyXml))
        {
            Logger.LogWarning("No hierarchy XML file selected");
            return;
        }

        IsLoadingHierarchy = true;
        try
        {
            if (!File.Exists(SelectedHierarchyXml))
            {
                ToastNotification.ShowError($"Hierarchy file not found: {Path.GetFileName(SelectedHierarchyXml)}");
                Logger.LogError("Hierarchy file not found: {Path}", SelectedHierarchyXml);
                return;
            }

            CurrentHierarchy = await HierarchyService.LoadHierarchyAsync(SelectedHierarchyXml);
            HasChanges = false;
            Logger.LogInformation("Loaded hierarchy from {Path}", SelectedHierarchyXml);
            ToastNotification.ShowSuccess($"Loaded hierarchy: {Path.GetFileName(SelectedHierarchyXml)}");

            // Refresh headers panel to mark used headers
            if (HeadersPanel != null)
            {
                await HeadersPanel.LoadHeadersAsync();
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to load hierarchy");
            ToastNotification.ShowError($"Failed to load hierarchy: {ex.Message}");
        }
        finally
        {
            IsLoadingHierarchy = false;
        }
    }

    private async Task SaveHierarchyAsync()
    {
        if (CurrentHierarchy == null || string.IsNullOrEmpty(SelectedProject))
        {
            ToastNotification.ShowError("No hierarchy to save or no project selected");
            return;
        }

        try
        {
            // Determine save path: use selected hierarchy XML if available, otherwise default
            string filePath;
            if (!string.IsNullOrEmpty(SelectedHierarchyXml))
            {
                // Save back to the selected hierarchy file
                filePath = SelectedHierarchyXml;
            }
            else
            {
                // Fallback to default hierarchy.xml location
                var parts = SelectedProject.Split('/');
                if (parts.Length != 2)
                {
                    Logger.LogError("Invalid project format: {Project}", SelectedProject);
                    ToastNotification.ShowError("Invalid project format");
                    return;
                }

                var customer = parts[0];
                var projectId = parts[1];
                filePath = $"/app/data/output/{customer}/projects/{projectId}/hierarchy.xml";
            }

            await HierarchyService.SaveHierarchyAsync(filePath, CurrentHierarchy);
            HasChanges = false;
            Logger.LogInformation("Saved hierarchy to {Path}", filePath);
            ToastNotification.ShowSuccess($"Saved hierarchy: {Path.GetFileName(filePath)}");

            // Refresh headers panel to update used status
            if (HeadersPanel != null)
            {
                await HeadersPanel.RefreshUsedStatusAsync();
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to save hierarchy");
            ToastNotification.ShowError($"Failed to save hierarchy: {ex.Message}");
        }
    }

    private void HandleItemSelected(HierarchyItem item)
    {
        SelectedItem = item;
    }

    private void HandleItemEdited(HierarchyItem item)
    {
        HasChanges = true;
    }

    private void HandleEditRequest(HierarchyItem item)
    {
        EditingItem = item;
        StateHasChanged();
    }

    private async Task HandleItemUpdated(HierarchyItem updatedItem)
    {
        // Item is already updated by reference, just mark as changed
        HasChanges = true;
        EditingItem = null;
        StateHasChanged();

        // Optionally refresh the headers panel to reflect changes
        if (HeadersPanel != null)
        {
            await HeadersPanel.RefreshUsedStatusAsync();
        }
    }

    private void CloseEditor()
    {
        EditingItem = null;
        StateHasChanged();
    }

    private async Task HandleHeadersChanged()
    {
        // Called when headers are loaded/refreshed
        StateHasChanged();
    }

    private string GetConfidenceColor(int confidence)
    {
        return confidence >= 80 ? "success" : confidence >= 70 ? "warning" : "danger";
    }

    private async Task AutoTransformAndLoadAsync()
    {
        if (string.IsNullOrEmpty(SelectedSourceXml) || string.IsNullOrEmpty(SelectedXsltFile))
        {
            if (string.IsNullOrEmpty(SelectedXsltFile))
            {
                ShowAlert("warning", "No XSLT file selected. Please transform a document on the Transform page first.");
            }
            return;
        }

        IsLoadingDocument = true;
        ClearAlert();

        try
        {
            // Warn if unsaved changes
            if (HasChanges && CurrentHierarchy != null)
            {
                Logger.LogWarning("Loading new document with unsaved changes");
            }

            // Clear current hierarchy
            CurrentHierarchy = null;
            HasChanges = false;

            // Read source XML
            var xmlContent = await File.ReadAllTextAsync(SelectedSourceXml);

            // Read XSLT
            var xsltPath = $"/app/xslt/{SelectedXsltFile}";
            if (!File.Exists(xsltPath))
            {
                ShowAlert("danger", $"XSLT file not found: {SelectedXsltFile}");
                return;
            }
            var xsltContent = await File.ReadAllTextAsync(xsltPath);

            // Transform
            Logger.LogInformation("Transforming {SourceXml} with {Xslt}", Path.GetFileName(SelectedSourceXml), SelectedXsltFile);
            var transformResult = await XsltTransformationService.TransformAsync(
                xmlContent,
                xsltContent,
                new TransformationOptions
                {
                    UseXslt3Service = true,
                    NormalizeHeaders = false
                },
                xsltPath  // Pass file path for module resolution
            );

            if (!transformResult.IsSuccess)
            {
                ShowAlert("danger", $"Transformation failed: {transformResult.ErrorMessage}");
                Logger.LogError("Transformation failed: {Error}", transformResult.ErrorMessage);
                return;
            }

            // Save transformed XML to normalized location
            var parts = SelectedProject?.Split('/');
            if (parts?.Length == 2)
            {
                var customer = parts[0];
                var projectId = parts[1];
                var normalizedPath = $"/app/data/output/{customer}/projects/{projectId}/normalized.xml";
                var normalizedDir = Path.GetDirectoryName(normalizedPath);
                if (!Directory.Exists(normalizedDir))
                {
                    Directory.CreateDirectory(normalizedDir!);
                }
                await File.WriteAllTextAsync(normalizedPath, transformResult.OutputContent);
                NormalizedXmlPath = normalizedPath;
                Logger.LogInformation("Saved normalized XML to {Path}", normalizedPath);
                Logger.LogInformation("NormalizedXmlPath set to: {Path}, File exists: {Exists}",
                    NormalizedXmlPath, File.Exists(NormalizedXmlPath));
            }

            // Load headers by passing the path directly (before parameter binding completes)
            Logger.LogInformation("About to load headers. HeadersPanel is null: {IsNull}, NormalizedXmlPath: {Path}",
                HeadersPanel == null, NormalizedXmlPath);

            if (HeadersPanel != null && !string.IsNullOrEmpty(NormalizedXmlPath))
            {
                await HeadersPanel.LoadHeadersAsync(NormalizedXmlPath, HierarchyXmlPath);
                Logger.LogInformation("Headers loaded. AllHeaders count from panel should be visible in AvailableHeadersPanel logs");
            }
            else
            {
                Logger.LogWarning("HeadersPanel is null or NormalizedXmlPath is empty, cannot load headers");
            }

            ShowAlert("success", $"Loaded and transformed: {Path.GetFileName(SelectedSourceXml)}");
            Logger.LogInformation("Successfully transformed and loaded document");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Auto-transform failed");
            ShowAlert("danger", $"Transformation error: {ex.Message}");
        }
        finally
        {
            IsLoadingDocument = false;
        }
    }

    private void ShowAlert(string type, string message)
    {
        AlertType = type;
        AlertMessage = message;
        StateHasChanged();
    }

    private void ClearAlert()
    {
        AlertMessage = null;
    }
}
