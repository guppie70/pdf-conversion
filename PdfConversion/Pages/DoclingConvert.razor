@page "/docling-convert"
@using System.Net.Http.Headers
@using System.Threading
@using Microsoft.AspNetCore.SignalR.Client
@using PdfConversion.Services
@using PdfConversion.Models
@inject IProjectLabelService ProjectLabelService
@inject IHttpClientFactory HttpClientFactory
@inject NavigationManager Navigation
@inject IJSRuntime JSRuntime
@inject ILogger<DoclingConvert> Logger
@inject DoclingJobPollingService JobPollingService
@inject IUserSelectionService UserSelectionService
@inject IBase64ImageExtractor ImageExtractor
@implements IAsyncDisposable

<PageTitle>Docling Convert - Step 1</PageTitle>

<div class="docling-convert-container">
    <div class="docling-header">
        <h3>Docling Convert - Step 1</h3>
        <p class="text-muted">Upload PDF or Word files and convert them to DocBook XML using Docling</p>
    </div>

    <!-- Configuration Panel -->
    <div class="docling-panel">
        <div class="panel-header">
            <h5>Configuration</h5>
        </div>
        <div class="panel-body">
            <!-- Mode Selection -->
            <div class="form-group mb-3">
                <label class="form-label">File Source</label>
                <div class="mode-selection">
                    <div class="form-check">
                        <input class="form-check-input"
                               type="radio"
                               name="fileMode"
                               id="modeNewUpload"
                               checked="@(FileMode == FileModeEnum.NewUpload)"
                               @onchange="@(() => HandleModeChange(FileModeEnum.NewUpload))"
                               disabled="@IsConverting">
                        <label class="form-check-label" for="modeNewUpload">
                            Upload New File
                        </label>
                    </div>
                    <div class="form-check">
                        <input class="form-check-input"
                               type="radio"
                               name="fileMode"
                               id="modeExistingFile"
                               checked="@(FileMode == FileModeEnum.ExistingFile)"
                               @onchange="@(() => HandleModeChange(FileModeEnum.ExistingFile))"
                               disabled="@IsConverting">
                        <label class="form-check-label" for="modeExistingFile">
                            Re-process Existing File
                        </label>
                    </div>
                </div>
            </div>

            @if (FileMode == FileModeEnum.NewUpload)
            {
                <!-- Project Selection for New Upload -->
                <div class="form-group">
                    <label for="projectSelect" class="form-label">Project</label>
                    <select id="projectSelect"
                            class="form-select"
                            value="@SelectedProject"
                            @onchange="HandleProjectChange"
                            disabled="@IsConverting">
                        <option value="">-- Select Project --</option>
                        @foreach (var customerGroup in Projects.GroupBy(p => p.Customer).OrderBy(g => g.Key))
                        {
                            <optgroup label="@customerGroup.Key">
                                @foreach (var project in customerGroup.OrderBy(p => p.ProjectId))
                                {
                                    <option value="@project.ProjectId">@project.DisplayString</option>
                                }
                            </optgroup>
                        }
                    </select>
                </div>

                <!-- Validation Alert -->
                @if (!IsConverting && string.IsNullOrEmpty(ErrorMessage) && string.IsNullOrEmpty(SuccessMessage))
                {
                    @if (string.IsNullOrEmpty(SelectedProject))
                    {
                        <div class="alert alert-warning mt-3" role="alert">
                            <i class="bi bi-exclamation-triangle"></i>
                            Please select a project to continue
                        </div>
                    }
                    else if (UploadedFile == null)
                    {
                        <div class="alert alert-warning mt-3" role="alert">
                            <i class="bi bi-exclamation-triangle"></i>
                            Please select a PDF or Word file to convert
                        </div>
                    }
                }

                <!-- File Upload Area -->
                <div class="form-group mt-3">
                    <label class="form-label">Document File</label>
                    <div class="upload-area @(IsDragging ? "dragging" : "")"
                         @ondragenter="HandleDragEnter"
                         @ondragleave="HandleDragLeave"
                         @ondragover:preventDefault
                         @ondrop="HandleDrop"
                         @ondrop:preventDefault>

                        @if (UploadedFile == null)
                        {
                            <div class="upload-prompt">
                                <i class="bi bi-cloud-arrow-up" style="font-size: 2.5rem; color: #0d6efd;"></i>
                                <p class="mt-2 mb-1"><strong>Drag & drop PDF or Word file here</strong></p>
                                <p class="text-muted small mb-1">or click to browse</p>
                                <p class="text-muted small mb-0">Supported: PDF, DOCX, DOC (max 50MB)</p>
                                <InputFile OnChange="HandleFileSelect" accept=".pdf,.docx,.doc" class="d-none" id="fileInput" />
                                <button type="button" class="btn btn-primary mt-2" @onclick="OpenFileDialog">
                                    Browse Files
                                </button>
                            </div>
                        }
                        else
                        {
                            <div class="file-info">
                                <i class="bi bi-file-earmark-check" style="font-size: 2rem; color: #28a745;"></i>
                                <div class="file-details mt-2">
                                    <p class="mb-1"><strong>@UploadedFile.Name</strong></p>
                                    <p class="text-muted mb-0">Size: @FormatFileSize(UploadedFile.Size)</p>
                                </div>
                                <button type="button" class="btn btn-secondary btn-sm mt-2" @onclick="ClearFile">
                                    <i class="bi bi-x-circle"></i> Clear
                                </button>
                            </div>
                        }
                    </div>
                </div>
            }
            else
            {
                <!-- Existing File Selection for Re-processing -->
                <div class="form-group">
                    <label for="existingFileSelect" class="form-label">Existing File</label>
                    <select id="existingFileSelect"
                            class="form-select"
                            value="@SelectedExistingFile"
                            @onchange="HandleExistingFileChange"
                            disabled="@IsConverting">
                        <option value="">-- Select Existing File --</option>
                        @foreach (var customerGroup in ExistingFiles.GroupBy(f => f.ProjectLabel).OrderBy(g => g.Key))
                        {
                            <optgroup label="@customerGroup.Key">
                                @foreach (var file in customerGroup.OrderBy(f => f.FileName))
                                {
                                    <option value="@file.FilePath">@file.FileName</option>
                                }
                            </optgroup>
                        }
                    </select>
                </div>

                <!-- Validation Alert for Existing File Mode -->
                @if (!IsConverting && string.IsNullOrEmpty(ErrorMessage) && string.IsNullOrEmpty(SuccessMessage))
                {
                    @if (string.IsNullOrEmpty(SelectedExistingFile))
                    {
                        <div class="alert alert-warning mt-3" role="alert">
                            <i class="bi bi-exclamation-triangle"></i>
                            Please select an existing file to re-process
                        </div>
                    }
                }
            }

            <!-- Output Format -->
            <div class="form-group mt-3">
                <label for="formatSelect" class="form-label">Output Format</label>
                <select id="formatSelect"
                        class="form-select"
                        value="@OutputFormat"
                        @onchange="HandleOutputFormatChange"
                        disabled="@IsConverting">
                    <option value="xml">XML</option>
                    <option value="html">HTML</option>
                    <option value="markdown">Markdown</option>
                    <option value="doctags">DocTags</option>
                    <option value="json">JSON</option>
                </select>
            </div>

            <!-- Convert Button -->
            <div class="button-group mt-3">
                <button class="btn btn-primary"
                        @onclick="ConvertWithDocling"
                        disabled="@(!IsReadyToConvert || IsConverting)">
                    @if (IsConverting)
                    {
                        <span class="spinner-border spinner-border-sm me-2" role="status"></span>
                        <span>Converting...</span>
                    }
                    else
                    {
                        <i class="bi bi-play-circle"></i>
                        <span> Convert with Docling</span>
                    }
                </button>

                @if (IsConverting && !string.IsNullOrEmpty(CurrentJobId))
                {
                    <button class="btn btn-secondary ms-2"
                            @onclick="CancelConversion">
                        <i class="bi bi-x-circle"></i>
                        <span> Cancel</span>
                    </button>
                }
            </div>

            <!-- Progress Bar -->
            @if (IsConverting)
            {
                <div class="mt-3">
                    <div class="progress" style="height: 30px;">
                        <div class="progress-bar progress-bar-striped progress-bar-animated @(JobProgress > 0.15 && JobProgress < 0.75 ? "processing-pulse" : "") d-flex align-items-center justify-content-center"
                             role="progressbar"
                             style="width: @((JobProgress * 100).ToString("F1"))%"
                             aria-valuenow="@((JobProgress * 100).ToString("F0"))"
                             aria-valuemin="0"
                             aria-valuemax="100">
                            @if (JobProgress > 0 && JobProgress < 1)
                            {
                                <span class="spinner-border spinner-border-sm me-1" role="status" style="width: 1rem; height: 1rem;"></span>
                            }
                            <span>@((JobProgress * 100).ToString("F0"))%</span>
                        </div>
                    </div>
                    <div class="text-muted small mt-1">
                        @JobStatusMessage
                        <span> - @ElapsedSeconds seconds elapsed</span>
                    </div>

                    @if (ActivityLog.Any())
                    {
                        <div class="card mt-2">
                            <div class="card-header py-1 px-2">
                                <small class="fw-bold">Activity Log</small>
                            </div>
                            <div @ref="_activityLogContainer" class="card-body p-2 activity-log-container">
                                @foreach (var log in ActivityLog.TakeLast(20))
                                {
                                    <div class="activity-log-entry">@log</div>
                                }
                            </div>
                        </div>
                    }
                </div>
            }
        </div>
    </div>

    <!-- Error Message -->
    @if (!string.IsNullOrEmpty(ErrorMessage))
    {
        <div class="alert alert-danger mt-3" role="alert">
            <i class="bi bi-exclamation-triangle"></i>
            <strong>Error:</strong> @ErrorMessage
            @if (ShowFallbackOption)
            {
                <div class="mt-2">
                    <button class="btn btn-outline-primary btn-sm" @onclick="NavigateToTransform">
                        <i class="bi bi-arrow-right-circle"></i> Use Adobe XML Pipeline Instead
                    </button>
                </div>
            }
        </div>
    }

    <!-- Success Message -->
    @if (!string.IsNullOrEmpty(SuccessMessage))
    {
        <div class="alert alert-success mt-3" role="alert">
            <i class="bi bi-check-circle"></i>
            <strong>Success:</strong> @SuccessMessage
        </div>
    }

    <!-- Preview Area -->
    @if (!string.IsNullOrEmpty(DoclingOutput))
    {
        <div class="docling-panel mt-3">
            <div class="panel-header">
                <h5>Conversion Output</h5>
            </div>
            <div class="panel-body">
                <div id="monacoPreviewContainer" class="monaco-container"></div>
                <div class="button-group mt-3">
                    <button class="btn btn-primary" @onclick="NavigateToTransform">
                        <i class="bi bi-arrow-right-circle"></i> Next: Transform
                    </button>
                </div>
            </div>
        </div>
    }
</div>

@code {
    // Enum for file mode
    private enum FileModeEnum
    {
        NewUpload,
        ExistingFile
    }

    // State
    private FileModeEnum FileMode { get; set; } = FileModeEnum.NewUpload;
    private List<ProjectInfo> Projects { get; set; } = new();
    private List<ExistingFileInfo> ExistingFiles { get; set; } = new();
    private string SelectedProject { get; set; } = string.Empty;
    private string SelectedExistingFile { get; set; } = string.Empty;
    private IBrowserFile? UploadedFile { get; set; }
    private byte[]? UploadedFileData { get; set; }
    private string? UploadedFileName { get; set; }
    private string? UploadedContentType { get; set; }
    private string OutputFormat { get; set; } = "html";
    private bool IsDragging { get; set; }
    private bool IsConverting { get; set; }
    private int ElapsedSeconds { get; set; }
    private string DoclingOutput { get; set; } = string.Empty;
    private string ErrorMessage { get; set; } = string.Empty;
    private string SuccessMessage { get; set; } = string.Empty;
    private bool ShowFallbackOption { get; set; }

    // Helper class for existing file info
    private class ExistingFileInfo
    {
        public string FilePath { get; set; } = string.Empty;
        public string FileName { get; set; } = string.Empty;
        public string ProjectId { get; set; } = string.Empty;
        public string Customer { get; set; } = string.Empty;
        public string ProjectLabel { get; set; } = string.Empty;
        public string DisplayString { get; set; } = string.Empty;
    }

    // Async job tracking
    private string? CurrentJobId { get; set; }
    private double JobProgress { get; set; }
    private string JobStatusMessage { get; set; } = string.Empty;
    private int? JobCurrentPage { get; set; }
    private int? JobTotalPages { get; set; }
    private List<string> ActivityLog { get; set; } = new();
    private ElementReference _activityLogContainer;

    // SignalR
    private HubConnection? _hubConnection;

    private System.Timers.Timer? _conversionTimer;
    private bool _monacoInitialized = false;

    private bool IsReadyToConvert
    {
        get
        {
            if (FileMode == FileModeEnum.NewUpload)
            {
                var hasProject = !string.IsNullOrEmpty(SelectedProject);
                var hasFile = UploadedFileData != null;
                var isReady = hasProject && hasFile;
                Logger.LogInformation($"[IsReadyToConvert] Mode=NewUpload, hasProject={hasProject} ('{SelectedProject}'), hasFile={hasFile}, isReady={isReady}");
                return isReady;
            }
            else
            {
                var hasExistingFile = !string.IsNullOrEmpty(SelectedExistingFile);
                Logger.LogInformation($"[IsReadyToConvert] Mode=ExistingFile, hasExistingFile={hasExistingFile} ('{SelectedExistingFile}')");
                return hasExistingFile;
            }
        }
    }

    protected override async Task OnInitializedAsync()
    {
        try
        {
            Logger.LogInformation("[OnInitializedAsync] Starting initialization");
            await LoadProjectsAsync();
            await LoadExistingFilesAsync();
            await InitializeSignalR();
            await RestoreUserSelectionsAsync();
            Logger.LogInformation($"[OnInitializedAsync] Initialized with {Projects.Count} projects and {ExistingFiles.Count} existing files");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error initializing DoclingConvert page");
            ErrorMessage = $"Failed to load projects: {ex.Message}";
        }
    }

    private async Task InitializeSignalR()
    {
        try
        {
            _hubConnection = new HubConnectionBuilder()
                .WithUrl(Navigation.ToAbsoluteUri("/hubs/docling-progress"))
                .WithAutomaticReconnect()
                .Build();

            _hubConnection.On<DoclingJobInfo>("ProgressUpdate", HandleProgressUpdate);

            await _hubConnection.StartAsync();
            Logger.LogInformation("SignalR connection established");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to initialize SignalR");
        }
    }

    private void HandleProgressUpdate(DoclingJobInfo jobInfo)
    {
        try
        {
            if (jobInfo.JobId != CurrentJobId)
            {
                return;
            }

            Logger.LogDebug($"Progress update: {jobInfo.Progress:P0} - {jobInfo.Message}");

            JobProgress = jobInfo.Progress;
            JobStatusMessage = jobInfo.Message;
            JobCurrentPage = jobInfo.CurrentPage;
            JobTotalPages = jobInfo.TotalPages;

            // Add message to activity log with timestamp
            if (!string.IsNullOrEmpty(jobInfo.Message))
            {
                var timestamp = DateTime.Now.ToString("HH:mm:ss");
                ActivityLog.Add($"[{timestamp}] {jobInfo.Message}");

                // Keep only last 50 messages to avoid memory issues
                if (ActivityLog.Count > 50)
                {
                    ActivityLog.RemoveRange(0, ActivityLog.Count - 50);
                }
            }

            // Handle completion
            if (jobInfo.Status == DoclingJobStatus.Completed)
            {
                _ = HandleJobCompletion(jobInfo);
            }
            else if (jobInfo.Status == DoclingJobStatus.Failed)
            {
                HandleJobFailure(jobInfo);
            }
            else if (jobInfo.Status == DoclingJobStatus.Cancelled)
            {
                HandleJobCancellation();
            }

            // Update UI and auto-scroll activity log
            InvokeAsync(async () =>
            {
                StateHasChanged();
                await Task.Delay(50); // Let DOM update
                await ScrollActivityLogToBottom();
            });
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error handling progress update");
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            Logger.LogInformation($"[OnAfterRenderAsync] First render - SelectedProject='{SelectedProject}', UploadedFile={UploadedFile?.Name ?? "null"}");
        }

        if (!string.IsNullOrEmpty(DoclingOutput) && !_monacoInitialized)
        {
            try
            {
                await InitializeMonacoEditor();
                _monacoInitialized = true;
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Error initializing Monaco editor");
            }
        }
    }

    private async Task LoadProjectsAsync()
    {
        try
        {
            var projects = await ProjectLabelService.GetAllProjectsAsync("/app/data/input");
            // Sort by customer and project ID for grouped display
            Projects = projects
                .OrderBy(p => p.Customer)
                .ThenBy(p => p.ProjectId)
                .ToList();
            Logger.LogInformation($"Loaded {Projects.Count} projects");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading projects");
            throw;
        }
    }

    private async Task LoadExistingFilesAsync()
    {
        try
        {
            var existingFiles = new List<ExistingFileInfo>();
            var basePath = "/app/data/input";
            var supportedExtensions = new[] { ".pdf", ".docx", ".doc" };

            // Load projects to get labels
            var projects = await ProjectLabelService.GetAllProjectsAsync(basePath);

            // Scan all project directories for PDF/Word files
            if (Directory.Exists(basePath))
            {
                foreach (var project in projects)
                {
                    if (Directory.Exists(project.FolderPath))
                    {
                        var files = Directory.GetFiles(project.FolderPath)
                            .Where(f => supportedExtensions.Contains(Path.GetExtension(f).ToLowerInvariant()))
                            .ToList();

                        foreach (var filePath in files)
                        {
                            var fileName = Path.GetFileName(filePath);
                            existingFiles.Add(new ExistingFileInfo
                            {
                                FilePath = filePath,
                                FileName = fileName,
                                ProjectId = project.ProjectId,
                                Customer = project.Customer,
                                ProjectLabel = project.CustomLabel ?? project.ProjectId,
                                DisplayString = $"{project.CustomLabel ?? project.ProjectId} - {fileName}"
                            });
                        }
                    }
                }
            }

            ExistingFiles = existingFiles.OrderBy(f => f.ProjectLabel).ThenBy(f => f.FileName).ToList();
            Logger.LogInformation($"Loaded {ExistingFiles.Count} existing files");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading existing files");
            throw;
        }
    }

    private async Task RestoreUserSelectionsAsync()
    {
        try
        {
            var selection = await UserSelectionService.GetSelectionAsync();

            // Restore file mode
            if (!string.IsNullOrEmpty(selection.LastDoclingFileMode))
            {
                if (Enum.TryParse<FileModeEnum>(selection.LastDoclingFileMode, out var mode))
                {
                    FileMode = mode;
                    Logger.LogInformation($"Restored file mode: {FileMode}");
                }
            }

            // Restore output format
            if (!string.IsNullOrEmpty(selection.LastDoclingOutputFormat))
            {
                OutputFormat = selection.LastDoclingOutputFormat;
                Logger.LogInformation($"Restored output format: {OutputFormat}");
            }

            // Restore project selection (for NewUpload mode)
            if (!string.IsNullOrEmpty(selection.LastDoclingProject))
            {
                // Parse "customer/project-id" format
                var parts = selection.LastDoclingProject.Split('/');
                if (parts.Length == 2)
                {
                    var customer = parts[0];
                    var projectId = parts[1];

                    // Find matching project by customer and project ID
                    var project = Projects.FirstOrDefault(p => p.Customer == customer && p.ProjectId == projectId);
                    if (project != null)
                    {
                        SelectedProject = project.ProjectId;
                        Logger.LogInformation($"Restored project: {customer}/{projectId}");
                    }
                    else
                    {
                        Logger.LogWarning($"Saved project '{selection.LastDoclingProject}' no longer exists");
                    }
                }
                else
                {
                    // Legacy format (just project ID) - try to find first matching project
                    var project = Projects.FirstOrDefault(p => p.ProjectId == selection.LastDoclingProject);
                    if (project != null)
                    {
                        SelectedProject = project.ProjectId;
                        Logger.LogInformation($"Restored project using legacy format: {SelectedProject}");
                    }
                    else
                    {
                        Logger.LogWarning($"Saved project '{selection.LastDoclingProject}' no longer exists");
                    }
                }
            }

            // Restore existing file selection (for ExistingFile mode)
            if (FileMode == FileModeEnum.ExistingFile && !string.IsNullOrEmpty(selection.LastDoclingExistingFile))
            {
                var fileExists = ExistingFiles.Any(f => f.FilePath == selection.LastDoclingExistingFile);
                if (fileExists)
                {
                    SelectedExistingFile = selection.LastDoclingExistingFile;
                    Logger.LogInformation($"Restored existing file: {SelectedExistingFile}");

                    // Load the file data (this will also set SelectedProject)
                    await LoadExistingFileDataAsync(SelectedExistingFile);
                }
                else
                {
                    Logger.LogWarning($"Saved file '{selection.LastDoclingExistingFile}' no longer exists, falling back to NewUpload mode");
                    FileMode = FileModeEnum.NewUpload;
                    SelectedExistingFile = string.Empty;
                }
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error restoring user selections");
            // Don't fail initialization if restoration fails - just use defaults
        }
    }

    private async Task LoadExistingFileDataAsync(string filePath)
    {
        try
        {
            // Load the file data for conversion
            var fileData = await File.ReadAllBytesAsync(filePath);
            UploadedFileData = fileData;
            UploadedFileName = Path.GetFileName(filePath);

            // Determine content type based on extension
            var extension = Path.GetExtension(filePath).ToLowerInvariant();
            UploadedContentType = extension switch
            {
                ".pdf" => "application/pdf",
                ".docx" => "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
                ".doc" => "application/msword",
                _ => "application/octet-stream"
            };

            // Set SelectedProject from the file's project
            var fileInfo = ExistingFiles.FirstOrDefault(f => f.FilePath == filePath);
            if (fileInfo != null)
            {
                SelectedProject = fileInfo.ProjectId;
            }

            Logger.LogInformation($"Loaded existing file: {UploadedFileName} ({FormatFileSize(fileData.Length)})");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading existing file data");
            throw;
        }
    }

    private async void HandleModeChange(FileModeEnum newMode)
    {
        FileMode = newMode;
        ErrorMessage = string.Empty;
        SuccessMessage = string.Empty;

        // Clear state when switching modes
        if (newMode == FileModeEnum.NewUpload)
        {
            SelectedExistingFile = string.Empty;
        }
        else
        {
            SelectedProject = string.Empty;
            ClearFile();
        }

        // Save file mode selection
        await SaveFileModeAsync();

        StateHasChanged();
    }

    private async Task SaveFileModeAsync()
    {
        try
        {
            var selection = await UserSelectionService.GetSelectionAsync();
            selection.LastDoclingFileMode = FileMode.ToString();
            await UserSelectionService.SaveSelectionAsync(selection);
            Logger.LogDebug($"Saved file mode: {FileMode}");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error saving file mode selection");
        }
    }

    private async Task HandleExistingFileChange(ChangeEventArgs e)
    {
        SelectedExistingFile = e.Value?.ToString() ?? string.Empty;

        if (!string.IsNullOrEmpty(SelectedExistingFile))
        {
            try
            {
                await LoadExistingFileDataAsync(SelectedExistingFile);

                // Save existing file selection with full customer/project path
                var fileInfo = ExistingFiles.FirstOrDefault(f => f.FilePath == SelectedExistingFile);
                if (fileInfo != null)
                {
                    var selection = await UserSelectionService.GetSelectionAsync();
                    selection.LastDoclingExistingFile = SelectedExistingFile;
                    // Store in "customer/project-id" format
                    selection.LastDoclingProject = $"{fileInfo.Customer}/{fileInfo.ProjectId}";
                    await UserSelectionService.SaveSelectionAsync(selection);
                    Logger.LogDebug($"Saved existing file selection: {SelectedExistingFile}, project: {selection.LastDoclingProject}");
                }
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Error loading existing file");
                ErrorMessage = $"Failed to load file: {ex.Message}";
                SelectedExistingFile = string.Empty;
                UploadedFileData = null;
            }
        }

        StateHasChanged();
    }

    private async Task OpenFileDialog()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("eval", "document.getElementById('fileInput').click()");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error opening file dialog");
        }
    }

    private void HandleDragEnter()
    {
        IsDragging = true;
    }

    private void HandleDragLeave()
    {
        IsDragging = false;
    }

    private void HandleDrop()
    {
        IsDragging = false;
    }

    private async Task HandleFileSelect(InputFileChangeEventArgs e)
    {
        try
        {
            var file = e.File;
            UploadedFileName = file.Name;
            UploadedContentType = file.ContentType;

            // Read file data immediately to avoid stale reference
            using var stream = file.OpenReadStream(maxAllowedSize: 50 * 1024 * 1024);
            using var memoryStream = new MemoryStream();
            await stream.CopyToAsync(memoryStream);
            UploadedFileData = memoryStream.ToArray();

            UploadedFile = file; // Keep for display purposes
            ErrorMessage = string.Empty;
            SuccessMessage = string.Empty;
            Logger.LogInformation($"File loaded: {UploadedFileName} ({FormatFileSize(UploadedFileData.Length)} bytes)");
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error reading uploaded file");
            ErrorMessage = $"Failed to load file: {ex.Message}";
            UploadedFile = null;
            UploadedFileData = null;
            StateHasChanged();
        }
    }

    private async void HandleProjectChange(ChangeEventArgs e)
    {
        SelectedProject = e.Value?.ToString() ?? string.Empty;
        Logger.LogInformation($"[HandleProjectChange] Project changed to: '{SelectedProject}'");
        Logger.LogInformation($"[HandleProjectChange] State after project change - SelectedProject='{SelectedProject}', UploadedFile={UploadedFile?.Name ?? "null"}");

        // Save project selection
        if (!string.IsNullOrEmpty(SelectedProject))
        {
            try
            {
                // Find the project to get customer information
                var project = Projects.FirstOrDefault(p => p.ProjectId == SelectedProject);
                if (project != null)
                {
                    var selection = await UserSelectionService.GetSelectionAsync();
                    // Store in "customer/project-id" format
                    selection.LastDoclingProject = $"{project.Customer}/{project.ProjectId}";
                    await UserSelectionService.SaveSelectionAsync(selection);
                    Logger.LogDebug($"Saved project selection: {selection.LastDoclingProject}");
                }
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Error saving project selection");
            }
        }

        StateHasChanged();
    }

    private async void HandleOutputFormatChange(ChangeEventArgs e)
    {
        OutputFormat = e.Value?.ToString() ?? "html";
        Logger.LogInformation($"[HandleOutputFormatChange] Output format changed to: '{OutputFormat}'");

        // Save output format selection
        try
        {
            var selection = await UserSelectionService.GetSelectionAsync();
            selection.LastDoclingOutputFormat = OutputFormat;
            await UserSelectionService.SaveSelectionAsync(selection);
            Logger.LogDebug($"Saved output format: {OutputFormat}");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error saving output format selection");
        }

        StateHasChanged();
    }

    private void ClearFile()
    {
        UploadedFile = null;
        UploadedFileData = null;
        UploadedFileName = null;
        UploadedContentType = null;
        DoclingOutput = string.Empty;
        ErrorMessage = string.Empty;
        SuccessMessage = string.Empty;
        _monacoInitialized = false;
        StateHasChanged(); // Trigger UI update to enable/disable button
    }

    private async Task ConvertWithDocling()
    {
        if (UploadedFileData == null || string.IsNullOrEmpty(UploadedFileName) || string.IsNullOrEmpty(SelectedProject))
        {
            ErrorMessage = "File data not available. Please select the file again.";
            return;
        }

        IsConverting = true;
        ElapsedSeconds = 0;
        ErrorMessage = string.Empty;
        SuccessMessage = string.Empty;
        ShowFallbackOption = false;
        DoclingOutput = string.Empty;
        _monacoInitialized = false;
        CurrentJobId = null;
        JobProgress = 0;
        JobStatusMessage = "Starting conversion...";
        JobCurrentPage = null;
        JobTotalPages = null;
        ActivityLog.Clear();

        // Start elapsed time timer
        _conversionTimer = new System.Timers.Timer(1000);
        _conversionTimer.Elapsed += (s, e) =>
        {
            ElapsedSeconds++;
            InvokeAsync(StateHasChanged);
        };
        _conversionTimer.Start();

        try
        {
            Logger.LogInformation($"Starting async conversion: project={SelectedProject}, file={UploadedFileName}, format={OutputFormat}");

            // Prepare multipart form data
            using var content = new MultipartFormDataContent();

            var fileContent = new ByteArrayContent(UploadedFileData);
            fileContent.Headers.ContentType = new MediaTypeHeaderValue(UploadedContentType ?? "application/octet-stream");
            content.Add(fileContent, "file", UploadedFileName);
            content.Add(new StringContent(OutputFormat), "output_format");

            // Call async endpoint to start job
            var httpClient = HttpClientFactory.CreateClient("DoclingService");
            var response = await httpClient.PostAsync("/convert-async", content);

            if (!response.IsSuccessStatusCode)
            {
                var error = await response.Content.ReadAsStringAsync();
                ErrorMessage = $"Failed to start conversion: {error}";
                Logger.LogError($"Failed to start job: HTTP {response.StatusCode} - {error}");
                IsConverting = false;
                _conversionTimer?.Stop();
                return;
            }

            var jobStartResponse = await response.Content.ReadFromJsonAsync<DoclingJobStartResponse>();
            if (jobStartResponse == null)
            {
                ErrorMessage = "Failed to parse job response";
                IsConverting = false;
                _conversionTimer?.Stop();
                return;
            }

            CurrentJobId = jobStartResponse.JobId;
            Logger.LogInformation($"Job started: {CurrentJobId}");

            // Subscribe to SignalR updates for this job
            if (_hubConnection?.State == HubConnectionState.Connected)
            {
                await _hubConnection.InvokeAsync("SubscribeToJob", CurrentJobId);
                Logger.LogInformation($"Subscribed to job {CurrentJobId} via SignalR");
            }

            // Start polling service tracking
            JobPollingService.StartTracking(CurrentJobId, "current-user");
        }
        catch (HttpRequestException ex)
        {
            _conversionTimer?.Stop();
            IsConverting = false;
            ErrorMessage = $"Connection error: Unable to reach Docling service. {ex.Message}";
            ShowFallbackOption = true;
            Logger.LogError(ex, "HTTP request error calling Docling service");
        }
        catch (Exception ex)
        {
            _conversionTimer?.Stop();
            IsConverting = false;
            ErrorMessage = $"Unexpected error: {ex.Message}";
            ShowFallbackOption = true;
            Logger.LogError(ex, "Error starting Docling conversion");
        }
    }

    private async Task HandleJobCompletion(DoclingJobInfo jobInfo)
    {
        try
        {
            _conversionTimer?.Stop();
            IsConverting = false;

            Logger.LogInformation($"Job {jobInfo.JobId} completed successfully");

            // Fetch result with base64-embedded images
            var httpClient = HttpClientFactory.CreateClient("DoclingService");
            var response = await httpClient.GetAsync($"/jobs/{jobInfo.JobId}/result");

            if (response.IsSuccessStatusCode)
            {
                var result = await response.Content.ReadFromJsonAsync<DoclingJobResultResponse>();
                if (result?.Success == true && result.OutputContent != null)
                {
                    var htmlWithBase64 = result.OutputContent;
                    Logger.LogInformation($"Retrieved result: {htmlWithBase64.Length} bytes with base64-embedded images");

                    // Determine project folder based on mode
                    string projectFolderPath;
                    string baseFilename;

                    if (FileMode == FileModeEnum.ExistingFile && !string.IsNullOrEmpty(SelectedExistingFile))
                    {
                        // Existing file mode - derive project folder from file path
                        // Example: /app/data/input/taxxor/projects/ar25-1/taxxor-small.pdf
                        // -> project folder: /app/data/input/taxxor/projects/ar25-1
                        projectFolderPath = Path.GetDirectoryName(SelectedExistingFile) ?? string.Empty;
                        baseFilename = Path.GetFileNameWithoutExtension(SelectedExistingFile);
                        Logger.LogInformation($"ExistingFile mode: Using project folder from file path: {projectFolderPath}");
                    }
                    else
                    {
                        // New upload mode - find project by ProjectId
                        var project = Projects.FirstOrDefault(p => p.ProjectId == SelectedProject);
                        if (project == null)
                        {
                            ErrorMessage = "Selected project not found";
                            return;
                        }
                        projectFolderPath = project.FolderPath;
                        baseFilename = Path.GetFileNameWithoutExtension(UploadedFileName ?? "document");
                        Logger.LogInformation($"NewUpload mode: Using project folder: {projectFolderPath}");
                    }

                    if (string.IsNullOrEmpty(projectFolderPath))
                    {
                        ErrorMessage = "Could not determine project folder path";
                        return;
                    }

                    // Determine if this format needs image extraction
                    bool needsImageExtraction = OutputFormat == "xml" || OutputFormat == "html" || OutputFormat == "markdown";
                    string outputContent;
                    int imageCount = 0;

                    if (needsImageExtraction)
                    {
                        // Extract images and replace base64 with file references
                        var imagesPath = Path.Combine(projectFolderPath, "images", "from-conversion");
                        Directory.CreateDirectory(imagesPath);

                        Logger.LogInformation($"Extracting images to: {imagesPath}");
                        var modifiedHtml = await ImageExtractor.ExtractAndReplaceImagesAsync(
                            htmlWithBase64,
                            imagesPath,
                            baseFilename);

                        // Count extracted images
                        if (Directory.Exists(imagesPath))
                        {
                            imageCount = Directory.GetFiles(imagesPath).Length;
                        }

                        // Convert to XML if user selected XML format
                        if (OutputFormat == "xml")
                        {
                            Logger.LogInformation("Converting HTML to XML format");
                            outputContent = ConvertHtmlToXml(modifiedHtml);
                        }
                        else
                        {
                            outputContent = modifiedHtml;
                        }
                    }
                    else
                    {
                        // DocTags and JSON formats - save as-is without image extraction
                        Logger.LogInformation($"Saving {OutputFormat} format without image extraction");
                        outputContent = htmlWithBase64;  // Actually contains DocTags or JSON content from Docling
                    }

                    // Save with appropriate file extension
                    var fileExtension = OutputFormat switch
                    {
                        "xml" => "xml",
                        "markdown" => "md",
                        "doctags" => "doctags",
                        "json" => "json",
                        _ => "html"  // default for html format
                    };
                    var outputPath = Path.Combine(projectFolderPath, $"docling-output.{fileExtension}");
                    await File.WriteAllTextAsync(outputPath, outputContent, System.Text.Encoding.UTF8);
                    Logger.LogInformation($"Saved output to: {outputPath}");

                    // Update Monaco display
                    DoclingOutput = outputContent;

                    // Build success message
                    var imageInfo = needsImageExtraction && imageCount > 0
                        ? $" with {imageCount} images extracted"
                        : "";
                    SuccessMessage = $"Conversion successful! Processed {result.PageCount ?? 0} pages in {ElapsedSeconds} seconds{imageInfo}. Output saved to {outputPath}";
                    Logger.LogInformation($"Conversion complete{(needsImageExtraction ? " with image extraction" : "")}");
                }
                else
                {
                    ErrorMessage = result?.Error ?? "Failed to retrieve conversion result";
                }
            }
            else
            {
                ErrorMessage = "Failed to retrieve conversion result";
            }

            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error handling job completion");
            ErrorMessage = $"Error retrieving result: {ex.Message}";
            await InvokeAsync(StateHasChanged);
        }
    }

    private string ConvertHtmlToXml(string htmlContent)
    {
        try
        {
            // Load HTML with HtmlAgilityPack
            var htmlDoc = new HtmlAgilityPack.HtmlDocument();
            htmlDoc.LoadHtml(htmlContent);

            // Remove all <style> elements
            var styleNodes = htmlDoc.DocumentNode.SelectNodes("//style");
            if (styleNodes != null)
            {
                foreach (var styleNode in styleNodes)
                {
                    styleNode.Remove();
                }
                Logger.LogDebug($"Removed {styleNodes.Count} style elements");
            }

            // Clean up <title> element - remove CDATA wrapper
            var titleNode = htmlDoc.DocumentNode.SelectSingleNode("//title");
            if (titleNode != null)
            {
                // Get the raw inner content
                var rawContent = titleNode.InnerHtml;

                // Extract text from CDATA section if present
                string titleText;
                if (rawContent.Contains("CDATA"))
                {
                    // Extract content between CDATA markers
                    var cdataPattern = @"(?://)?\s*<!\[CDATA\[\s*(.*?)\s*\]\]>\s*(?://)?";
                    var match = System.Text.RegularExpressions.Regex.Match(rawContent, cdataPattern,
                        System.Text.RegularExpressions.RegexOptions.Singleline);

                    if (match.Success)
                    {
                        titleText = match.Groups[1].Value.Trim();
                    }
                    else
                    {
                        // Fallback: use InnerText and clean it
                        titleText = titleNode.InnerText.Trim();
                    }
                }
                else
                {
                    titleText = titleNode.InnerText.Trim();
                }

                // Clear the node and set clean text content
                titleNode.RemoveAllChildren();
                titleNode.AppendChild(htmlDoc.CreateTextNode(titleText));

                Logger.LogDebug($"Cleaned title: '{titleText}'");
            }

            // Configure output as XML (not HTML)
            htmlDoc.OptionOutputAsXml = true;
            htmlDoc.OptionWriteEmptyNodes = true;
            htmlDoc.OptionAutoCloseOnEnd = true;

            // Find the root <html> element
            var htmlElement = htmlDoc.DocumentNode.SelectSingleNode("//html");
            if (htmlElement == null)
            {
                Logger.LogWarning("No <html> element found, using document node");
                htmlElement = htmlDoc.DocumentNode;
            }

            // Generate XML output
            using var writer = new System.IO.StringWriter();

            // Write XML declaration
            writer.WriteLine("<?xml version=\"1.0\" encoding=\"UTF-8\"?>");

            // Write only the <html> element (not the document node to avoid span wrapper)
            htmlElement.WriteTo(writer);

            return writer.ToString();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error converting HTML to XML");
            // Return original HTML if conversion fails
            return htmlContent;
        }
    }

    private void HandleJobFailure(DoclingJobInfo jobInfo)
    {
        _conversionTimer?.Stop();
        IsConverting = false;
        ErrorMessage = $"Conversion failed: {jobInfo.Error}";
        Logger.LogError($"Job {jobInfo.JobId} failed: {jobInfo.Error}");
    }

    private void HandleJobCancellation()
    {
        _conversionTimer?.Stop();
        IsConverting = false;
        ErrorMessage = "Conversion was cancelled";
        Logger.LogInformation("Job was cancelled");
    }

    private async Task CancelConversion()
    {
        if (string.IsNullOrEmpty(CurrentJobId))
        {
            return;
        }

        try
        {
            var httpClient = HttpClientFactory.CreateClient("DoclingService");
            var response = await httpClient.DeleteAsync($"/jobs/{CurrentJobId}");

            if (response.IsSuccessStatusCode)
            {
                Logger.LogInformation($"Cancelled job {CurrentJobId}");
            }
            else
            {
                Logger.LogWarning($"Failed to cancel job {CurrentJobId}: {response.StatusCode}");
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, $"Error cancelling job {CurrentJobId}");
        }
    }

    private async Task InitializeMonacoEditor()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync(
                "eval",
                @"
                if (typeof monaco !== 'undefined') {
                    const container = document.getElementById('monacoPreviewContainer');
                    if (container) {
                        const editor = monaco.editor.create(container, {
                            value: " + System.Text.Json.JsonSerializer.Serialize(DoclingOutput) + @",
                            language: 'xml',
                            theme: 'vs-dark',
                            readOnly: true,
                            automaticLayout: true,
                            minimap: { enabled: true },
                            scrollBeyondLastLine: false,
                            fontSize: 13,
                            lineNumbers: 'on',
                            wordWrap: 'on'
                        });
                    }
                }
                "
            );
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error initializing Monaco editor");
        }
    }

    private void NavigateToTransform()
    {
        Navigation.NavigateTo("/development");
    }

    private string FormatFileSize(long bytes)
    {
        string[] sizes = { "B", "KB", "MB", "GB" };
        double len = bytes;
        int order = 0;
        while (len >= 1024 && order < sizes.Length - 1)
        {
            order++;
            len = len / 1024;
        }
        return $"{len:0.##} {sizes[order]}";
    }

    private async Task ScrollActivityLogToBottom()
    {
        try
        {
            // Only scroll if there are activity logs to show
            if (!ActivityLog.Any())
            {
                return;
            }

            // Call JavaScript function to scroll container to bottom
            await JSRuntime.InvokeVoidAsync("scrollToBottom", _activityLogContainer);
        }
        catch (Exception ex)
        {
            // Log but don't fail on scroll errors - it's a UX enhancement
            Logger.LogDebug(ex, "Error scrolling activity log to bottom");
        }
    }

    public void Dispose()
    {
        _conversionTimer?.Stop();
        _conversionTimer?.Dispose();
    }

    public async ValueTask DisposeAsync()
    {
        _conversionTimer?.Stop();
        _conversionTimer?.Dispose();

        if (_hubConnection != null)
        {
            try
            {
                if (!string.IsNullOrEmpty(CurrentJobId))
                {
                    await _hubConnection.InvokeAsync("UnsubscribeFromJob", CurrentJobId);
                    JobPollingService.StopTracking(CurrentJobId);
                }

                await _hubConnection.DisposeAsync();
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Error disposing SignalR connection");
            }
        }
    }
}
