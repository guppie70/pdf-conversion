@page "/development"
@using PdfConversion.Services
@using PdfConversion.Models
@using PdfConversion.Shared
@using Microsoft.JSInterop
@using static PdfConversion.Shared.LoadingSkeleton
@implements IAsyncDisposable
@inject IProjectManagementService ProjectService
@inject IXsltTransformationService XsltService
@inject IFileService FileService
@inject IJSRuntime JSRuntime
@inject ILogger<Development> Logger
@inject DevelopmentToolbarState ToolbarState
@inject ThemeService ThemeService

<PageTitle>Development Mode</PageTitle>

<!-- Settings Panel (floating overlay when settings button clicked) -->
@if (ShowSettings)
{
    <div class="settings-overlay">
        <div class="settings-panel">
            <div class="settings-header">
                <h6 class="mb-0">Transformation Settings</h6>
                <button type="button" class="btn-close" @onclick="ToggleSettings" aria-label="Close"></button>
            </div>
            <div class="settings-body">
                <div class="form-check mb-2">
                    <input class="form-check-input" type="checkbox" id="useXslt3" @bind="UseXslt3Service" @bind:after="OnSettingsChanged">
                    <label class="form-check-label" for="useXslt3">
                        Use XSLT3 Service (XSLT 2.0/3.0)
                    </label>
                </div>
                <div class="form-check mb-2">
                    <input class="form-check-input" type="checkbox" id="normalizeHeaders" @bind="NormalizeHeaders" @bind:after="OnSettingsChanged">
                    <label class="form-check-label" for="normalizeHeaders">
                        Normalize Headers
                    </label>
                </div>
                <div class="form-check mb-2">
                    <input class="form-check-input" type="checkbox" id="autoTransform" @bind="AutoTransform" @bind:after="OnSettingsChanged">
                    <label class="form-check-label" for="autoTransform">
                        Auto-transform on XSLT change
                    </label>
                </div>

                <hr class="my-3" />

                <div class="mt-3">
                    <FileUpload ProjectId="@SelectedProjectId" OnFilesUploaded="OnFilesUploaded" />
                </div>
            </div>
        </div>
    </div>
}

<!-- Three-Panel Layout -->
<div class="development-workspace">
    <div class="panels-container" id="panels-container">
        <!-- Left Panel: Source XML Viewer -->
        <div class="panel panel-left" id="panel-left">
            <div class="panel-header">
                <span class="fw-bold">Source XML</span>
                <span class="text-muted small">@(SelectedFileName ?? "No file selected")</span>
            </div>
            <div class="panel-content">
                <LoadingSkeleton IsLoading="@IsLoadingXml" Type="SkeletonType.CodeEditor" Lines="25">
                    @if (!string.IsNullOrEmpty(XmlContent))
                    {
                        <pre id="source-xml" class="code-viewer">@XmlContent</pre>
                    }
                    else
                    {
                        <div class="text-center p-5 text-muted">
                            <i class="bi bi-file-earmark-code" style="font-size: 3rem;"></i>
                            <p class="mt-3">Select a project and file to view the source XML</p>
                        </div>
                    }
                </LoadingSkeleton>
            </div>
        </div>

        <!-- Resize Handle 1 -->
        <div class="resize-handle" id="resize-handle-1"></div>

        <!-- Center Panel: XSLT Editor -->
        <div class="panel panel-center" id="panel-center">
            <div class="panel-header">
                <span class="fw-bold">XSLT Transformation</span>
                <span class="text-muted small">transformation.xslt</span>
            </div>
            <div class="panel-content">
                <LoadingSkeleton IsLoading="@IsLoadingXslt" Type="SkeletonType.CodeEditor" Lines="30">
                    <div id="monaco-editor-container" style="width: 100%; height: 100%;"></div>
                </LoadingSkeleton>
            </div>
        </div>

        <!-- Resize Handle 2 -->
        <div class="resize-handle" id="resize-handle-2"></div>

        <!-- Right Panel: Preview -->
        <div class="panel panel-right" id="panel-right">
            <div class="panel-header">
                <span class="fw-bold">Output Preview</span>
                <div class="preview-controls">
                    @if (!string.IsNullOrEmpty(OutputContent))
                    {
                        <div class="form-check form-switch">
                            <input class="form-check-input" type="checkbox" id="renderedToggle" @bind-value="ShowRendered" @bind-value:after="OnRenderedToggled">
                            <label class="form-check-label" for="renderedToggle">HTML mode</label>
                        </div>
                        @if (!ShowRendered)
                        {
                            <div class="form-check form-switch">
                                <input class="form-check-input" type="checkbox" id="formatToggle"
                                       checked="@ShowFormattedXml"
                                       @bind-value="ShowFormattedXml"
                                       @bind-value:after="OnFormatChanged">
                                <label class="form-check-label" for="formatToggle">Format</label>
                            </div>
                        }
                    }
                    @if (!string.IsNullOrEmpty(OutputContent))
                    {
                        <div class="preview-actions">
                            @if (ShowRendered)
                            {
                                <button class="btn btn-sm btn-outline-secondary" @onclick="ZoomOut" title="Zoom Out" disabled="@(ZoomLevel <= 50)">
                                    <i class="bi bi-zoom-out"></i>
                                </button>
                                <span class="zoom-indicator">@ZoomLevel%</span>
                                <button class="btn btn-sm btn-outline-secondary" @onclick="ZoomIn" title="Zoom In" disabled="@(ZoomLevel >= 200)">
                                    <i class="bi bi-zoom-in"></i>
                                </button>
                                <button class="btn btn-sm btn-outline-secondary" @onclick="ResetZoom" title="Reset Zoom">
                                    <i class="bi bi-arrow-counterclockwise"></i>
                                </button>
                            }
                            else
                            {
                                <button class="btn btn-sm btn-outline-secondary" @onclick="CopyToClipboard" title="Copy to Clipboard">
                                    <i class="bi bi-clipboard"></i> Copy
                                </button>
                            }
                            <button class="btn btn-sm btn-primary" @onclick="DownloadOutput" title="Download Output">
                                <i class="bi bi-download"></i> Download
                            </button>
                        </div>
                    }
                </div>
            </div>
            <div class="panel-content">
                @if (IsTransforming)
                {
                    <div class="transformation-overlay">
                        <div class="transformation-indicator">
                            <div class="spinner-border text-success" role="status">
                                <span class="visually-hidden">Transforming...</span>
                            </div>
                            <p class="mt-3 fw-bold">Transforming XML...</p>
                            <p class="text-muted small">Please wait while the transformation is in progress</p>
                        </div>
                    </div>
                }
                @if (!string.IsNullOrEmpty(OutputContent))
                {
                    @if (ShowRendered)
                    {
                        <div class="preview-rendered" style="font-size: @(ZoomLevel)%;">
                            @((MarkupString)OutputContent)
                        </div>
                    }
                    else
                    {
                        <pre id="output-source" class="code-viewer" @key="@_outputContentKey">@OutputContent</pre>
                    }
                    @if (TransformationStats != null)
                    {
                        <div class="preview-stats">
                            <div class="stats-content">
                                <span class="badge bg-success">
                                    <i class="bi bi-clock"></i> @TransformationStats.ProcessingTimeMs ms
                                </span>
                                @if (TransformationStats.HeadersNormalized > 0)
                                {
                                    <span class="badge bg-info">
                                        <i class="bi bi-type-h1"></i> @TransformationStats.HeadersNormalized headers normalized
                                    </span>
                                }
                                @if (TransformationStats.TablesProcessed > 0)
                                {
                                    <span class="badge bg-primary">
                                        <i class="bi bi-table"></i> @TransformationStats.TablesProcessed tables processed
                                    </span>
                                }
                                @if (TransformationStats.WarningMessages.Any())
                                {
                                    <span class="badge bg-warning text-dark">
                                        <i class="bi bi-exclamation-triangle"></i> @TransformationStats.WarningMessages.Count warnings
                                    </span>
                                }
                            </div>
                        </div>
                    }
                }
                else if (!IsTransforming)
                {
                    <div class="text-center p-5 text-muted">
                        <i class="bi bi-eye" style="font-size: 3rem;"></i>
                        <p class="mt-3">@(CanTransform ? "Click \"Transform\" to preview the output" : "Select a project and file to begin")</p>
                        @if (AutoTransform && CanTransform)
                        {
                            <p class="small">Auto-transform is enabled. Edit the XSLT to see live preview.</p>
                        }
                    </div>
                }
            </div>
        </div>
    </div>
</div>

@code {
    // LocalStorage models
    private class SavedSelection
    {
        public string? ProjectId { get; set; }
        public string? FileName { get; set; }
    }

    private class SavedSettings
    {
        public bool UseXslt3Service { get; set; }
        public bool NormalizeHeaders { get; set; }
        public bool AutoTransform { get; set; }
        public bool HasStoredSettings { get; set; }
    }

    // State
    private List<Project>? Projects;
    private List<string>? ProjectFiles;
    private string? SelectedProjectId;
    private string? SelectedFileName;
    private string? XmlContent;
    private string? XsltContent;
    private string? OutputContent;
    private TransformationResult? TransformationStats;

    // UI State
    private bool IsLoading = false;
    private bool IsLoadingXml = false;
    private bool IsLoadingXslt = false;
    private bool IsTransforming = false;
    private bool IsSaving = false;
    private bool ShowSettings = false;
    private bool ShowRendered = false; // Default to source view
    private bool ShowFormattedXml = true;
    private bool isRestoringFromStorage = false;

    // Settings (defaults will be overridden by localStorage if available)
    private bool UseXslt3Service = true;
    private bool NormalizeHeaders = true;
    private bool AutoTransform = false;

    // Preview Controls
    private int ZoomLevel = 100;
    private int _outputContentKey = 0;

    // Computed Properties
    private bool CanTransform => !string.IsNullOrEmpty(SelectedProjectId)
                                && !string.IsNullOrEmpty(SelectedFileName)
                                && !string.IsNullOrEmpty(XmlContent)
                                && !string.IsNullOrEmpty(XsltContent);

    private bool CanSave => !string.IsNullOrEmpty(XsltContent);

    private async Task OnRenderedToggled()
    {
        // ShowRendered is already updated by @bind-value
        Logger.LogInformation("Rendered toggle changed: ShowRendered = {ShowRendered}", ShowRendered);

        // If Source view is now active (Rendered OFF) and Format is checked, apply syntax highlighting
        if (!ShowRendered && ShowFormattedXml)
        {
            // Give Blazor a moment to render the <pre> element
            await Task.Delay(50);

            try
            {
                await JSRuntime.InvokeVoidAsync("xmlFormatter.highlightElement", "output-source");
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Error applying syntax highlighting when toggling to source view");
                ToastNotification.ShowError("Failed to apply syntax highlighting. Please try again.");
            }
        }

        StateHasChanged();
    }

    private async Task OnFormatChanged()
    {
        // ShowFormattedXml is already updated by @bind-value
        Logger.LogInformation("Format checkbox changed: ShowFormattedXml = {ShowFormatted}", ShowFormattedXml);

        try
        {
            // Save scroll position before changing format
            var scrollPosition = await JSRuntime.InvokeAsync<Dictionary<string, int>>("xmlFormatter.saveScrollPosition", "output-source");

            if (ShowFormattedXml)
            {
                // Apply syntax highlighting
                await JSRuntime.InvokeVoidAsync("xmlFormatter.highlightElement", "output-source");
            }
            else
            {
                // Show raw XML
                await JSRuntime.InvokeVoidAsync("xmlFormatter.showRawElement", "output-source", OutputContent);
            }

            // Restore scroll position after format change
            await Task.Delay(50); // Give time for content to update
            await JSRuntime.InvokeVoidAsync("xmlFormatter.restoreScrollPosition", "output-source", scrollPosition);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error toggling XML format");
            ToastNotification.ShowError("Failed to toggle format. Please try again.");
        }

        StateHasChanged();
    }

    protected override async Task OnInitializedAsync()
    {
        // Wire up toolbar state
        ToolbarState.OnProjectChanged = async (projectId) => await OnProjectChanged(new ChangeEventArgs { Value = projectId });
        ToolbarState.OnFileChanged = async (fileName) => await OnFileChanged(new ChangeEventArgs { Value = fileName });
        ToolbarState.OnTransform = TransformAsync;
        ToolbarState.OnSave = SaveXsltAsync;
        ToolbarState.OnToggleSettings = ToggleSettings;
        // Note: OnToggleTransformationLog is handled in MainLayout

        await LoadProjectsAsync();
        await LoadXsltAsync();

        UpdateToolbarState();
    }

    private void UpdateToolbarState()
    {
        ToolbarState.Projects = Projects;
        ToolbarState.ProjectFiles = ProjectFiles;
        ToolbarState.SelectedProjectId = SelectedProjectId;
        ToolbarState.SelectedFileName = SelectedFileName;
        ToolbarState.IsLoading = IsLoading;
        ToolbarState.IsTransforming = IsTransforming;
        ToolbarState.IsSaving = IsSaving;
        ToolbarState.CanTransform = CanTransform;
        ToolbarState.CanSave = CanSave;
        ToolbarState.ShowSettings = ShowSettings;
        ToolbarState.NotifyStateChanged();
    }

    private async Task LoadProjectsAsync()
    {
        try
        {
            IsLoading = true;
            UpdateToolbarState();
            Projects = (await ProjectService.GetProjectsAsync()).ToList();
            Logger.LogInformation("Loaded {Count} projects", Projects.Count);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading projects");
            ToastNotification.ShowError($"Failed to load projects: {ex.Message}");
        }
        finally
        {
            IsLoading = false;
            UpdateToolbarState();
        }
    }

    private async Task LoadXsltAsync()
    {
        try
        {
            IsLoadingXslt = true;

            var xsltPath = "/app/xslt/transformation.xslt";
            if (File.Exists(xsltPath))
            {
                XsltContent = await File.ReadAllTextAsync(xsltPath);
                Logger.LogInformation("Loaded XSLT template from {Path}", xsltPath);

                // Update Monaco editor content if already initialized
                if (monacoInitialized)
                {
                    await JSRuntime.InvokeVoidAsync("MonacoEditorInterop.setValue", XsltContent);
                }
            }
            else
            {
                Logger.LogWarning("XSLT template not found at {Path}", xsltPath);
                ToastNotification.ShowWarning("XSLT template not found");
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading XSLT");
            ToastNotification.ShowError($"Failed to load XSLT: {ex.Message}");
        }
        finally
        {
            IsLoadingXslt = false;
        }
    }

    private async Task OnProjectChanged(ChangeEventArgs e)
    {
        try
        {
            SelectedProjectId = e.Value?.ToString();
            SelectedFileName = null;
            XmlContent = null;
            OutputContent = null;
            ProjectFiles = null;

            if (!string.IsNullOrEmpty(SelectedProjectId))
            {
                IsLoading = true;
                UpdateToolbarState();
                StateHasChanged();
                ProjectFiles = (await ProjectService.GetProjectFilesAsync(SelectedProjectId)).ToList();
                Logger.LogInformation("Loaded {Count} files for project {ProjectId}", ProjectFiles.Count, SelectedProjectId);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading project files");
            ToastNotification.ShowError($"Failed to load project files: {ex.Message}");
        }
        finally
        {
            IsLoading = false;
            UpdateToolbarState();
            StateHasChanged();

            // Save selection to localStorage (unless we're restoring)
            if (!isRestoringFromStorage)
            {
                await JSRuntime.InvokeVoidAsync("developmentStorage.saveSelection", SelectedProjectId, SelectedFileName);
            }
        }
    }

    private async Task OnFileChanged(ChangeEventArgs e)
    {
        try
        {
            SelectedFileName = e.Value?.ToString();
            XmlContent = null;
            OutputContent = null;
            UpdateToolbarState();
            StateHasChanged();

            if (!string.IsNullOrEmpty(SelectedProjectId) && !string.IsNullOrEmpty(SelectedFileName))
            {
                IsLoadingXml = true;
                StateHasChanged();
                XmlContent = await ProjectService.ReadInputFileAsync(SelectedProjectId, SelectedFileName);
                Logger.LogInformation("Loaded file {FileName} from project {ProjectId}", SelectedFileName, SelectedProjectId);

                // Auto-transform if enabled
                if (AutoTransform && CanTransform)
                {
                    await TransformAsync();
                }
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading XML file");
            ToastNotification.ShowError($"Failed to load XML file: {ex.Message}");
        }
        finally
        {
            IsLoadingXml = false;
            UpdateToolbarState();
            StateHasChanged();

            // Apply syntax highlighting to source XML
            if (!string.IsNullOrEmpty(XmlContent))
            {
                _ = InvokeAsync(async () =>
                {
                    await Task.Delay(100); // Give Blazor time to render
                    try
                    {
                        await JSRuntime.InvokeVoidAsync("xmlFormatter.highlightElement", "source-xml");
                        Logger.LogInformation("Applied syntax highlighting to source XML");
                    }
                    catch (Exception ex)
                    {
                        Logger.LogError(ex, "Error applying syntax highlighting to source XML");
                    }
                });
            }

            // Save selection to localStorage (unless we're restoring)
            if (!isRestoringFromStorage)
            {
                await JSRuntime.InvokeVoidAsync("developmentStorage.saveSelection", SelectedProjectId, SelectedFileName);
            }
        }
    }

    private async Task OnXsltChanged()
    {
        // Auto-transform if enabled
        if (AutoTransform && CanTransform && !IsTransforming)
        {
            await TransformAsync();
        }
    }

    private async Task TransformAsync()
    {
        if (!CanTransform) return;

        try
        {
            IsTransforming = true;
            UpdateToolbarState();

            var options = new TransformationOptions
            {
                UseXslt3Service = UseXslt3Service,
                NormalizeHeaders = NormalizeHeaders
            };

            var result = await XsltService.TransformAsync(XmlContent!, XsltContent!, options);

            if (result.IsSuccess)
            {
                // Save scroll position before updating content (only if output already exists)
                Dictionary<string, int>? scrollPosition = null;
                if (!string.IsNullOrEmpty(OutputContent) && !ShowRendered)
                {
                    try
                    {
                        scrollPosition = await JSRuntime.InvokeAsync<Dictionary<string, int>>("xmlFormatter.saveScrollPosition", "output-source");
                        Logger.LogInformation("Saved scroll position before transformation update");
                    }
                    catch (Exception ex)
                    {
                        Logger.LogWarning(ex, "Could not save scroll position");
                    }
                }

                OutputContent = result.OutputContent;
                TransformationStats = result;
                _outputContentKey++; // Force Blazor to recreate element (required when mixing Blazor text with JS innerHTML)
                Logger.LogInformation("Transformation successful in {Time}ms. OutputContent length: {Length}", result.ProcessingTimeMs, OutputContent?.Length ?? 0);

                // Trigger visual success feedback (green glow on Transform button)
                await TriggerTransformSuccessEffect();

                if (result.WarningMessages.Any())
                {
                    foreach (var warning in result.WarningMessages)
                    {
                        ToastNotification.ShowWarning(warning);
                    }
                }

                // If we're in Source view (Rendered OFF) with formatting enabled, re-apply syntax highlighting after render
                if (!ShowRendered && ShowFormattedXml)
                {
                    // Schedule syntax highlighting after Blazor renders the new content
                    var savedScrollPos = scrollPosition; // Capture for closure
                    _ = InvokeAsync(async () =>
                    {
                        await Task.Delay(100); // Give Blazor time to render
                        try
                        {
                            await JSRuntime.InvokeVoidAsync("xmlFormatter.highlightElement", "output-source");
                            Logger.LogInformation("XML syntax highlighting applied after transformation");

                            // Restore scroll position after highlighting
                            if (savedScrollPos != null)
                            {
                                await Task.Delay(50); // Give time for highlighting to complete
                                await JSRuntime.InvokeVoidAsync("xmlFormatter.restoreScrollPosition", "output-source", savedScrollPos);
                                Logger.LogInformation("Restored scroll position after transformation");
                            }
                        }
                        catch (Exception ex)
                        {
                            Logger.LogError(ex, "Error applying syntax highlighting after transformation");
                        }
                    });
                }
            }
            else
            {
                Logger.LogError("Transformation failed: {Error}", result.ErrorMessage);
                ToastNotification.ShowError($"Transformation failed: {result.ErrorMessage}");
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error during transformation");
            ToastNotification.ShowError($"Transformation error: {ex.Message}");
        }
        finally
        {
            IsTransforming = false;
            UpdateToolbarState();
            StateHasChanged();
        }
    }

    private async Task SaveXsltAsync()
    {
        if (!CanSave) return;

        try
        {
            IsSaving = true;
            UpdateToolbarState();

            var xsltPath = "/app/xslt/transformation.xslt";
            await File.WriteAllTextAsync(xsltPath, XsltContent!);

            ToastNotification.ShowSuccess("XSLT template saved successfully");
            Logger.LogInformation("XSLT template saved to {Path}", xsltPath);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error saving XSLT");
            ToastNotification.ShowError($"Failed to save XSLT: {ex.Message}");
        }
        finally
        {
            IsSaving = false;
            UpdateToolbarState();
            StateHasChanged();
        }
    }

    private void ToggleSettings()
    {
        ShowSettings = !ShowSettings;
        UpdateToolbarState();
        StateHasChanged();
    }

    private void OnSettingsChanged()
    {
        // Save settings to localStorage asynchronously (fire-and-forget)
        _ = SaveSettingsAsync();
    }

    private async Task SaveSettingsAsync()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("developmentStorage.saveSettings", UseXslt3Service, NormalizeHeaders, AutoTransform);
            Logger.LogInformation("Settings saved: UseXslt3Service={UseXslt3}, NormalizeHeaders={Normalize}, AutoTransform={Auto}",
                UseXslt3Service, NormalizeHeaders, AutoTransform);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to save settings to localStorage");
        }
    }

    private async Task OnFilesUploaded()
    {
        // Refresh file list
        if (!string.IsNullOrEmpty(SelectedProjectId))
        {
            try
            {
                ProjectFiles = (await ProjectService.GetProjectFilesAsync(SelectedProjectId)).ToList();
                UpdateToolbarState();
                StateHasChanged();
                Logger.LogInformation("File list refreshed after upload");
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Error refreshing file list after upload");
                ToastNotification.ShowError($"Failed to refresh file list: {ex.Message}");
            }
        }
    }

    // Zoom controls
    private void ZoomIn()
    {
        if (ZoomLevel < 200)
        {
            ZoomLevel += 10;
            StateHasChanged();
        }
    }

    private void ZoomOut()
    {
        if (ZoomLevel > 50)
        {
            ZoomLevel -= 10;
            StateHasChanged();
        }
    }

    private void ResetZoom()
    {
        ZoomLevel = 100;
        StateHasChanged();
    }

    // Copy to clipboard
    private async Task CopyToClipboard()
    {
        try
        {
            if (!string.IsNullOrEmpty(OutputContent))
            {
                await JSRuntime.InvokeVoidAsync("navigator.clipboard.writeText", OutputContent);
                ToastNotification.ShowSuccess("Output copied to clipboard");
                Logger.LogInformation("Output copied to clipboard");
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error copying to clipboard");
            ToastNotification.ShowError($"Failed to copy to clipboard: {ex.Message}");
        }
    }

    // Download output
    private async Task DownloadOutput()
    {
        try
        {
            if (!string.IsNullOrEmpty(OutputContent))
            {
                var fileName = $"{SelectedProjectId ?? "output"}_{DateTime.Now:yyyyMMdd_HHmmss}.xhtml";
                var bytes = System.Text.Encoding.UTF8.GetBytes(OutputContent);
                var base64 = Convert.ToBase64String(bytes);

                await JSRuntime.InvokeVoidAsync("downloadFile", fileName, "application/xhtml+xml", base64);
                ToastNotification.ShowSuccess($"Downloaded {fileName}");
                Logger.LogInformation("Downloaded output as {FileName}", fileName);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error downloading output");
            ToastNotification.ShowError($"Failed to download output: {ex.Message}");
        }
    }

    // Monaco Editor Integration
    private DotNetObjectReference<Development>? dotNetRef;
    private bool monacoInitialized = false;
    private bool keyboardShortcutsInitialized = false;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // Wait a bit to ensure JavaScript files are fully loaded
            await Task.Delay(200);

            // Load saved settings from localStorage
            try
            {
                var savedSettings = await JSRuntime.InvokeAsync<SavedSettings>("developmentStorage.loadSettings");
                if (savedSettings != null && savedSettings.HasStoredSettings)
                {
                    UseXslt3Service = savedSettings.UseXslt3Service;
                    NormalizeHeaders = savedSettings.NormalizeHeaders;
                    AutoTransform = savedSettings.AutoTransform;

                    Logger.LogInformation("Restored settings from localStorage: UseXslt3Service={UseXslt3}, NormalizeHeaders={Normalize}, AutoTransform={Auto}",
                        UseXslt3Service, NormalizeHeaders, AutoTransform);

                    StateHasChanged();
                }
                else
                {
                    Logger.LogInformation("No stored settings found, using defaults: UseXslt3Service={UseXslt3}, NormalizeHeaders={Normalize}, AutoTransform={Auto}",
                        UseXslt3Service, NormalizeHeaders, AutoTransform);
                }
            }
            catch (Exception ex)
            {
                Logger.LogWarning(ex, "Could not restore settings from localStorage, using defaults");
            }

            // Initialize keyboard shortcuts
            if (!keyboardShortcutsInitialized)
            {
                try
                {
                    dotNetRef = DotNetObjectReference.Create(this);
                    await JSRuntime.InvokeVoidAsync("KeyboardShortcuts.initialize", dotNetRef);
                    keyboardShortcutsInitialized = true;
                    Logger.LogInformation("Keyboard shortcuts initialized");
                }
                catch (Exception ex)
                {
                    Logger.LogError(ex, "Failed to initialize keyboard shortcuts");
                }
            }

            // Initialize Monaco Editor
            if (!string.IsNullOrEmpty(XsltContent) && !monacoInitialized)
            {
                try
                {
                    var theme = ThemeService.GetMonacoTheme();
                    await JSRuntime.InvokeVoidAsync("MonacoEditorInterop.initialize",
                        "monaco-editor-container",
                        XsltContent,
                        dotNetRef,
                        theme);
                    monacoInitialized = true;
                    Logger.LogInformation("Monaco Editor initialized successfully");
                }
                catch (Exception ex)
                {
                    Logger.LogError(ex, "Failed to initialize Monaco Editor");
                    ToastNotification.ShowError("Failed to initialize code editor. Using fallback mode.");
                }
            }

            // Load saved selections from localStorage and restore them

            try
            {
                var savedSelection = await JSRuntime.InvokeAsync<SavedSelection>("developmentStorage.loadSelection");
                if (savedSelection != null && !string.IsNullOrEmpty(savedSelection.ProjectId))
                {
                    Logger.LogInformation("Restoring saved selection: Project={Project}, File={File}",
                        savedSelection.ProjectId, savedSelection.FileName);

                    // Set flag to prevent saving during restoration
                    isRestoringFromStorage = true;

                    try
                    {
                        // Restore project selection
                        await OnProjectChanged(new ChangeEventArgs { Value = savedSelection.ProjectId });

                        // Restore file selection if available
                        if (!string.IsNullOrEmpty(savedSelection.FileName))
                        {
                            // Wait for project files to load
                            await Task.Delay(800);
                            await OnFileChanged(new ChangeEventArgs { Value = savedSelection.FileName });
                        }
                    }
                    finally
                    {
                        // Clear the flag after restoration is complete
                        isRestoringFromStorage = false;
                    }
                }
                else
                {
                    Logger.LogInformation("No saved selection found in localStorage");
                }
            }
            catch (Exception ex)
            {
                Logger.LogWarning(ex, "Could not restore saved selection from localStorage");
                isRestoringFromStorage = false;
            }
        }
    }

    [JSInvokable]
    public async Task OnEditorContentChanged(string content)
    {
        XsltContent = content;
        await OnXsltChanged();
    }

    [JSInvokable]
    public async Task OnSaveShortcut()
    {
        await SaveXsltAsync();
    }

    [JSInvokable]
    public async Task OnTransformShortcut()
    {
        await TransformAsync();
    }

    [JSInvokable]
    public void OnShowHelp()
    {
        // This would trigger help panel in MainLayout
        // For now, just show a toast
        ToastNotification.ShowInfo("Press ? to show help panel");
    }

    private async Task TriggerTransformSuccessEffect()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("VisualFeedback.triggerTransformSuccess");
        }
        catch (Exception ex)
        {
            Logger.LogWarning(ex, "Failed to trigger transform success effect");
        }
    }

    public async ValueTask DisposeAsync()
    {
        if (monacoInitialized)
        {
            try
            {
                await JSRuntime.InvokeVoidAsync("MonacoEditorInterop.dispose");
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Error disposing Monaco Editor");
            }
        }

        dotNetRef?.Dispose();
    }
}
