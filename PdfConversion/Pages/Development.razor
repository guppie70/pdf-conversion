@page "/development"
@using PdfConversion.Services
@using PdfConversion.Models
@using PdfConversion.Shared
@using Microsoft.JSInterop
@using static PdfConversion.Shared.LoadingSkeleton
@implements IAsyncDisposable
@inject IProjectManagementService ProjectService
@inject IXsltTransformationService XsltService
@inject IFileService FileService
@inject IJSRuntime JSRuntime
@inject ILogger<Development> Logger
@inject DevelopmentToolbarState ToolbarState
@inject ThemeService ThemeService
@inject IXsltFileWatcherService XsltFileWatcher
@inject IXmlFileWatcherService XmlFileWatcher

<PageTitle>Development Mode</PageTitle>

<!-- Settings Panel (floating overlay when settings button clicked) -->
@if (ShowSettings)
{
    <div class="settings-overlay">
        <div class="settings-panel">
            <div class="settings-header">
                <h6 class="mb-0">Transformation Settings</h6>
                <button type="button" class="btn-close" @onclick="ToggleSettings" aria-label="Close"></button>
            </div>
            <div class="settings-body">
                <div class="form-check mb-2">
                    <input class="form-check-input" type="checkbox" id="useXslt3" @bind="UseXslt3Service" @bind:after="OnSettingsChanged">
                    <label class="form-check-label" for="useXslt3">
                        Use XSLT3 Service (XSLT 2.0/3.0)
                    </label>
                </div>
                <div class="form-check mb-2">
                    <input class="form-check-input" type="checkbox" id="normalizeHeaders" @bind="NormalizeHeaders" @bind:after="OnSettingsChanged">
                    <label class="form-check-label" for="normalizeHeaders">
                        Normalize Headers
                    </label>
                </div>
                <div class="form-check mb-2">
                    <input class="form-check-input" type="checkbox" id="autoTransform" @bind="AutoTransform" @bind:after="OnSettingsChanged">
                    <label class="form-check-label" for="autoTransform">
                        Auto-transform on XSLT change
                    </label>
                </div>

                <hr class="my-3" />

                <div class="mt-3">
                    <FileUpload ProjectId="@SelectedProjectId" OnFilesUploaded="OnFilesUploaded" />
                </div>
            </div>
        </div>
    </div>
}

<!-- Three-Panel Layout -->
<div class="development-workspace">
    <div class="panels-container" id="panels-container">
        <!-- Left Panel: Source XML Viewer -->
        <div class="panel panel-left" id="panel-left">
            <div class="panel-header">
                <div class="panel-header-left">
                    @if (Projects != null && Projects.Any())
                    {
                        <select class="form-select form-select-sm xslt-file-select" @onchange="OnFilePathChangedFromDropdown">
                            <option value="">Select a file...</option>
                            @foreach (var project in Projects)
                            {
                                <optgroup label="@project.Name">
                                    @if (project.Files != null && project.Files.Any())
                                    {
                                        @foreach (var file in project.Files)
                                        {
                                            var fullPath = $"{project.Organization}/{project.ProjectId}/{file}";
                                            var isSelected = !string.IsNullOrEmpty(SelectedProjectId) &&
                                                           !string.IsNullOrEmpty(SelectedFileName) &&
                                                           SelectedProjectId == $"{project.Organization}/{project.ProjectId}" &&
                                                           SelectedFileName == file;
                                            <option value="@fullPath" selected="@isSelected">
                                                @file
                                            </option>
                                        }
                                    }
                                </optgroup>
                            }
                        </select>
                    }
                    else
                    {
                        <span class="text-muted small">@(SelectedFileName ?? "No file selected")</span>
                    }
                </div>
                <div class="panel-header-right">
                    <button class="btn btn-sm panel-help-btn"
                            title="Source XML: Select and view your Adobe Acrobat XML input file"
                            data-bs-toggle="tooltip"
                            data-bs-placement="right">
                        <i class="bi bi-question-circle"></i>
                    </button>
                </div>
            </div>
            <div class="panel-content">
                <!-- Keep Monaco viewer in DOM at all times to prevent detachment -->
                <!-- Use CSS display to show/hide based on state -->
                <div id="source-xml-viewer" style="width: 100%; height: 100%; display: @(IsLoadingXml || string.IsNullOrEmpty(XmlContent) ? "none" : "block");"></div>

                @if (IsLoadingXml)
                {
                    <LoadingSkeleton IsLoading="true" Type="SkeletonType.CodeEditor" Lines="25">
                    </LoadingSkeleton>
                }
                else if (string.IsNullOrEmpty(XmlContent))
                {
                    <div class="text-center p-5 text-muted">
                        <i class="bi bi-file-earmark-code" style="font-size: 3rem;"></i>
                        <p class="mt-3">Select a project and file to view the source XML</p>
                    </div>
                }
            </div>
        </div>

        <!-- Resize Handle 1 -->
        <div class="resize-handle" id="resize-handle-1"></div>

        <!-- Center Panel: XSLT Editor -->
        <div class="panel panel-center" id="panel-center">
            <div class="panel-header">
                <div class="panel-header-left">
                    @if (XsltFiles != null && XsltFiles.Any())
                    {
                        <select class="form-select form-select-sm xslt-file-select" @onchange="OnXsltFileChanged" value="@SelectedXsltFile">
                            @foreach (var file in XsltFiles)
                            {
                                <option value="@file">@file</option>
                            }
                        </select>
                    }
                    else
                    {
                        <span class="text-muted small">@(SelectedXsltFile ?? "transformation.xslt")</span>
                    }
                </div>
                <div class="panel-header-right">
                    <div class="panel-action-buttons">
                        <button class="btn btn-sm panel-action-btn" @onclick="TransformAsync" disabled="@(!CanTransform || IsTransforming)" title="Transform (Ctrl+Enter)" data-bs-toggle="tooltip">
                            @if (IsTransforming)
                            {
                                <span class="spinner-border spinner-border-sm"></span>
                            }
                            else
                            {
                                <i class="bi bi-play-fill"></i>
                            }
                        </button>
                        <button class="btn btn-sm panel-action-btn" @onclick="SaveXsltAsync" disabled="@(!CanSave || IsSaving)" title="Save XSLT (Ctrl+S)" data-bs-toggle="tooltip">
                            @if (IsSaving)
                            {
                                <span class="spinner-border spinner-border-sm"></span>
                            }
                            else
                            {
                                <i class="bi bi-floppy-fill"></i>
                            }
                        </button>
                        <button class="btn btn-sm panel-help-btn"
                                title="XSLT Transformation: Edit XSLT templates to transform Adobe XML to Taxxor XHTML"
                                data-bs-toggle="tooltip"
                                data-bs-placement="bottom">
                            <i class="bi bi-question-circle"></i>
                        </button>
                    </div>
                </div>
            </div>
            <div class="panel-content">
                <LoadingSkeleton IsLoading="@IsLoadingXslt" Type="SkeletonType.CodeEditor" Lines="30">
                    <div id="monaco-editor-container" style="width: 100%; height: 100%;"></div>
                </LoadingSkeleton>
            </div>
        </div>

        <!-- Resize Handle 2 -->
        <div class="resize-handle" id="resize-handle-2"></div>

        <!-- Right Panel: Preview -->
        <div class="panel panel-right" id="panel-right">
            <div class="panel-header">
                <button class="btn btn-link panel-help-btn"
                        title="Output Preview: View the transformed XHTML output in HTML or source mode"
                        data-bs-toggle="tooltip"
                        data-bs-placement="left">
                    <i class="bi bi-question-circle"></i>
                </button>
                <div class="preview-controls">
                    @if (!string.IsNullOrEmpty(OutputContent))
                    {
                        <div class="form-check form-switch">
                            <input class="form-check-input" type="checkbox" id="renderedToggle" @bind-value="ShowRendered" @bind-value:after="OnRenderedToggled">
                            <label class="form-check-label" for="renderedToggle">HTML mode</label>
                        </div>
                        @if (!ShowRendered)
                        {
                            <div class="form-check form-switch">
                                <input class="form-check-input" type="checkbox" id="formatToggle"
                                       checked="@ShowFormattedXml"
                                       @bind-value="ShowFormattedXml"
                                       @bind-value:after="OnFormatChanged">
                                <label class="form-check-label" for="formatToggle">Format</label>
                            </div>
                        }
                    }
                    @if (!string.IsNullOrEmpty(OutputContent))
                    {
                        <div class="preview-actions">
                            @if (ShowRendered)
                            {
                                <button class="btn btn-sm btn-outline-secondary" @onclick="ZoomOut" title="Zoom Out" disabled="@(ZoomLevel <= 50)">
                                    <i class="bi bi-zoom-out"></i>
                                </button>
                                <span class="zoom-indicator">@ZoomLevel%</span>
                                <button class="btn btn-sm btn-outline-secondary" @onclick="ZoomIn" title="Zoom In" disabled="@(ZoomLevel >= 200)">
                                    <i class="bi bi-zoom-in"></i>
                                </button>
                                <button class="btn btn-sm btn-outline-secondary" @onclick="ResetZoom" title="Reset Zoom">
                                    <i class="bi bi-arrow-counterclockwise"></i>
                                </button>
                            }
                            else
                            {
                                <button class="btn btn-sm btn-outline-secondary" @onclick="CopyToClipboard" title="Copy to Clipboard">
                                    <i class="bi bi-clipboard"></i> Copy
                                </button>
                            }
                            <button class="btn btn-sm btn-primary" @onclick="DownloadOutput" title="Download Output">
                                <i class="bi bi-download"></i> Download
                            </button>
                        </div>
                    }
                </div>
            </div>
            <div class="panel-content">
                @if (IsTransforming)
                {
                    <div class="transformation-overlay">
                        <div class="transformation-indicator">
                            <div class="spinner-border text-success" role="status">
                                <span class="visually-hidden">Transforming...</span>
                            </div>
                            <p class="mt-3 fw-bold">Transforming XML...</p>
                            <p class="text-muted small">Please wait while the transformation is in progress</p>
                        </div>
                    </div>
                }
                @if (!string.IsNullOrEmpty(TransformationError))
                {
                    <div class="p-4">
                        <div class="alert alert-danger mb-0" role="alert">
                            <h5 class="alert-heading">
                                <i class="bi bi-exclamation-triangle-fill"></i> Transformation Error
                            </h5>
                            <hr />
                            <pre class="mb-0" style="white-space: pre-wrap; font-family: 'Monaco', 'Menlo', 'Consolas', monospace; font-size: 0.875rem;">@TransformationError</pre>
                        </div>
                    </div>
                }
                else if (!string.IsNullOrEmpty(OutputContent))
                {
                    <!-- Keep both views in DOM, use CSS to show/hide -->
                    <!-- This prevents Monaco editor from losing its DOM element -->
                    <div class="preview-rendered" style="font-size: @(ZoomLevel)%; display: @(ShowRendered ? "block" : "none");">
                        @((MarkupString)OutputContent)
                    </div>
                    <div id="output-xml-viewer" style="width: 100%; height: 100%; display: @(ShowRendered ? "none" : "block");"></div>
                    @if (TransformationStats != null)
                    {
                        <div class="preview-stats">
                            <div class="stats-content">
                                <span class="badge bg-success">
                                    <i class="bi bi-clock"></i> @TransformationStats.ProcessingTimeMs ms
                                </span>
                                @if (TransformationStats.HeadersNormalized > 0)
                                {
                                    <span class="badge bg-info">
                                        <i class="bi bi-type-h1"></i> @TransformationStats.HeadersNormalized headers normalized
                                    </span>
                                }
                                @if (TransformationStats.TablesProcessed > 0)
                                {
                                    <span class="badge bg-primary">
                                        <i class="bi bi-table"></i> @TransformationStats.TablesProcessed tables processed
                                    </span>
                                }
                                @if (TransformationStats.WarningMessages.Any())
                                {
                                    <span class="badge bg-warning text-dark">
                                        <i class="bi bi-exclamation-triangle"></i> @TransformationStats.WarningMessages.Count warnings
                                    </span>
                                }
                            </div>
                        </div>
                    }
                }
                else if (!IsTransforming)
                {
                    <div class="text-center p-5 text-muted">
                        <i class="bi bi-eye" style="font-size: 3rem;"></i>
                        <p class="mt-3">@(CanTransform ? "Click \"Transform\" to preview the output" : "Select a project and file to begin")</p>
                        @if (AutoTransform && CanTransform)
                        {
                            <p class="small">Auto-transform is enabled. Edit the XSLT to see live preview.</p>
                        }
                    </div>
                }
            </div>
        </div>
    </div>
</div>

@code {
    // LocalStorage models
    private class SavedSelection
    {
        public string? ProjectId { get; set; }
        public string? FileName { get; set; }
        public string? XsltFile { get; set; }
    }

    private class SavedSettings
    {
        public bool UseXslt3Service { get; set; }
        public bool NormalizeHeaders { get; set; }
        public bool AutoTransform { get; set; }
        public bool HasStoredSettings { get; set; }
    }

    // State
    private List<Project>? Projects;
    private List<string>? ProjectFiles;
    private string? SelectedProjectId;
    private string? SelectedFileName;
    private string? XmlContent;
    private string? XsltContent;
    private List<string>? XsltFiles;
    private string? SelectedXsltFile = "transformation.xslt";
    private string? OutputContent;
    private TransformationResult? TransformationStats;
    private string? TransformationError;

    // UI State
    private bool IsLoading = false;
    private bool IsLoadingXml = false;
    private bool IsLoadingXslt = false;
    private bool IsTransforming = false;
    private bool IsSaving = false;
    private bool ShowSettings = false;
    private bool ShowRendered = false; // Default to source view
    private bool ShowFormattedXml = true;
    private bool isRestoringFromStorage = false;
    private bool isUpdatingFromExternalFile = false; // Prevents Monaco from triggering auto-transform during external updates

    // Settings (defaults will be overridden by localStorage if available)
    private bool UseXslt3Service = true;
    private bool NormalizeHeaders = true;
    private bool AutoTransform = false;

    // Preview Controls
    private int ZoomLevel = 100;

    // Computed Properties
    private bool CanTransform => !string.IsNullOrEmpty(SelectedProjectId)
                                && !string.IsNullOrEmpty(SelectedFileName)
                                && !string.IsNullOrEmpty(XmlContent)
                                && !string.IsNullOrEmpty(XsltContent);

    private bool CanSave => !string.IsNullOrEmpty(XsltContent);

    private async Task OnRenderedToggled()
    {
        // ShowRendered is already updated by @bind-value
        Logger.LogInformation("Rendered toggle changed: ShowRendered = {ShowRendered}", ShowRendered);

        // If Source view is now active (Rendered OFF), ensure Monaco viewer is initialized
        // Note: The viewer container stays in DOM (just hidden/shown with CSS), so we only
        // need to initialize once. No need to dispose/recreate on every toggle.
        if (!ShowRendered && !string.IsNullOrEmpty(OutputContent) && !_outputXmlViewerInitialized)
        {
            // Give Blazor time to render and make the container visible
            await Task.Delay(100);

            try
            {
                var outputTheme = ThemeService.GetMonacoTheme();
                await JSRuntime.InvokeVoidAsync("MonacoViewerInterop.createViewer",
                    "output-xml-viewer",
                    "outputXml",
                    new {
                        value = OutputContent ?? "",
                        language = "xml",
                        theme = outputTheme
                    });
                _outputXmlViewerInitialized = true;
                Logger.LogInformation("Output XML viewer initialized when toggling to source view");
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Error initializing Output XML viewer when toggling to source view");
                ToastNotification.ShowError("Failed to initialize viewer. Please try again.");
            }
        }

        StateHasChanged();
    }

    private async Task OnFormatChanged()
    {
        // ShowFormattedXml is already updated by @bind-value
        Logger.LogInformation("Format checkbox changed: ShowFormattedXml = {ShowFormatted}", ShowFormattedXml);

        // Monaco viewer handles formatting automatically
        // This method is kept for backwards compatibility but no longer needs to do anything
        StateHasChanged();
    }

    protected override async Task OnInitializedAsync()
    {
        // Wire up toolbar state
        ToolbarState.OnTransform = TransformAsync;
        ToolbarState.OnSave = SaveXsltAsync;
        ToolbarState.OnToggleSettings = ToggleSettings;
        // Note: OnToggleTransformationLog is handled in MainLayout

        // Register file watcher callbacks (replaces any existing callback to prevent double subscription)
        XsltFileWatcher.SetFileChangedCallback(OnXsltFileChangedExternally);
        XmlFileWatcher.SetFileChangedCallback(OnXmlFileChangedExternally);

        await LoadProjectsAsync();
        await LoadXsltAsync();

        UpdateToolbarState();
    }

    private void UpdateToolbarState()
    {
        ToolbarState.Projects = Projects;
        ToolbarState.IsLoading = IsLoading;
        ToolbarState.IsTransforming = IsTransforming;
        ToolbarState.IsSaving = IsSaving;
        ToolbarState.CanTransform = CanTransform;
        ToolbarState.CanSave = CanSave;
        ToolbarState.ShowSettings = ShowSettings;
        ToolbarState.NotifyStateChanged();
    }

    private async Task LoadProjectsAsync()
    {
        try
        {
            IsLoading = true;
            UpdateToolbarState();
            Projects = (await ProjectService.GetProjectsAsync()).ToList();

            // Load files for each project
            foreach (var project in Projects)
            {
                var fullProjectId = $"{project.Organization}/{project.ProjectId}";
                project.Files = (await ProjectService.GetProjectFilesAsync(fullProjectId)).ToList();
            }

            Logger.LogInformation("Loaded {Count} projects with files", Projects.Count);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading projects");
            ToastNotification.ShowError($"Failed to load projects: {ex.Message}");
        }
        finally
        {
            IsLoading = false;
            UpdateToolbarState();
        }
    }

    private async Task LoadXsltAsync()
    {
        try
        {
            IsLoadingXslt = true;

            // Load list of available XSLT files
            XsltFiles = FileService.GetXsltFiles().ToList();
            Logger.LogInformation("Loaded {Count} XSLT files", XsltFiles.Count);

            // Ensure selected file exists, default to transformation.xslt if not
            if (string.IsNullOrEmpty(SelectedXsltFile) || !XsltFiles.Contains(SelectedXsltFile))
            {
                SelectedXsltFile = XsltFiles.Contains("transformation.xslt")
                    ? "transformation.xslt"
                    : XsltFiles.FirstOrDefault();
            }

            if (!string.IsNullOrEmpty(SelectedXsltFile))
            {
                var xsltPath = $"/app/xslt/{SelectedXsltFile}";
                if (File.Exists(xsltPath))
                {
                    XsltContent = await File.ReadAllTextAsync(xsltPath);
                    Logger.LogInformation("Loaded XSLT file from {Path}", xsltPath);

                    // Update Monaco editor content if already initialized
                    if (monacoInitialized)
                    {
                        await JSRuntime.InvokeVoidAsync("MonacoEditorInterop.setValue", XsltContent);
                    }

                    // Start watching for file changes
                    try
                    {
                        XsltFileWatcher.StartWatching(xsltPath);
                        Logger.LogInformation("Started watching XSLT file for external changes");
                    }
                    catch (Exception watchEx)
                    {
                        Logger.LogError(watchEx, "Failed to start XSLT file watcher");
                        // Non-critical, continue without watcher
                    }
                }
                else
                {
                    Logger.LogWarning("XSLT file not found at {Path}", xsltPath);
                    ToastNotification.ShowWarning($"XSLT file not found: {SelectedXsltFile}");
                }
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading XSLT");
            ToastNotification.ShowError($"Failed to load XSLT: {ex.Message}");
        }
        finally
        {
            IsLoadingXslt = false;
        }
    }

    private async Task OnFilePathChangedFromDropdown(ChangeEventArgs e)
    {
        var filePath = e.Value?.ToString();
        if (!string.IsNullOrEmpty(filePath))
        {
            await OnFilePathChanged(filePath);
        }
    }

    private async Task OnFilePathChanged(string filePath)
    {
        try
        {
            // Parse: "org/project/file.xml" -> org, project, file
            var parts = filePath.Split('/', 3);
            if (parts.Length != 3) return;

            var organization = parts[0];
            var projectId = parts[1];
            var fileName = parts[2];

            SelectedProjectId = $"{organization}/{projectId}";
            SelectedFileName = fileName;
            XmlContent = null;
            OutputContent = null;

            IsLoadingXml = true;
            UpdateToolbarState();
            StateHasChanged();

            var xmlFilePath = Path.Combine("/app/data/input", organization, "projects", projectId, fileName);
            XmlContent = await ProjectService.ReadInputFileAsync(SelectedProjectId, fileName);
            Logger.LogInformation("Loaded file {FileName} from project {ProjectId}", fileName, SelectedProjectId);

            // Start watching the XML file
            try
            {
                XmlFileWatcher.StartWatching(xmlFilePath);
                Logger.LogInformation("Started watching XML file: {Path}", xmlFilePath);
            }
            catch (Exception watchEx)
            {
                Logger.LogError(watchEx, "Failed to start XML file watcher");
            }

            // Auto-transform if enabled
            if (AutoTransform && CanTransform)
            {
                await TransformAsync();
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading file from path {Path}", filePath);
            ToastNotification.ShowError($"Failed to load file: {ex.Message}");
        }
        finally
        {
            IsLoadingXml = false;
            UpdateToolbarState();
            StateHasChanged();

            // Initialize or update Monaco viewer
            if (!string.IsNullOrEmpty(XmlContent))
            {
                _ = InvokeAsync(async () =>
                {
                    await Task.Delay(200);
                    try
                    {
                        if (_sourceXmlViewerInitialized)
                        {
                            await JSRuntime.InvokeVoidAsync("MonacoViewerInterop.setValue", "sourceXml", XmlContent ?? "");
                        }
                        else
                        {
                            var sourceXmlTheme = ThemeService.GetMonacoTheme();
                            await JSRuntime.InvokeVoidAsync("MonacoViewerInterop.createViewer",
                                "source-xml-viewer",
                                "sourceXml",
                                new { value = XmlContent ?? "", language = "xml", theme = sourceXmlTheme });
                            _sourceXmlViewerInitialized = true;
                        }
                    }
                    catch (Exception ex)
                    {
                        Logger.LogError(ex, "Error initializing/updating Source XML viewer");
                    }
                });
            }

            // Save selection to localStorage
            if (!isRestoringFromStorage)
            {
                await JSRuntime.InvokeVoidAsync("developmentStorage.saveSelection", SelectedProjectId, SelectedFileName, SelectedXsltFile);
            }
        }
    }

    private async Task OnProjectChanged(ChangeEventArgs e)
    {
        try
        {
            SelectedProjectId = e.Value?.ToString();
            SelectedFileName = null;
            XmlContent = null;
            OutputContent = null;
            ProjectFiles = null;

            if (!string.IsNullOrEmpty(SelectedProjectId))
            {
                IsLoading = true;
                UpdateToolbarState();
                StateHasChanged();
                ProjectFiles = (await ProjectService.GetProjectFilesAsync(SelectedProjectId)).ToList();
                Logger.LogInformation("Loaded {Count} files for project {ProjectId}", ProjectFiles.Count, SelectedProjectId);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading project files");
            ToastNotification.ShowError($"Failed to load project files: {ex.Message}");
        }
        finally
        {
            IsLoading = false;
            UpdateToolbarState();
            StateHasChanged();

            // Save selection to localStorage (unless we're restoring)
            if (!isRestoringFromStorage)
            {
                await JSRuntime.InvokeVoidAsync("developmentStorage.saveSelection", SelectedProjectId, SelectedFileName, SelectedXsltFile);
            }
        }
    }

    private async Task OnFileChanged(ChangeEventArgs e)
    {
        try
        {
            SelectedFileName = e.Value?.ToString();
            XmlContent = null;
            OutputContent = null;
            UpdateToolbarState();
            StateHasChanged();

            if (!string.IsNullOrEmpty(SelectedProjectId) && !string.IsNullOrEmpty(SelectedFileName))
            {
                IsLoadingXml = true;
                StateHasChanged();

                var xmlFilePath = Path.Combine("/app/data/input/optiver/projects", SelectedProjectId, SelectedFileName);
                XmlContent = await ProjectService.ReadInputFileAsync(SelectedProjectId, SelectedFileName);
                Logger.LogInformation("Loaded file {FileName} from project {ProjectId}", SelectedFileName, SelectedProjectId);

                // Start watching the XML file for external changes
                try
                {
                    XmlFileWatcher.StartWatching(xmlFilePath);
                    Logger.LogInformation("Started watching XML file for external changes: {Path}", xmlFilePath);
                }
                catch (Exception watchEx)
                {
                    Logger.LogError(watchEx, "Failed to start XML file watcher");
                    // Non-critical, continue without watcher
                }

                // Auto-transform if enabled
                if (AutoTransform && CanTransform)
                {
                    await TransformAsync();
                }
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading XML file");
            ToastNotification.ShowError($"Failed to load XML file: {ex.Message}");
        }
        finally
        {
            IsLoadingXml = false;
            UpdateToolbarState();
            StateHasChanged();

            // Initialize or update Monaco viewer
            if (!string.IsNullOrEmpty(XmlContent))
            {
                _ = InvokeAsync(async () =>
                {
                    await Task.Delay(200); // Give Blazor time to render the container
                    try
                    {
                        if (_sourceXmlViewerInitialized)
                        {
                            // Update existing viewer
                            await JSRuntime.InvokeVoidAsync("MonacoViewerInterop.setValue",
                                "sourceXml",
                                XmlContent ?? "");
                            Logger.LogInformation("Updated Source XML viewer content");
                        }
                        else
                        {
                            // Initialize viewer for the first time
                            var sourceXmlTheme = ThemeService.GetMonacoTheme();
                            await JSRuntime.InvokeVoidAsync("MonacoViewerInterop.createViewer",
                                "source-xml-viewer",
                                "sourceXml",
                                new {
                                    value = XmlContent ?? "",
                                    language = "xml",
                                    theme = sourceXmlTheme
                                });
                            _sourceXmlViewerInitialized = true;
                            Logger.LogInformation("Source XML viewer initialized after file load");
                        }
                    }
                    catch (Exception ex)
                    {
                        Logger.LogError(ex, "Error initializing/updating Source XML viewer");
                    }
                });
            }

            // Save selection to localStorage (unless we're restoring)
            if (!isRestoringFromStorage)
            {
                await JSRuntime.InvokeVoidAsync("developmentStorage.saveSelection", SelectedProjectId, SelectedFileName, SelectedXsltFile);
            }
        }
    }

    private async Task OnXsltFileChanged(ChangeEventArgs e)
    {
        try
        {
            SelectedXsltFile = e.Value?.ToString();
            if (string.IsNullOrEmpty(SelectedXsltFile)) return;

            Logger.LogInformation("XSLT file selection changed to {File}", SelectedXsltFile);

            IsLoadingXslt = true;
            StateHasChanged();

            var xsltPath = $"/app/xslt/{SelectedXsltFile}";
            if (File.Exists(xsltPath))
            {
                // Set flag to prevent auto-transform during file load
                isUpdatingFromExternalFile = true;

                XsltContent = await File.ReadAllTextAsync(xsltPath);
                Logger.LogInformation("Loaded XSLT file from {Path}", xsltPath);

                // Update file watcher to watch the new file
                try
                {
                    XsltFileWatcher.StartWatching(xsltPath);
                    Logger.LogInformation("Started watching XSLT file for external changes");
                }
                catch (Exception watchEx)
                {
                    Logger.LogError(watchEx, "Failed to start XSLT file watcher");
                }

                // Save selection to localStorage
                await JSRuntime.InvokeVoidAsync("developmentStorage.saveSelection", SelectedProjectId, SelectedFileName, SelectedXsltFile);
            }
            else
            {
                Logger.LogWarning("XSLT file not found at {Path}", xsltPath);
                ToastNotification.ShowWarning($"XSLT file not found: {SelectedXsltFile}");
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading XSLT file");
            ToastNotification.ShowError($"Failed to load XSLT file: {ex.Message}");
        }
        finally
        {
            isUpdatingFromExternalFile = false;
            IsLoadingXslt = false;
            StateHasChanged();

            // Re-initialize Monaco editor after skeleton disappears
            // The LoadingSkeleton component may have destroyed the Monaco DOM
            if (monacoInitialized && !string.IsNullOrEmpty(XsltContent))
            {
                _ = InvokeAsync(async () =>
                {
                    await Task.Delay(200); // Give Blazor time to render the container

                    try
                    {
                        // Check if Monaco editor needs re-initialization
                        var needsReinit = await JSRuntime.InvokeAsync<bool>("eval",
                            "document.querySelector('#monaco-editor-container').innerHTML === ''");

                        if (needsReinit)
                        {
                            Logger.LogWarning("Monaco editor container is empty, re-initializing");
                            monacoInitialized = false;

                            var theme = ThemeService.GetMonacoTheme();
                            await JSRuntime.InvokeVoidAsync("MonacoEditorInterop.initialize",
                                "monaco-editor-container",
                                XsltContent,
                                dotNetRef,
                                theme);
                            monacoInitialized = true;
                            Logger.LogInformation("Monaco editor re-initialized after file change");
                        }
                        else
                        {
                            // Monaco editor exists, just update content
                            await JSRuntime.InvokeVoidAsync("MonacoEditorInterop.setValue", XsltContent);
                            await Task.Delay(50);
                            await JSRuntime.InvokeVoidAsync("MonacoEditorInterop.resize");
                            Logger.LogInformation("Updated Monaco editor with new XSLT file content");
                        }
                    }
                    catch (Exception ex)
                    {
                        Logger.LogError(ex, "Error updating/re-initializing Monaco editor");
                        ToastNotification.ShowError("Failed to update editor. Please refresh the page.");
                    }
                });
            }
        }
    }

    private async Task OnXsltChanged()
    {
        // Don't trigger auto-transform if we're updating from external file
        // (external file handler will trigger transform itself)
        if (isUpdatingFromExternalFile)
        {
            Logger.LogDebug("OnXsltChanged: Skipping auto-transform (updating from external file)");
            return;
        }

        // Auto-transform if enabled
        if (AutoTransform && CanTransform && !IsTransforming)
        {
            Logger.LogInformation("OnXsltChanged: Auto-transform triggered by editor change");
            await TransformAsync();
        }
    }

    private async void OnXsltFileChangedExternally(object? sender, XsltFileChangedEventArgs e)
    {
        // This is called from file watcher thread, marshal to UI thread
        await InvokeAsync(async () =>
        {
            try
            {
                Logger.LogInformation("XSLT file updated externally at {Path}", e.FilePath);

                // Set flag to prevent Monaco from triggering auto-transform
                isUpdatingFromExternalFile = true;

                // Update XSLT content
                XsltContent = e.Content;

                // Update Monaco editor if initialized
                if (monacoInitialized)
                {
                    await JSRuntime.InvokeVoidAsync("MonacoEditorInterop.setValue", XsltContent);
                }

                StateHasChanged();

                // Auto-transform if enabled
                if (AutoTransform && CanTransform && !IsTransforming)
                {
                    Logger.LogInformation("Auto-transform triggered by external XSLT file change");
                    await TransformAsync();
                }
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Error handling external XSLT file change");
                ToastNotification.ShowError($"Failed to reload XSLT: {ex.Message}");
            }
            finally
            {
                // Clear flag (Monaco won't fire change event due to isSettingValueProgrammatically)
                isUpdatingFromExternalFile = false;
            }
        });
    }

    private async void OnXmlFileChangedExternally(object? sender, XmlFileChangedEventArgs e)
    {
        // This is called from file watcher thread, marshal to UI thread
        await InvokeAsync(async () =>
        {
            try
            {
                Logger.LogInformation("XML file updated externally at {Path}", e.FilePath);

                // Update XML content
                XmlContent = e.Content;

                // Update Source XML viewer if initialized
                if (_sourceXmlViewerInitialized)
                {
                    await JSRuntime.InvokeVoidAsync("MonacoViewerInterop.setValue", "sourceXml", XmlContent);
                    Logger.LogInformation("Updated Source XML viewer with external file changes");
                }

                StateHasChanged();

                // Show notification to user
                ToastNotification.ShowInfo("Source XML reloaded from disk");

                // Auto-transform if enabled
                if (AutoTransform && CanTransform && !IsTransforming)
                {
                    Logger.LogInformation("Auto-transform triggered by external XML file change");
                    await TransformAsync();
                }
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Error handling external XML file change");
                ToastNotification.ShowError($"Failed to reload XML: {ex.Message}");
            }
        });
    }

    private async Task TransformAsync()
    {
        if (!CanTransform) return;

        try
        {
            IsTransforming = true;
            TransformationError = null; // Clear any previous error
            UpdateToolbarState();

            // ALWAYS use transformation.xslt as the main XSLT file for transformations
            var transformationXsltPath = "/app/xslt/transformation.xslt";
            string transformationXsltContent;

            if (File.Exists(transformationXsltPath))
            {
                transformationXsltContent = await File.ReadAllTextAsync(transformationXsltPath);
                Logger.LogInformation("Loaded transformation.xslt for transformation (length: {Length})", transformationXsltContent?.Length ?? 0);
            }
            else
            {
                Logger.LogError("transformation.xslt not found at {Path}", transformationXsltPath);
                TransformationError = "transformation.xslt not found. Cannot perform transformation.";
                return;
            }

            var options = new TransformationOptions
            {
                UseXslt3Service = UseXslt3Service,
                NormalizeHeaders = NormalizeHeaders
            };

            // Check if we're editing a module file (not transformation.xslt)
            var isEditingModule = !string.IsNullOrEmpty(SelectedXsltFile) &&
                                  !SelectedXsltFile.Equals("transformation.xslt", StringComparison.OrdinalIgnoreCase);

            TransformationResult result;

            if (isEditingModule && !string.IsNullOrEmpty(XsltContent))
            {
                // Use the new method that supports edited module content from Monaco
                Logger.LogInformation("Transforming with edited module file: {File}", SelectedXsltFile);
                result = await XsltService.TransformWithEditedModuleAsync(
                    XmlContent!,
                    transformationXsltContent,
                    SelectedXsltFile,
                    XsltContent,
                    options);
            }
            else
            {
                // Standard transformation (either transformation.xslt is selected, or no module editing)
                Logger.LogInformation("Standard transformation using transformation.xslt");
                result = await XsltService.TransformAsync(XmlContent!, transformationXsltContent, options);
            }

            if (result.IsSuccess)
            {
                TransformationError = null; // Clear error on success
                OutputContent = result.OutputContent;
                TransformationStats = result;
                Logger.LogInformation("Transformation successful in {Time}ms. OutputContent length: {Length}", result.ProcessingTimeMs, OutputContent?.Length ?? 0);

                // Trigger visual success feedback (green glow on Transform button)
                await TriggerTransformSuccessEffect();

                if (result.WarningMessages.Any())
                {
                    foreach (var warning in result.WarningMessages)
                    {
                        ToastNotification.ShowWarning(warning);
                    }
                }

                // Update or initialize Output XML viewer (only if Source view is active)
                if (!ShowRendered)
                {
                    _ = InvokeAsync(async () =>
                    {
                        await Task.Delay(100); // Give Blazor time to render the container
                        try
                        {
                            if (!_outputXmlViewerInitialized)
                            {
                                var outputTheme = ThemeService.GetMonacoTheme();
                                await JSRuntime.InvokeVoidAsync("MonacoViewerInterop.createViewer",
                                    "output-xml-viewer",
                                    "outputXml",
                                    new {
                                        value = OutputContent ?? "",
                                        language = "xml",
                                        theme = outputTheme
                                    });
                                _outputXmlViewerInitialized = true;
                                Logger.LogInformation("Output XML viewer initialized after transformation");
                            }
                            else
                            {
                                await JSRuntime.InvokeVoidAsync("MonacoViewerInterop.setValue",
                                    "outputXml",
                                    OutputContent ?? "");
                                Logger.LogInformation("Updated Output XML viewer content");
                            }
                        }
                        catch (Exception ex)
                        {
                            Logger.LogError(ex, "Error initializing/updating Output XML viewer");
                        }
                    });
                }
            }
            else
            {
                Logger.LogError("Transformation failed: {Error}", result.ErrorMessage);
                TransformationError = result.ErrorMessage;
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error during transformation");
            TransformationError = $"Transformation error: {ex.Message}";
        }
        finally
        {
            IsTransforming = false;
            UpdateToolbarState();
            StateHasChanged();
        }
    }

    private async Task SaveXsltAsync()
    {
        if (!CanSave || string.IsNullOrEmpty(SelectedXsltFile)) return;

        try
        {
            IsSaving = true;
            UpdateToolbarState();

            var xsltPath = $"/app/xslt/{SelectedXsltFile}";
            await File.WriteAllTextAsync(xsltPath, XsltContent!);

            ToastNotification.ShowSuccess($"XSLT file saved successfully: {SelectedXsltFile}");
            Logger.LogInformation("XSLT file saved to {Path}", xsltPath);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error saving XSLT file {File}", SelectedXsltFile);
            ToastNotification.ShowError($"Failed to save XSLT: {ex.Message}");
        }
        finally
        {
            IsSaving = false;
            UpdateToolbarState();
            StateHasChanged();
        }
    }

    private void ToggleSettings()
    {
        ShowSettings = !ShowSettings;
        UpdateToolbarState();
        StateHasChanged();
    }

    private void OnSettingsChanged()
    {
        // Save settings to localStorage asynchronously (fire-and-forget)
        _ = SaveSettingsAsync();
    }

    private async Task SaveSettingsAsync()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("developmentStorage.saveSettings", UseXslt3Service, NormalizeHeaders, AutoTransform);
            Logger.LogInformation("Settings saved: UseXslt3Service={UseXslt3}, NormalizeHeaders={Normalize}, AutoTransform={Auto}",
                UseXslt3Service, NormalizeHeaders, AutoTransform);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to save settings to localStorage");
        }
    }

    private async Task OnFilesUploaded()
    {
        // Refresh file list
        if (!string.IsNullOrEmpty(SelectedProjectId))
        {
            try
            {
                ProjectFiles = (await ProjectService.GetProjectFilesAsync(SelectedProjectId)).ToList();
                UpdateToolbarState();
                StateHasChanged();
                Logger.LogInformation("File list refreshed after upload");
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Error refreshing file list after upload");
                ToastNotification.ShowError($"Failed to refresh file list: {ex.Message}");
            }
        }
    }

    // Zoom controls
    private void ZoomIn()
    {
        if (ZoomLevel < 200)
        {
            ZoomLevel += 10;
            StateHasChanged();
        }
    }

    private void ZoomOut()
    {
        if (ZoomLevel > 50)
        {
            ZoomLevel -= 10;
            StateHasChanged();
        }
    }

    private void ResetZoom()
    {
        ZoomLevel = 100;
        StateHasChanged();
    }

    // Copy to clipboard
    private async Task CopyToClipboard()
    {
        try
        {
            if (!string.IsNullOrEmpty(OutputContent))
            {
                await JSRuntime.InvokeVoidAsync("navigator.clipboard.writeText", OutputContent);
                ToastNotification.ShowSuccess("Output copied to clipboard");
                Logger.LogInformation("Output copied to clipboard");
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error copying to clipboard");
            ToastNotification.ShowError($"Failed to copy to clipboard: {ex.Message}");
        }
    }

    // Download output
    private async Task DownloadOutput()
    {
        try
        {
            if (!string.IsNullOrEmpty(OutputContent))
            {
                var fileName = $"{SelectedProjectId ?? "output"}_{DateTime.Now:yyyyMMdd_HHmmss}.xhtml";
                var bytes = System.Text.Encoding.UTF8.GetBytes(OutputContent);
                var base64 = System.Convert.ToBase64String(bytes);

                await JSRuntime.InvokeVoidAsync("downloadFile", fileName, "application/xhtml+xml", base64);
                ToastNotification.ShowSuccess($"Downloaded {fileName}");
                Logger.LogInformation("Downloaded output as {FileName}", fileName);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error downloading output");
            ToastNotification.ShowError($"Failed to download output: {ex.Message}");
        }
    }

    // Monaco Editor Integration
    private DotNetObjectReference<Development>? dotNetRef;
    private bool monacoInitialized = false;
    private bool keyboardShortcutsInitialized = false;
    private bool _sourceXmlViewerInitialized = false;
    private bool _outputXmlViewerInitialized = false;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // Wait a bit to ensure JavaScript files are fully loaded
            await Task.Delay(200);

            // Load saved settings from localStorage
            try
            {
                var savedSettings = await JSRuntime.InvokeAsync<SavedSettings>("developmentStorage.loadSettings");
                if (savedSettings != null && savedSettings.HasStoredSettings)
                {
                    UseXslt3Service = savedSettings.UseXslt3Service;
                    NormalizeHeaders = savedSettings.NormalizeHeaders;
                    AutoTransform = savedSettings.AutoTransform;

                    Logger.LogInformation("Restored settings from localStorage: UseXslt3Service={UseXslt3}, NormalizeHeaders={Normalize}, AutoTransform={Auto}",
                        UseXslt3Service, NormalizeHeaders, AutoTransform);

                    StateHasChanged();
                }
                else
                {
                    Logger.LogInformation("No stored settings found, using defaults: UseXslt3Service={UseXslt3}, NormalizeHeaders={Normalize}, AutoTransform={Auto}",
                        UseXslt3Service, NormalizeHeaders, AutoTransform);
                }
            }
            catch (Exception ex)
            {
                Logger.LogWarning(ex, "Could not restore settings from localStorage, using defaults");
            }

            // Initialize keyboard shortcuts
            if (!keyboardShortcutsInitialized)
            {
                try
                {
                    dotNetRef = DotNetObjectReference.Create(this);
                    await JSRuntime.InvokeVoidAsync("KeyboardShortcuts.initialize", dotNetRef);
                    keyboardShortcutsInitialized = true;
                    Logger.LogInformation("Keyboard shortcuts initialized");
                }
                catch (Exception ex)
                {
                    Logger.LogError(ex, "Failed to initialize keyboard shortcuts");
                }
            }

            // Initialize Bootstrap tooltips for panel help buttons
            try
            {
                await JSRuntime.InvokeVoidAsync("eval", @"
                    if (typeof bootstrap !== 'undefined') {
                        var tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle=""tooltip""]'));
                        tooltipTriggerList.map(function (tooltipTriggerEl) {
                            return new bootstrap.Tooltip(tooltipTriggerEl, {
                                trigger: 'hover focus',
                                container: 'body'
                            });
                        });
                    }
                ");
                Logger.LogInformation("Bootstrap tooltips initialized for panel help buttons");
            }
            catch (Exception ex)
            {
                Logger.LogWarning(ex, "Failed to initialize Bootstrap tooltips");
            }

            // Initialize Monaco Editor for XSLT
            if (!string.IsNullOrEmpty(XsltContent) && !monacoInitialized)
            {
                try
                {
                    var theme = ThemeService.GetMonacoTheme();
                    await JSRuntime.InvokeVoidAsync("MonacoEditorInterop.initialize",
                        "monaco-editor-container",
                        XsltContent,
                        dotNetRef,
                        theme);
                    monacoInitialized = true;
                    Logger.LogInformation("Monaco Editor initialized successfully");
                }
                catch (Exception ex)
                {
                    Logger.LogError(ex, "Failed to initialize Monaco Editor");
                    ToastNotification.ShowError("Failed to initialize code editor. Using fallback mode.");
                }
            }

            // Initialize Source XML viewer
            if (!string.IsNullOrEmpty(XmlContent) && !_sourceXmlViewerInitialized)
            {
                try
                {
                    var sourceXmlTheme = ThemeService.GetMonacoTheme();
                    await JSRuntime.InvokeVoidAsync("MonacoViewerInterop.createViewer",
                        "source-xml-viewer",
                        "sourceXml",
                        new {
                            value = XmlContent ?? "",
                            language = "xml",
                            theme = sourceXmlTheme
                        });
                    _sourceXmlViewerInitialized = true;
                    Logger.LogInformation("Source XML viewer initialized successfully");
                }
                catch (Exception ex)
                {
                    Logger.LogError(ex, "Failed to initialize Source XML viewer");
                }
            }

            // Load saved selections from localStorage and restore them

            try
            {
                var savedSelection = await JSRuntime.InvokeAsync<SavedSelection>("developmentStorage.loadSelection");
                if (savedSelection != null && !string.IsNullOrEmpty(savedSelection.ProjectId))
                {
                    Logger.LogInformation("Restoring saved selection: Project={Project}, File={File}, XsltFile={XsltFile}",
                        savedSelection.ProjectId, savedSelection.FileName, savedSelection.XsltFile);

                    // Set flag to prevent saving during restoration
                    isRestoringFromStorage = true;

                    try
                    {
                        // Restore XSLT file selection first
                        if (!string.IsNullOrEmpty(savedSelection.XsltFile))
                        {
                            SelectedXsltFile = savedSelection.XsltFile;
                            // Reload XSLT to use the restored file
                            await LoadXsltAsync();
                        }

                        // Restore file selection if available (using the new combined path approach)
                        if (!string.IsNullOrEmpty(savedSelection.ProjectId) && !string.IsNullOrEmpty(savedSelection.FileName))
                        {
                            // Wait for projects to load
                            await Task.Delay(800);
                            var filePath = $"{savedSelection.ProjectId}/{savedSelection.FileName}";
                            await OnFilePathChanged(filePath);
                        }
                    }
                    finally
                    {
                        // Clear the flag after restoration is complete
                        isRestoringFromStorage = false;
                    }
                }
                else
                {
                    Logger.LogInformation("No saved selection found in localStorage");
                }
            }
            catch (Exception ex)
            {
                Logger.LogWarning(ex, "Could not restore saved selection from localStorage");
                isRestoringFromStorage = false;
            }
        }
    }

    [JSInvokable]
    public async Task OnEditorContentChanged(string content)
    {
        Logger.LogDebug("OnEditorContentChanged called (isUpdatingFromExternalFile={IsUpdating})", isUpdatingFromExternalFile);
        XsltContent = content;
        await OnXsltChanged();
    }

    [JSInvokable]
    public async Task OnSaveShortcut()
    {
        await SaveXsltAsync();
    }

    [JSInvokable]
    public async Task OnTransformShortcut()
    {
        await TransformAsync();
    }

    [JSInvokable]
    public void OnShowHelp()
    {
        // This would trigger help panel in MainLayout
        // For now, just show a toast
        ToastNotification.ShowInfo("Press ? to show help panel");
    }

    private async Task TriggerTransformSuccessEffect()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("VisualFeedback.triggerTransformSuccess");
        }
        catch (Exception ex)
        {
            Logger.LogWarning(ex, "Failed to trigger transform success effect");
        }
    }

    public async ValueTask DisposeAsync()
    {
        // Clear file watcher callbacks
        XsltFileWatcher.SetFileChangedCallback(null);
        XmlFileWatcher.SetFileChangedCallback(null);

        // Dispose Source XML viewer
        if (_sourceXmlViewerInitialized)
        {
            try
            {
                await JSRuntime.InvokeVoidAsync("MonacoViewerInterop.dispose", "sourceXml");
                Logger.LogInformation("Disposed Source XML viewer");
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Error disposing Source XML viewer");
            }
        }

        // Dispose Output XML viewer
        if (_outputXmlViewerInitialized)
        {
            try
            {
                await JSRuntime.InvokeVoidAsync("MonacoViewerInterop.dispose", "outputXml");
                Logger.LogInformation("Disposed Output XML viewer");
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Error disposing Output XML viewer");
            }
        }

        // Dispose Monaco Editor
        if (monacoInitialized)
        {
            try
            {
                await JSRuntime.InvokeVoidAsync("MonacoEditorInterop.dispose");
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Error disposing Monaco Editor");
            }
        }

        dotNetRef?.Dispose();
    }
}
