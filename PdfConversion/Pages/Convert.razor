@page "/convert/{customer}/{projectId}"
@using System
@using System.IO
@using System.Xml.Linq
@using PdfConversion.Services
@using PdfConversion.Models
@using PdfConversion.Components
@using PdfConversion.Utils
@inject IProjectManagementService ProjectService
@inject IConversionService ConversionService
@inject IRoundTripValidationService ValidationService
@inject IUserSelectionService UserSelectionService
@inject ILogger<Pages.Convert> Logger
@inject IJSRuntime JSRuntime
@inject ProjectMetadataService MetadataService
@inject IFileGroupBuilderService FileGroupBuilder
@inject IProjectValidationService ProjectValidation
@inject NavigationManager NavigationManager
@inject IProjectLoadingService ProjectLoader
@inject ISourceDetectionService SourceDetectionService
@inject WorkflowStateService WorkflowState
@implements IDisposable

<PageTitle>Convert: PDF to Taxxor Sections</PageTitle>

<div class="convert-container">
    <div class="convert-header">
        <h3>Convert: PDF to Taxxor Sections</h3>
        <p class="text-muted">Convert transformed PDF documents into individual Taxxor section XML files</p>
    </div>

    <!-- Configuration Panel -->
    <div class="convert-panel">
        <div class="panel-header">
            <h5>Configuration</h5>
        </div>
        <div class="panel-body">
            <div class="row g-3">
                <!-- Normalized XML Selection with Status Indicators -->
                <div class="col-12">
                    <label class="form-label mb-1">Select Normalized XML</label>
                    @if (ProjectFileGroups.Any() && ProjectFileGroups.SelectMany(g => g.Files).Any())
                    {
                        <div class="normalized-xml-list">
                            @foreach (var group in ProjectFileGroups)
                            {
                                @foreach (var file in group.Files)
                                {
                                    var hasHierarchy = _hierarchyStatus.ContainsKey(file.FullPath) && _hierarchyStatus[file.FullPath];
                                    var isSelected = _config.SourceFile?.EndsWith(file.FileName) == true;
                                    var hierarchyName = GetExpectedHierarchyName(file.FileName);

                                    <div class="normalized-xml-item @(isSelected ? "selected" : "") @(hasHierarchy || _exportAsSingleSection ? "ready" : "needs-hierarchy")"
                                         @onclick="@(() => SelectNormalizedXml(file.FullPath, file.FileName, hasHierarchy))"
                                         style="@(IsProcessing ? "pointer-events: none; opacity: 0.6;" : "")">
                                        <div class="item-content">
                                            <div class="item-main">
                                                <span class="status-icon">
                                                    @if (hasHierarchy || _exportAsSingleSection)
                                                    {
                                                        <i class="bi bi-check-circle-fill text-success"></i>
                                                    }
                                                    else
                                                    {
                                                        <i class="bi bi-circle text-warning"></i>
                                                    }
                                                </span>
                                                <span class="file-name">@file.FileName</span>
                                                <span class="status-badge @(hasHierarchy || _exportAsSingleSection ? "badge-ready" : "badge-needs-hierarchy")">
                                                    @if (hasHierarchy)
                                                    {
                                                        @("Ready")
                                                    }
                                                    else if (_exportAsSingleSection)
                                                    {
                                                        @("Single Section")
                                                    }
                                                    else
                                                    {
                                                        @("NEEDS HIERARCHY")
                                                    }
                                                </span>
                                            </div>
                                            @if (!hasHierarchy)
                                            {
                                                @if (_exportAsSingleSection)
                                                {
                                                    <div class="item-hint item-hint-single-section">
                                                        <i class="bi bi-check-circle"></i>
                                                        Single section mode - no hierarchy needed
                                                    </div>
                                                }
                                                else
                                                {
                                                    <div class="item-hint">
                                                        <i class="bi bi-info-circle"></i>
                                                        Go to Generate Hierarchy to create @hierarchyName
                                                    </div>
                                                }
                                            }
                                            else
                                            {
                                                <div class="item-hierarchy">
                                                    <i class="bi bi-diagram-3"></i>
                                                    @hierarchyName
                                                </div>
                                            }
                                        </div>
                                    </div>
                                }
                            }
                        </div>
                    }
                    else
                    {
                        <div class="alert alert-info">
                            <i class="bi bi-info-circle"></i>
                            No normalized XMLs available. Create one in the Transform page first.
                        </div>
                    }
                </div>

                <!-- Project Language Selection -->
                <div class="col-12 col-md-6 mt-2">
                    <label class="form-label mb-1">
                        <i class="bi bi-globe me-1"></i>
                        Content Language
                    </label>
                    <select class="form-select form-select-sm"
                            @bind="_selectedLanguage"
                            @bind:after="OnLanguageChangedAsync"
                            disabled="@IsProcessing">
                        @foreach (var lang in ProjectMetadata.SupportedLanguages)
                        {
                            <option value="@lang">@ProjectMetadata.LanguageDisplayNames[lang]</option>
                        }
                    </select>
                    <small class="text-muted small">Sets the lang attribute in generated section XML files</small>
                </div>

                <!-- Single Section Export Option -->
                <div class="col-12 col-md-6 mt-2">
                    <div class="single-section-option">
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" id="exportAsSingleSection"
                                   @bind="_exportAsSingleSection"
                                   @bind:after="OnExportModeChanged"
                                   disabled="@IsProcessing">
                            <label class="form-check-label" for="exportAsSingleSection">
                                <i class="bi bi-file-earmark-text me-1"></i>
                                Export as single section
                            </label>
                        </div>
                        <small class="text-muted">Exports entire document as one section (full-document.xml)</small>
                    </div>
                </div>
            </div>

            <!-- Action Buttons -->
            <div class="row mt-2">
                <div class="col-12">
                    <button class="btn btn-primary"
                            @onclick="StartConversion"
                            disabled="@(!_config.IsValid || IsProcessing)">
                        <i class="bi bi-play-circle"></i> Start Conversion
                    </button>
                    <button class="btn btn-danger ms-2"
                            @onclick="StopConversion"
                            disabled="@(!IsProcessing)">
                        <i class="bi bi-stop-circle"></i> Stop
                    </button>
                </div>
            </div>

            <!-- Validation Feedback -->
            @if (!string.IsNullOrEmpty(_validationError))
            {
                <div class="alert alert-danger mt-3" role="alert">
                    <i class="bi bi-exclamation-triangle"></i>
                    <strong>Error:</strong> @_validationError
                </div>
            }
            else if (!_config.IsValid && !IsProcessing)
            {
                <div class="alert alert-info mt-3" role="alert">
                    <i class="bi bi-info-circle"></i>
                    Select a fileset to start the conversion process
                </div>
            }
        </div>
    </div>

    <!-- Progress Panel -->
    @if (IsProcessing || ProcessingComplete)
    {
        <div class="convert-panel mt-3">
            <div class="panel-header">
                <h5>Progress</h5>
            </div>
            <div class="panel-body">
                <div class="progress-info">
                    <span>Processing: @CurrentItemIndex / @TotalItems sections (@ProgressPercentage%)</span>
                </div>
                <div class="progress mt-2" style="height: 30px;">
                    <div class="progress-bar progress-bar-striped @(IsProcessing ? "progress-bar-animated" : "") @(CurrentItemName == "Cancelled" ? "bg-warning" : "")"
                         role="progressbar"
                         style="width: @ProgressPercentage%"
                         aria-valuenow="@ProgressPercentage"
                         aria-valuemin="0"
                         aria-valuemax="100">
                        @ProgressPercentage%
                    </div>
                </div>
                @if (!string.IsNullOrEmpty(CurrentItemName))
                {
                    <div class="mt-2 @(CurrentItemName == "Cancelled" ? "text-warning" : "text-muted")">
                        <strong>Status:</strong>
                        @if (CurrentItemName == "Cancelled")
                        {
                            <span>@CurrentItemName (conversion stopped at section @CurrentItemIndex of @TotalItems)</span>
                        }
                        else if (CurrentItemName == "Complete")
                        {
                            <span>@CurrentItemName</span>
                        }
                        else if (CurrentItemName == "Failed")
                        {
                            <span class="text-danger">@CurrentItemName</span>
                        }
                        else
                        {
                            <span>Processing "@CurrentItemName"...</span>
                        }
                    </div>
                }
            </div>
        </div>
    }

    <!-- Validation Panel -->
    @if (ProcessingComplete && !string.IsNullOrEmpty(_config.ProjectId) && CurrentItemName != "Cancelled")
    {
        <div class="convert-panel mt-3">
            <div class="panel-header">
                <h5>Round-Trip Validation</h5>
                <button class="btn btn-sm btn-primary"
                        @onclick="StartValidation"
                        disabled="@IsValidating">
                    @if (IsValidating)
                    {
                        <span class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true"></span>
                        <span>Validating...</span>
                    }
                    else
                    {
                        <i class="bi bi-check-circle"></i>
                        <span> Validate Round-Trip</span>
                    }
                </button>
            </div>
            <div class="panel-body">
                @if (ValidationResult == null && !IsValidating)
                {
                    <div class="text-center text-muted p-4">
                        <i class="bi bi-info-circle fs-3"></i>
                        <p class="mt-2 mb-0">
                            Click "Validate Round-Trip" to verify that sections can be reconstructed back to the original normalized XML.
                        </p>
                    </div>
                }
                else
                {
                    <DiffViewer ValidationResult="@ValidationResult" />
                }
            </div>
        </div>
    }

    <!-- Log Panel -->
    <div class="convert-panel mt-3">
        <div class="panel-header">
            <h5>Log</h5>
            <button class="btn btn-sm btn-outline-secondary" @onclick="ClearLog">
                <i class="bi bi-trash"></i> Clear
            </button>
        </div>
        <div class="panel-body">
            <div class="log-viewer" @ref="_logViewerElement">
                @if (LogEntries.Any())
                {
                    @foreach (var entry in LogEntries)
                    {
                        <div class="log-entry">
                            <span class="log-time">[@entry.Time.ToString("HH:mm:ss")]</span>
                            <span class="log-message">@entry.Message</span>
                        </div>
                    }
                }
                else
                {
                    <div class="text-muted text-center p-4">
                        No log entries yet. Select configuration and start conversion.
                    </div>
                }
            </div>
        </div>
    </div>

    <!-- Duplicate Match Modal -->
    <DuplicateMatchModal DuplicateMatches="_pendingDuplicates"
                         TransformedDocument="_transformedDocumentContext"
                         ProcessedMatches="_processedMatchesContext"
                         AllHierarchyItems="_allHierarchyItems"
                         CurrentHierarchyItem="_currentHierarchyItem"
                         IsVisible="_showDuplicateModal"
                         CancellationTokenSource="_cancellationTokenSource"
                         OnSelectionConfirmed="HandleDuplicateSelectionConfirmed" />
</div>

@code {
    // Route Parameters
    [Parameter]
    public string Customer { get; set; } = string.Empty;

    [Parameter]
    public string ProjectId { get; set; } = string.Empty;

    // Query String Parameters - URL is source of truth
    [Parameter, SupplyParameterFromQuery(Name = "normalizedFile")]
    public string? NormalizedFileParam { get; set; }

    [Parameter, SupplyParameterFromQuery(Name = "hierarchyFile")]
    public string? HierarchyFileParam { get; set; }

    // Tracking fields for detecting parameter changes
    private string? _currentNormalizedFile;
    private string? _currentHierarchyFile;
    private int _navigationLoopCount = 0;
    private const int MAX_NAVIGATIONS = 5;

    // Configuration
    private readonly ConversionConfiguration _config = new();

    // State
    private List<Project>? Projects;
    private List<string>? SourceFiles;
    private List<string>? HierarchyFiles;
    private bool IsProcessing = false;
    private bool ProcessingComplete = false;

    // ProjectFileSelector helper properties
    private List<ProjectFileGroup> ProjectFileGroups { get; set; } = new();

    // Track hierarchy availability for each normalized XML
    private Dictionary<string, bool> _hierarchyStatus = new();
    private Dictionary<string, string> _matchingHierarchies = new();

    // Error message for validation failures
    private string? _validationError;

    // Project language setting
    private string _selectedLanguage = "en";

    // Single section export mode
    private bool _exportAsSingleSection = false;

    // Progress tracking
    private int CurrentItemIndex = 0;
    private int TotalItems = 0;
    private string? CurrentItemName;
    private int ProgressPercentage => TotalItems > 0 ? (CurrentItemIndex * 100 / TotalItems) : 0;

    // Cancellation support
    private CancellationTokenSource? _cancellationTokenSource;

    // Duplicate selection support
    private List<HeaderMatch>? _pendingDuplicates;
    private TaskCompletionSource<HeaderMatch?>? _duplicateSelectionTcs;
    private bool _showDuplicateModal = false;
    private XDocument? _transformedDocumentContext;
    private List<HeaderMatch>? _processedMatchesContext;
    private List<HierarchyItem>? _allHierarchyItems;
    private HierarchyItem? _currentHierarchyItem;

    // Log
    private readonly List<LogEntry> LogEntries = new();
    private ElementReference _logViewerElement;

    // Validation
    private bool IsValidating = false;
    private RoundTripValidationResult? ValidationResult = null;

    // Computed properties
    private bool IsProjectSelected => !string.IsNullOrEmpty(_config.ProjectId);

    protected override async Task OnInitializedAsync()
    {
        if (!ProjectValidation.IsValidProjectParameters(Customer, ProjectId))
        {
            NavigationManager.NavigateTo("/");
            return;
        }

        if (!ProjectValidation.ProjectExists(Customer, ProjectId))
        {
            NavigationManager.NavigateTo("/");
            return;
        }

        await LoadProjectsAsync();
        await InitializeFromUrlParametersAsync();
    }

    protected override async Task OnParametersSetAsync()
    {
        // Navigation loop detection
        if (_navigationLoopCount++ > MAX_NAVIGATIONS)
        {
            Logger.LogError("Navigation loop detected! OnParametersSetAsync called {Count} times. Aborting to prevent infinite loop.", _navigationLoopCount);
            _navigationLoopCount = 0;
            return;
        }

        Logger.LogInformation("OnParametersSetAsync: Detected navigation to {Customer}/{ProjectId} (loop count: {Count})", Customer, ProjectId, _navigationLoopCount);

        // Sync project context with WorkflowStateService (clears state if project changed)
        WorkflowState.SetProject(Customer, ProjectId);

        // Detect which parameters changed
        var projectChanged = (_config.ProjectId != $"{Customer}/{ProjectId}");
        var normalizedFileChanged = (NormalizedFileParam != _currentNormalizedFile);
        var hierarchyFileChanged = (HierarchyFileParam != _currentHierarchyFile);

        // Log parameter changes for debugging
        if (projectChanged || normalizedFileChanged || hierarchyFileChanged)
        {
            Logger.LogInformation(
                "Parameters changed - Project: {ProjectChanged}, NormalizedFile: {NormalizedChanged}, Hierarchy: {HierarchyChanged}",
                projectChanged, normalizedFileChanged, hierarchyFileChanged);

            // Clear state if parameters changed
            if (projectChanged)
            {
                // Clear project-specific state
                _config.SourceFile = null;
                _config.HierarchyFile = null;
                SourceFiles = null;
                HierarchyFiles = null;
                ProjectFileGroups.Clear();
                _hierarchyStatus.Clear();
                _matchingHierarchies.Clear();
            }

            // Update tracking variables
            _config.ProjectId = $"{Customer}/{ProjectId}";
            _currentNormalizedFile = NormalizedFileParam;
            _currentHierarchyFile = HierarchyFileParam;

            // Reload from disk based on URL parameters
            if (projectChanged)
            {
                await LoadProjectsAsync();
            }

            // Apply normalized file parameter
            if (!string.IsNullOrEmpty(_currentNormalizedFile))
            {
                _config.SourceFile = _currentNormalizedFile;
                Logger.LogInformation("Applied normalizedFile from URL: {File}", _currentNormalizedFile);
            }

            // Apply hierarchy file parameter
            if (!string.IsNullOrEmpty(_currentHierarchyFile))
            {
                _config.HierarchyFile = _currentHierarchyFile;
                Logger.LogInformation("Applied hierarchyFile from URL: {File}", _currentHierarchyFile);
            }

            // Reset navigation loop counter on successful parameter application
            _navigationLoopCount = 0;
            StateHasChanged();
        }
        else
        {
            Logger.LogDebug("No parameter changes detected, keeping existing state");
            // Reset navigation loop counter
            _navigationLoopCount = 0;
        }
    }

    private async Task InitializeFromUrlParametersAsync()
    {
        try
        {
            // Use URL parameters directly - this is a project-specific page
            var projectPath = $"{Customer}/{ProjectId}";
            _config.ProjectId = projectPath;

            Logger.LogInformation("Initialize Convert page for project: {Project}", projectPath);

            // Load project language setting
            var metadata = await MetadataService.GetProjectMetadata(Customer, ProjectId);
            _selectedLanguage = metadata?.Language ?? "en";
            Logger.LogInformation("Project language: {Language}", _selectedLanguage);

            // Load files for this specific project
            await LoadProjectFilesAsync(projectPath);

            // URL is source of truth - apply URL parameters if present
            if (!string.IsNullOrEmpty(NormalizedFileParam))
            {
                _config.SourceFile = NormalizedFileParam;
                _currentNormalizedFile = NormalizedFileParam;
                Logger.LogInformation("Applied normalizedFile from URL: {File}", NormalizedFileParam);
            }
            else if (!string.IsNullOrEmpty(WorkflowState.LastNormalizedOutput))
            {
                // Use normalized file from previous workflow stage
                _config.SourceFile = WorkflowState.LastNormalizedOutput;
                _currentNormalizedFile = WorkflowState.LastNormalizedOutput;
                Logger.LogInformation("Applied normalizedFile from WorkflowState: {File}", WorkflowState.LastNormalizedOutput);
            }

            if (!string.IsNullOrEmpty(HierarchyFileParam))
            {
                _config.HierarchyFile = HierarchyFileParam;
                _currentHierarchyFile = HierarchyFileParam;
                Logger.LogInformation("Applied hierarchyFile from URL: {File}", HierarchyFileParam);
            }
            else if (!string.IsNullOrEmpty(WorkflowState.LastHierarchyOutput))
            {
                // Use hierarchy file from previous workflow stage
                _config.HierarchyFile = WorkflowState.LastHierarchyOutput;
                _currentHierarchyFile = WorkflowState.LastHierarchyOutput;
                Logger.LogInformation("Applied hierarchyFile from WorkflowState: {File}", WorkflowState.LastHierarchyOutput);
            }

            // Auto-select if there's only one normalized XML with a ready hierarchy
            // (only if no file selected from URL or WorkflowState)
            if (string.IsNullOrEmpty(_config.SourceFile))
            {
                AutoSelectSingleReadyFile();
            }

            StateHasChanged();
        }
        catch (Exception ex)
        {
            Logger.LogWarning(ex, "Error initializing from URL parameters");
        }
    }

    private async Task LoadProjectFilesAsync(string projectId)
    {
        // Load source files (XML files in project root)
        var allFiles = (await ProjectService.GetProjectFilesAsync(projectId)).ToList();
        SourceFiles = allFiles.Where(f => f.EndsWith(".xml", StringComparison.OrdinalIgnoreCase)).ToList();

        // Load hierarchy files from output/[customer]/projects/[project-id]/hierarchies/
        var parts = projectId.Split('/', 2);
        if (parts.Length == 2)
        {
            var organization = parts[0];
            var projectIdShort = parts[1];
            var hierarchiesPath = Path.Combine("/app/data/output", organization, "projects", projectIdShort, "hierarchies");

            if (Directory.Exists(hierarchiesPath))
            {
                HierarchyFiles = Directory.GetFiles(hierarchiesPath, "*.xml")
                    .Select(Path.GetFileName)
                    .Where(f => !string.IsNullOrEmpty(f))
                    .Cast<string>()
                    .ToList();

                Logger.LogInformation("Loaded {HierarchyCount} hierarchy files from {Path}",
                    HierarchyFiles.Count, hierarchiesPath);
            }
            else
            {
                HierarchyFiles = new List<string>();
                Logger.LogInformation("Hierarchies directory not found: {Path}", hierarchiesPath);
            }
        }
        else
        {
            HierarchyFiles = new List<string>();
            Logger.LogWarning("Invalid projectId format: {ProjectId} (expected 'organization/project-id')", projectId);
        }

        Logger.LogInformation("Loaded {SourceCount} source files and {HierarchyCount} hierarchy files for project {ProjectId}",
            SourceFiles.Count, HierarchyFiles?.Count ?? 0, projectId);
    }

    private async Task LoadProjectsAsync()
    {
        try
        {
            // Use centralized ProjectLoadingService
            Projects = await ProjectLoader.LoadActiveProjectsWithLabelsAsync();

            // Build file groups for project/file selector (normalized XMLs only)
            ProjectFileGroups = await FileGroupBuilder.CreateQuery()
                .OnlyActiveProjects(false)
                .NormalizedFiles()  // Only show normalized XMLs from normalized/ folder
                .ForCustomer(Customer)
                .ForProject(ProjectId)
                .BuildAsync();

            // Load hierarchy status for each normalized XML
            await LoadHierarchyStatusAsync();

            Logger.LogInformation("Loaded {Count} active projects", Projects.Count);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading projects");
            AddLogEntry($"Error loading projects: {ex.Message}");
        }
    }

    private async Task LoadHierarchyStatusAsync()
    {
        _hierarchyStatus.Clear();
        _matchingHierarchies.Clear();

        foreach (var group in ProjectFileGroups)
        {
            foreach (var file in group.Files)
            {
                try
                {
                    var normalizedName = Path.GetFileName(file.FileName);
                    var hierarchyName = SourceDetectionService.GetMatchingHierarchyName(normalizedName);

                    // Check if hierarchy exists in output folder
                    if (!string.IsNullOrEmpty(group.Customer) && !string.IsNullOrEmpty(group.ProjectId))
                    {
                        var hierarchyPath = $"/app/data/output/{group.Customer}/projects/{group.ProjectId}/hierarchies/{hierarchyName}";
                        _hierarchyStatus[file.FullPath] = File.Exists(hierarchyPath);
                        _matchingHierarchies[file.FullPath] = hierarchyPath;

                        Logger.LogDebug("Hierarchy status for {File}: {Status} (expected at {Path})",
                            file.FileName,
                            _hierarchyStatus[file.FullPath] ? "exists" : "missing",
                            hierarchyPath);
                    }
                }
                catch (Exception ex)
                {
                    Logger.LogWarning(ex, "Could not determine hierarchy status for {File}", file.FileName);
                    _hierarchyStatus[file.FullPath] = false;
                }
            }
        }

        await Task.CompletedTask;
    }

    private string GetExpectedHierarchyName(string normalizedFileName)
    {
        try
        {
            var fileName = Path.GetFileName(normalizedFileName);
            return SourceDetectionService.GetMatchingHierarchyName(fileName);
        }
        catch
        {
            return "hierarchy.xml";
        }
    }

    private void SelectNormalizedXml(string fullPath, string fileName, bool hasHierarchy)
    {
        // In single section mode, hierarchy is not required
        if (!hasHierarchy && !_exportAsSingleSection)
        {
            // Don't allow selection of items without hierarchy
            AddLogEntry($"Cannot select {fileName} - hierarchy not available");
            return;
        }

        // Clear any previous validation error
        _validationError = null;

        // Include normalized/ prefix for pre-normalized files
        // The ConversionService expects paths like "normalized/docling-word.xml"
        _config.SourceFile = $"normalized/{fileName}";

        // Sync export mode to configuration
        _config.ExportAsSingleSection = _exportAsSingleSection;

        // Auto-select matching hierarchy if available (not required in single section mode)
        if (_matchingHierarchies.TryGetValue(fullPath, out var hierarchyPath))
        {
            _config.HierarchyFile = hierarchyPath;
            Logger.LogInformation("Selected normalized XML: {Source} with hierarchy: {Hierarchy}",
                _config.SourceFile, Path.GetFileName(hierarchyPath));
            AddLogEntry($"Selected: {fileName} with {Path.GetFileName(hierarchyPath)}");
        }
        else if (_exportAsSingleSection)
        {
            _config.HierarchyFile = null;
            Logger.LogInformation("Selected normalized XML for single section export: {Source}", _config.SourceFile);
            AddLogEntry($"Selected: {fileName} (single section mode)");
        }

        // Update URL with new normalizedFile and hierarchyFile parameters
        // OnParametersSetAsync will sync with WorkflowStateService
        var url = BuildUrlWithParams(
            normalizedFile: _config.SourceFile,
            hierarchyFile: _config.HierarchyFile
        );
        NavigationManager.NavigateTo(url);
    }

    /// <summary>
    /// Auto-selects the normalized XML if there's only one file with a ready hierarchy.
    /// </summary>
    private void AutoSelectSingleReadyFile()
    {
        // Get all files with ready hierarchies
        var readyFiles = ProjectFileGroups
            .SelectMany(g => g.Files)
            .Where(f => _hierarchyStatus.ContainsKey(f.FullPath) && _hierarchyStatus[f.FullPath])
            .ToList();

        if (readyFiles.Count == 1)
        {
            var file = readyFiles[0];
            Logger.LogInformation("Auto-selecting single ready file: {File}", file.FileName);
            SelectNormalizedXml(file.FullPath, file.FileName, hasHierarchy: true);
        }
    }

    private void OnHierarchyFileChanged(ChangeEventArgs e)
    {
        _config.HierarchyFile = e.Value?.ToString();
        if (!string.IsNullOrEmpty(_config.HierarchyFile))
        {
            AddLogEntry($"Hierarchy file selected: {_config.HierarchyFile}");

            // Update URL with new hierarchyFile parameter, preserve normalizedFile
            // OnParametersSetAsync will sync with WorkflowStateService
            var url = BuildUrlWithParams(
                normalizedFile: _currentNormalizedFile,
                hierarchyFile: _config.HierarchyFile
            );
            NavigationManager.NavigateTo(url);
        }
        else
        {
            StateHasChanged();
        }
    }

    private async Task OnLanguageChangedAsync()
    {
        try
        {
            await MetadataService.UpdateProjectLanguage(Customer, ProjectId, _selectedLanguage);
            AddLogEntry($"Content language set to: {ProjectMetadata.LanguageDisplayNames[_selectedLanguage]}");
            Logger.LogInformation("Updated project language to {Language} for {Customer}/{ProjectId}",
                _selectedLanguage, Customer, ProjectId);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to update project language");
            AddLogEntry($"Error updating language: {ex.Message}");
        }
    }

    private void OnExportModeChanged()
    {
        // Sync to config
        _config.ExportAsSingleSection = _exportAsSingleSection;

        // Log the change
        if (_exportAsSingleSection)
        {
            AddLogEntry("Export mode: Single section (full document)");
        }
        else
        {
            AddLogEntry("Export mode: Standard (multi-section with hierarchy)");
        }

        // Trigger UI update to reflect changes in file list styling
        StateHasChanged();
    }

    private async Task StartConversion()
    {
        // Sync export mode to configuration before validation
        _config.ExportAsSingleSection = _exportAsSingleSection;

        if (!_config.IsValid) return;

        // Clear any previous validation error
        _validationError = null;

        // Create new cancellation token source
        _cancellationTokenSource?.Dispose();
        _cancellationTokenSource = new CancellationTokenSource();

        IsProcessing = true;
        ProcessingComplete = false;
        CurrentItemIndex = 0;
        TotalItems = 0;
        CurrentItemName = "Initializing...";

        AddLogEntry("Starting conversion...");
        AddLogEntry($"Project: {_config.ProjectId}");
        AddLogEntry($"Source: {_config.SourceFile}");
        if (_exportAsSingleSection)
        {
            AddLogEntry($"Mode: Single section export");
        }
        else
        {
            AddLogEntry($"Hierarchy: {_config.HierarchyFile}");
        }
        AddLogEntry("");

        StateHasChanged();

        try
        {
            ConversionResult result;

            if (_exportAsSingleSection)
            {
                // Use single section conversion
                var sourceFileName = Path.GetFileName(_config.SourceFile!);
                result = await ConversionService.StartSingleSectionConversionAsync(
                    _config.ProjectId!,
                    _config.SourceFile!,
                    sourceFileName,
                    AddLogEntry,
                    _cancellationTokenSource.Token);
            }
            else
            {
                // Use standard multi-section conversion
                result = await ConversionService.StartConversionAsync(
                    _config.ProjectId!,
                    _config.SourceFile!,
                    _config.HierarchyFile!,
                    AddLogEntry,
                    HandleDuplicateSelection,
                    _cancellationTokenSource.Token);
            }

            TotalItems = result.TotalSections;
            CurrentItemIndex = result.SuccessfulSections + result.FailedSections;

            if (result.WasCancelled)
            {
                CurrentItemName = "Cancelled";
            }
            else if (!result.Success && result.Errors.Any())
            {
                // Validation or early failure - show error in alert panel
                _validationError = result.Errors.First();
                CurrentItemName = "Failed";
            }
            else
            {
                // When complete successfully, show 100% progress
                CurrentItemIndex = TotalItems;
                CurrentItemName = "Complete";
            }

            IsProcessing = false;
            ProcessingComplete = result.Success || result.WasCancelled;
            StateHasChanged();
        }
        catch (OperationCanceledException)
        {
            // Expected when cancellation is requested
            AddLogEntry("✗ Conversion cancelled by user");
            CurrentItemName = "Cancelled";
            IsProcessing = false;
            ProcessingComplete = true;
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error during conversion");
            AddLogEntry($"✗ Error: {ex.Message}");
            _validationError = ex.Message;
            CurrentItemName = "Failed";
            IsProcessing = false;
            ProcessingComplete = false;
            StateHasChanged();
        }
        finally
        {
            // Save conversion log to _work directory for debugging
            await SaveConversionLogToWorkDirectoryAsync();

            // Clean up cancellation token source
            _cancellationTokenSource?.Dispose();
            _cancellationTokenSource = null;
        }
    }

    private async Task SaveConversionLogToWorkDirectoryAsync()
    {
        try
        {
            var workPath = "/app/data/_work";
            if (!Directory.Exists(workPath))
            {
                Directory.CreateDirectory(workPath);
            }

            // Basic log format (timestamped messages)
            var basicLogPath = Path.Combine(workPath, "_conversion.log");
            var basicLogContent = string.Join("\n", LogEntries.Select(e => $"[{e.Time:HH:mm:ss}] {e.Message}"));
            await File.WriteAllTextAsync(basicLogPath, basicLogContent);

            // Extended LLM-friendly log format with context
            var extendedLogPath = Path.Combine(workPath, "_conversion-extended.log");
            var extendedLogContent = GenerateExtendedLogContent();
            await File.WriteAllTextAsync(extendedLogPath, extendedLogContent);

            Logger.LogInformation("Saved conversion logs to {BasicPath} and {ExtendedPath}", basicLogPath, extendedLogPath);
        }
        catch (Exception ex)
        {
            Logger.LogWarning(ex, "Failed to save conversion log to _work directory");
            // Non-critical, don't fail conversion
        }
    }

    private string GenerateExtendedLogContent()
    {
        var sb = new System.Text.StringBuilder();

        sb.AppendLine("=".PadRight(80, '='));
        sb.AppendLine("EXTENDED CONVERSION LOG FOR LLM ANALYSIS");
        sb.AppendLine("=".PadRight(80, '='));
        sb.AppendLine();

        // Configuration context
        sb.AppendLine("## CONFIGURATION");
        sb.AppendLine($"Project ID: {_config.ProjectId ?? "N/A"}");
        sb.AppendLine($"Source File: {_config.SourceFile ?? "N/A"}");
        sb.AppendLine($"Hierarchy File: {_config.HierarchyFile ?? "N/A"}");
        sb.AppendLine($"Timestamp: {DateTime.Now:yyyy-MM-dd HH:mm:ss}");
        sb.AppendLine();

        // Conversion log with timestamps
        sb.AppendLine("## CONVERSION LOG");
        sb.AppendLine();
        foreach (var entry in LogEntries)
        {
            sb.AppendLine($"[{entry.Time:HH:mm:ss}] {entry.Message}");
        }
        sb.AppendLine();

        // Statistics extraction from log
        sb.AppendLine("## STATISTICS");
        var successLines = LogEntries.Where(e => e.Message.Contains("✓")).Count();
        var errorLines = LogEntries.Where(e => e.Message.Contains("✗")).Count();
        var warningLines = LogEntries.Where(e => e.Message.Contains("⚠")).Count();
        var skippedLines = LogEntries.Where(e => e.Message.Contains("Skipping")).Count();

        sb.AppendLine($"Successful operations: {successLines}");
        sb.AppendLine($"Failed operations: {errorLines}");
        sb.AppendLine($"Warnings: {warningLines}");
        sb.AppendLine($"Skipped sections: {skippedLines}");
        sb.AppendLine();

        // Extract errors and warnings for quick reference
        var errors = LogEntries.Where(e => e.Message.Contains("✗") || e.Message.Contains("Error")).ToList();
        if (errors.Any())
        {
            sb.AppendLine("## ERRORS");
            foreach (var error in errors)
            {
                sb.AppendLine($"[{error.Time:HH:mm:ss}] {error.Message}");
            }
            sb.AppendLine();
        }

        var warnings = LogEntries.Where(e => e.Message.Contains("⚠") || e.Message.Contains("Warning")).ToList();
        if (warnings.Any())
        {
            sb.AppendLine("## WARNINGS");
            foreach (var warning in warnings)
            {
                sb.AppendLine($"[{warning.Time:HH:mm:ss}] {warning.Message}");
            }
            sb.AppendLine();
        }

        // Duplicate selection events (useful for debugging matching issues)
        var duplicates = LogEntries.Where(e => e.Message.Contains("Duplicate") || e.Message.Contains("duplicate")).ToList();
        if (duplicates.Any())
        {
            sb.AppendLine("## DUPLICATE HEADER HANDLING");
            foreach (var dup in duplicates)
            {
                sb.AppendLine($"[{dup.Time:HH:mm:ss}] {dup.Message}");
            }
            sb.AppendLine();
        }

        // Analysis prompt for LLM
        sb.AppendLine("## LLM ANALYSIS PROMPT");
        sb.AppendLine("Please analyze the conversion log above and identify:");
        sb.AppendLine("1. Any patterns in the errors or warnings");
        sb.AppendLine("2. Potential root causes for failures");
        sb.AppendLine("3. Sections that were skipped and why");
        sb.AppendLine("4. Header matching issues (duplicates, unmatched)");
        sb.AppendLine("5. Suggested fixes or improvements to the transformation/hierarchy");
        sb.AppendLine();

        sb.AppendLine("=".PadRight(80, '='));
        sb.AppendLine("END OF EXTENDED LOG");
        sb.AppendLine("=".PadRight(80, '='));

        return sb.ToString();
    }

    private Task StopConversion()
    {
        if (_cancellationTokenSource != null && !_cancellationTokenSource.IsCancellationRequested)
        {
            AddLogEntry("Stopping conversion...");
            _cancellationTokenSource.Cancel();
        }

        return Task.CompletedTask;
    }

    public void Dispose()
    {
        _cancellationTokenSource?.Dispose();
    }

    private void AddLogEntry(string message)
    {
        LogEntries.Add(new LogEntry
        {
            Time = DateTime.Now,
            Message = message
        });

        // Auto-scroll to bottom (will be implemented with JS interop if needed)
        StateHasChanged();
    }

    private void ClearLog()
    {
        LogEntries.Clear();
        StateHasChanged();
    }

    private async Task<HeaderMatch?> HandleDuplicateSelection(
        List<HeaderMatch> duplicates,
        XDocument transformedDocument,
        List<HeaderMatch> processedMatches,
        List<HierarchyItem> allHierarchyItems,
        HierarchyItem currentHierarchyItem)
    {
        // Create a new TaskCompletionSource to wait for user selection
        _duplicateSelectionTcs = new TaskCompletionSource<HeaderMatch?>();
        _pendingDuplicates = duplicates;
        _transformedDocumentContext = transformedDocument;
        _processedMatchesContext = processedMatches;
        _allHierarchyItems = allHierarchyItems;
        _currentHierarchyItem = currentHierarchyItem;
        _showDuplicateModal = true;

        // Trigger UI update to show modal
        StateHasChanged();

        // Wait for user to make selection
        var selectedMatch = await _duplicateSelectionTcs.Task;

        // Clean up
        _duplicateSelectionTcs = null;
        _pendingDuplicates = null;
        _transformedDocumentContext = null;
        _processedMatchesContext = null;
        _allHierarchyItems = null;
        _currentHierarchyItem = null;

        return selectedMatch;
    }

    private async Task HandleDuplicateSelectionConfirmed(HeaderMatch? selectedMatch)
    {
        // Hide modal
        _showDuplicateModal = false;
        StateHasChanged();

        // Complete the TaskCompletionSource with the user's selection
        if (_duplicateSelectionTcs != null && !_duplicateSelectionTcs.Task.IsCompleted)
        {
            _duplicateSelectionTcs.SetResult(selectedMatch);
        }

        await Task.CompletedTask;
    }

    private async Task StartValidation()
    {
        if (string.IsNullOrEmpty(_config.ProjectId))
        {
            Logger.LogWarning("Cannot start validation: no project selected");
            return;
        }

        IsValidating = true;
        ValidationResult = null;
        StateHasChanged();

        try
        {
            Logger.LogInformation("Starting round-trip validation for project {ProjectId}", _config.ProjectId);

            ValidationResult = await ValidationService.ValidateRoundTripAsync(_config.ProjectId, _config.SourceFile!, _config.HierarchyFile);

            Logger.LogInformation("Round-trip validation completed: {Result}", ValidationResult.ToString());
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error during round-trip validation");
            ValidationResult = new RoundTripValidationResult
            {
                Success = false,
                ErrorMessage = $"Validation error: {ex.Message}"
            };
        }
        finally
        {
            IsValidating = false;
            StateHasChanged();
        }
    }

    private class LogEntry
    {
        public DateTime Time { get; set; }
        public string Message { get; set; } = string.Empty;
    }

    private string BuildUrlWithParams(string? normalizedFile, string? hierarchyFile)
    {
        var baseUrl = $"/convert/{Customer}/{ProjectId}";
        var queryParams = new List<string>();

        if (!string.IsNullOrEmpty(normalizedFile))
            queryParams.Add($"normalizedFile={Uri.EscapeDataString(normalizedFile)}");

        if (!string.IsNullOrEmpty(hierarchyFile))
            queryParams.Add($"hierarchyFile={Uri.EscapeDataString(hierarchyFile)}");

        return queryParams.Count > 0
            ? $"{baseUrl}?{string.Join("&", queryParams)}"
            : baseUrl;
    }
}
