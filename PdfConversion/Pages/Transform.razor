@page "/transform"
@using PdfConversion.Services
@using PdfConversion.Models
@using PdfConversion.Shared
@using Microsoft.JSInterop
@using static PdfConversion.Shared.LoadingSkeleton
@implements IAsyncDisposable
@inject IProjectManagementService ProjectService
@inject IXsltTransformationService XsltService
@inject IFileService FileService
@inject IJSRuntime JSRuntime
@inject ILogger<Transform> Logger
@inject TransformToolbarState ToolbarState
@inject ThemeService ThemeService
@inject IXsltFileWatcherService XsltFileWatcher
@inject IXmlFileWatcherService XmlFileWatcher
@inject IXhtmlValidationService ValidationService
@inject IUserSelectionService UserSelectionService

<PageTitle>Transform</PageTitle>

<!-- Settings Panel (floating overlay when settings button clicked) -->
@if (ShowSettings)
{
    <div class="settings-overlay">
        <div class="settings-panel">
            <div class="settings-header">
                <h6 class="mb-0">Transformation Settings</h6>
                <button type="button" class="btn-close" @onclick="ToggleSettings" aria-label="Close"></button>
            </div>
            <div class="settings-body">
                <div class="form-check mb-2">
                    <input class="form-check-input" type="checkbox" id="useXslt3" @bind="UseXslt3Service" @bind:after="OnSettingsChanged">
                    <label class="form-check-label" for="useXslt3">
                        Use XSLT3 Service (XSLT 2.0/3.0)
                    </label>
                </div>
                <div class="form-check mb-2">
                    <input class="form-check-input" type="checkbox" id="normalizeHeaders" @bind="NormalizeHeaders" @bind:after="OnSettingsChanged">
                    <label class="form-check-label" for="normalizeHeaders">
                        Normalize Headers
                    </label>
                </div>
                <div class="form-check mb-2">
                    <input class="form-check-input" type="checkbox" id="autoTransform" @bind="AutoTransform" @bind:after="OnSettingsChanged">
                    <label class="form-check-label" for="autoTransform">
                        Auto-transform on XML or XSLT change
                    </label>
                </div>

                <hr class="my-3" />

                <div class="mt-3">
                    <FileUpload ProjectId="@SelectedProjectId" OnFilesUploaded="OnFilesUploaded" />
                </div>
            </div>
        </div>
    </div>
}

<!-- XML Steering Attributes Help Modal -->
<div class="modal fade" id="xmlSteeringAttributesModal" tabindex="-1" aria-labelledby="xmlSteeringAttributesModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg modal-dialog-centered modal-dialog-scrollable">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="xmlSteeringAttributesModalLabel">
                    <i class="bi bi-code-square me-2"></i>XML Steering Attributes
                </h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p class="lead">
                    Steering attributes allow you to control transformation behavior by adding special attributes to your input XML elements.
                </p>

                <div class="attribute-section">
                    <h6 class="attribute-title">
                        <i class="bi bi-table me-2"></i>Table Cell Injection
                    </h6>

                    <div class="attribute-details">
                        <div class="attribute-name">
                            <code>data-injectcell-position</code>
                        </div>
                        <p class="attribute-description">
                            Controls where missing cells are inserted in asymmetric table rows.
                        </p>

                        <div class="attribute-usage">
                            <strong>Applied to:</strong> <code>&lt;TABLE&gt;</code> element
                        </div>

                        <div class="attribute-values">
                            <strong>Values:</strong>
                            <ul>
                                <li><code>Integer (1 to N)</code> - Insert cells before position N</li>
                                <li><code>0, negative, or missing</code> - Append cells at end (default behavior)</li>
                            </ul>
                        </div>

                        <div class="attribute-example">
                            <strong>Example:</strong>
                            <pre><code>&lt;TABLE data-injectcell-position="2"&gt;
  &lt;TR&gt;
    &lt;TD&gt;Cell 1&lt;/TD&gt;
    &lt;TD&gt;Cell 2&lt;/TD&gt;
    &lt;TD&gt;Cell 3&lt;/TD&gt;
  &lt;/TR&gt;
  &lt;TR&gt;
    &lt;TD&gt;Cell 1&lt;/TD&gt;
    &lt;!-- Missing cell will be inserted at position 2 --&gt;
    &lt;TD&gt;Cell 3&lt;/TD&gt;
  &lt;/TR&gt;
&lt;/TABLE&gt;</code></pre>
                        </div>

                        <div class="attribute-effect">
                            <strong>Effect:</strong>
                            <p>
                                In rows with fewer cells than the maximum, new cells are inserted at the specified position instead of being appended to the end.
                                This helps maintain proper column alignment in tables where cells are missing from the middle of rows.
                            </p>
                        </div>
                    </div>
                </div>

                <div class="attribute-section">
                    <h6 class="attribute-title">
                        <i class="bi bi-type-h1 me-2"></i>Force Header Conversion
                    </h6>

                    <div class="attribute-details">
                        <div class="attribute-name">
                            <code>data-forceheader</code>
                        </div>
                        <p class="attribute-description">
                            Forces a paragraph element to be converted to a specific header level during transformation.
                        </p>

                        <div class="attribute-usage">
                            <strong>Applied to:</strong> <code>&lt;P&gt;</code> element
                        </div>

                        <div class="attribute-values">
                            <strong>Values:</strong>
                            <ul>
                                <li><code>h1</code> - Convert to level 1 header</li>
                                <li><code>h2</code> - Convert to level 2 header</li>
                                <li><code>h3</code> - Convert to level 3 header</li>
                                <li><code>h4</code> - Convert to level 4 header</li>
                            </ul>
                        </div>

                        <div class="attribute-example">
                            <strong>Example:</strong>
                            <pre><code>&lt;P data-forceheader="h2"&gt;Important Section Title&lt;/P&gt;</code></pre>
                        </div>

                        <div class="attribute-effect">
                            <strong>Effect:</strong>
                            <p>
                                The paragraph is transformed into the specified header level (e.g., <code>&lt;h2&gt;</code>) with a default <code>(a),(b),(c)</code> numbering scheme.
                                This is useful when Adobe Acrobat incorrectly classifies a section title as a paragraph instead of a header.
                            </p>
                        </div>

                        <div class="attribute-use-case">
                            <strong>Use case:</strong>
                            <p>
                                When Adobe Acrobat misidentifies document structure and marks important section titles as paragraphs (<code>&lt;P&gt;</code>) instead of headers (<code>&lt;H2&gt;</code>, <code>&lt;H3&gt;</code>, etc.),
                                use this attribute to correct the document structure and ensure proper hierarchy in the output.
                            </p>
                        </div>
                    </div>
                </div>

                <div class="alert alert-info mt-4" role="alert">
                    <i class="bi bi-info-circle me-2"></i>
                    <strong>Note:</strong> Steering attributes are processed during XSLT transformation.
                    They are removed from the final output XML.
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
            </div>
        </div>
    </div>
</div>

<!-- Output Preview Help Modal -->
<div class="modal fade" id="outputPreviewHelpModal" tabindex="-1" aria-labelledby="outputPreviewHelpModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="outputPreviewHelpModalLabel">
                    <i class="bi bi-eye me-2"></i>Output Preview
                </h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                @if (!string.IsNullOrEmpty(SavedNormalizedXmlPath))
                {
                    <div class="alert alert-info mb-0" role="alert">
                        <div class="d-flex align-items-start">
                            <i class="bi bi-folder-open me-3" style="font-size: 1.5rem;"></i>
                            <div class="flex-grow-1">
                                <h6 class="alert-heading mb-2">Normalized XML saved to:</h6>
                                <code class="d-block mb-3 p-2 bg-light rounded">@SavedNormalizedXmlPath</code>
                                <button type="button" class="btn btn-sm btn-outline-primary" @onclick="() => CopyPathToClipboard(SavedNormalizedXmlPath)">
                                    <i class="bi bi-clipboard me-1"></i>Copy Path
                                </button>
                            </div>
                        </div>
                    </div>
                }
                else
                {
                    <div class="text-muted text-center py-3">
                        <i class="bi bi-info-circle me-2"></i>
                        Transform the XML to see the saved file path
                    </div>
                }
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
            </div>
        </div>
    </div>
</div>

<!-- Validation Errors Modal (Draggable) -->
@if (ValidationResult != null)
{
    <div class="modal fade" id="validationErrorsModal" tabindex="-1" aria-labelledby="validationErrorsModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-lg modal-dialog-scrollable" style="cursor: move;" id="validation-modal-dialog">
            <div class="modal-content">
                <div class="modal-header" id="validation-modal-header">
                    <h5 class="modal-title" id="validationErrorsModalLabel">
                        <i class="bi bi-exclamation-triangle-fill text-danger me-2"></i>XHTML Validation Errors
                    </h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    @if (ValidationResult.Issues.Any())
                    {
                        // Group issues by type for better organization
                        var schemaIssues = ValidationResult.Issues.Where(i => i.Type == ValidationIssueType.SchemaValidationError).ToList();
                        var elementIssues = ValidationResult.Issues.Where(i => i.Type != ValidationIssueType.SchemaValidationError).ToList();

                        // Group element issues by element name and first XPath occurrence
                        var groupedElementIssues = elementIssues
                            .Where(i => i.XPaths.Any())
                            .GroupBy(i => new { ElementName = i.ElementName, XPath = i.XPaths.First() })
                            .Select(g => new
                            {
                                ElementName = g.Key.ElementName,
                                XPath = g.Key.XPath,
                                Issues = g.ToList(),
                                TotalOccurrences = g.Sum(i => i.OccurrenceCount),
                                HasInvalidElement = g.Any(i => i.Type == ValidationIssueType.InvalidElement),
                                HasUppercase = g.Any(i => i.Type == ValidationIssueType.UppercaseInElementName)
                            })
                            .OrderBy(g => g.ElementName)
                            .ToList();

                        <div class="alert alert-warning mb-3" role="alert">
                            <i class="bi bi-info-circle me-2"></i>
                            Found <strong>@ValidationResult.TotalIssues</strong> validation @(ValidationResult.TotalIssues == 1 ? "issue" : "issues"):
                            @if (schemaIssues.Any())
                            {
                                <span class="ms-2"><strong>@schemaIssues.Sum(i => i.OccurrenceCount)</strong> schema validation errors</span>
                            }
                            @if (elementIssues.Any())
                            {
                                <span class="ms-2"><strong>@elementIssues.Sum(i => i.OccurrenceCount)</strong> element name issues</span>
                            }
                        </div>

                        @* Schema Validation Errors Section *@
                        @if (schemaIssues.Any())
                        {
                            <h6 class="text-danger mb-3">
                                <i class="bi bi-shield-exclamation me-2"></i>W3C XHTML 1.0 Strict Schema Validation
                            </h6>
                            <div class="list-group mb-4">
                                @foreach (var issue in schemaIssues.OrderByDescending(i => i.OccurrenceCount))
                                {
                                    <div class="list-group-item">
                                        <div class="d-flex justify-content-between align-items-start mb-2">
                                            <div class="flex-grow-1">
                                                <div class="d-flex align-items-center gap-2 mb-2">
                                                    <i class="bi bi-@(issue.Severity == System.Xml.Schema.XmlSeverityType.Error ? "x-circle text-danger" : "exclamation-triangle text-warning")"
                                                       style="font-size: 1.25rem;"
                                                       title="@issue.Severity"></i>
                                                    <div>
                                                        <code class="text-danger">@issue.ElementName</code>
                                                        <span class="badge bg-secondary ms-2">@issue.OccurrenceCount @(issue.OccurrenceCount == 1 ? "occurrence" : "occurrences")</span>
                                                    </div>
                                                </div>
                                                <div class="text-muted small mb-2">
                                                    @issue.SchemaMessage
                                                </div>
                                            </div>
                                        </div>

                                        @if (issue.LineNumbers != null && issue.LineNumbers.Any())
                                        {
                                            <div class="mt-2">
                                                <small class="text-muted d-block mb-1">
                                                    @(issue.LineNumbers.Count == 1 ? "Location:" : $"First {Math.Min(5, issue.LineNumbers.Count)} locations:")
                                                </small>
                                                @for (int i = 0; i < Math.Min(5, issue.LineNumbers.Count); i++)
                                                {
                                                    var lineNum = issue.LineNumbers[i];
                                                    var linePos = issue.LinePositions != null && i < issue.LinePositions.Count ? issue.LinePositions[i] : 0;
                                                    var locationText = $"Line {lineNum}, Column {linePos}";

                                                    <div class="d-flex align-items-center gap-2 mb-1">
                                                        <code class="small text-muted">@locationText</code>
                                                        <button class="btn btn-sm btn-outline-secondary"
                                                                @onclick="() => CopyToClipboardAsync(locationText)"
                                                                title="Copy location">
                                                            <i class="bi bi-clipboard"></i>
                                                        </button>
                                                        <button class="btn btn-sm btn-primary"
                                                                @onclick="() => NavigateToLine(lineNum)"
                                                                title="Navigate to line">
                                                            <i class="bi bi-arrow-right-circle"></i>
                                                        </button>
                                                    </div>
                                                }

                                                @if (issue.LineNumbers.Count > 5)
                                                {
                                                    <small class="text-muted">+ @(issue.LineNumbers.Count - 5) more occurrence(s)</small>
                                                }
                                            </div>
                                        }
                                    </div>
                                }
                            </div>
                        }

                        @* Element Name Issues Section *@
                        @if (groupedElementIssues.Any())
                        {
                            <h6 class="text-warning mb-3">
                                <i class="bi bi-code-slash me-2"></i>Element Name Issues
                            </h6>
                            <div class="list-group">
                            @foreach (var group in groupedElementIssues)
                            {
                                <div class="list-group-item">
                                    <div class="d-flex justify-content-between align-items-center mb-2">
                                        <div class="d-flex align-items-center gap-2">
                                            @* Show all applicable icons *@
                                            @if (group.HasInvalidElement)
                                            {
                                                <i class="bi bi-x-circle text-danger" title="Invalid element - not in HTML5 spec" style="font-size: 1.25rem;"></i>
                                            }
                                            @if (group.HasUppercase)
                                            {
                                                <i class="bi bi-type text-warning" title="Uppercase in element name - HTML requires lowercase" style="font-size: 1.25rem;"></i>
                                            }
                                            <div>
                                                <code class="@(group.HasInvalidElement ? "text-danger" : "text-warning")">&lt;@group.ElementName&gt;</code>
                                                <span class="badge bg-secondary ms-2">@group.TotalOccurrences @(group.TotalOccurrences == 1 ? "occurrence" : "occurrences")</span>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="mt-2">
                                        <small class="text-muted d-block mb-1">First occurrence XPath:</small>
                                        <div class="d-flex align-items-center gap-2">
                                            <code class="small flex-grow-1 text-muted text-break">@group.XPath</code>
                                            <button class="btn btn-sm btn-outline-secondary"
                                                    @onclick="() => CopyToClipboardAsync(group.XPath)"
                                                    title="Copy XPath">
                                                <i class="bi bi-clipboard"></i>
                                            </button>
                                            <button class="btn btn-sm btn-primary"
                                                    @onclick="() => NavigateToElement(group.XPath)"
                                                    title="Navigate to element">
                                                <i class="bi bi-arrow-right-circle"></i>
                                            </button>
                                        </div>
                                    </div>
                                </div>
                            }
                            </div>
                        }

                        @* Legend *@
                        <div class="mt-3 small text-muted">
                            <div class="d-flex align-items-center gap-3 flex-wrap">
                                @if (schemaIssues.Any())
                                {
                                    <div>
                                        <i class="bi bi-shield-exclamation text-danger me-1"></i>
                                        <span>W3C XHTML schema validation error</span>
                                    </div>
                                }
                                @if (groupedElementIssues.Any(g => g.HasInvalidElement))
                                {
                                    <div>
                                        <i class="bi bi-x-circle text-danger me-1"></i>
                                        <span>Invalid element (not in HTML5 spec)</span>
                                    </div>
                                }
                                @if (groupedElementIssues.Any(g => g.HasUppercase))
                                {
                                    <div>
                                        <i class="bi bi-type text-warning me-1"></i>
                                        <span>Uppercase in element name</span>
                                    </div>
                                }
                            </div>
                        </div>
                    }
                    else
                    {
                        <div class="alert alert-success mb-0" role="alert">
                            <i class="bi bi-check-circle me-2"></i>
                            No validation errors found! The XHTML output is valid.
                        </div>
                    }
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                </div>
            </div>
        </div>
    </div>
}

<!-- Three-Panel Layout -->
<div class="development-workspace">
    <div class="panels-container" id="panels-container">
        <!-- Left Panel: Source XML Viewer -->
        <div class="panel panel-left" id="panel-left">
            <div class="panel-header">
                <div class="panel-header-left">
                    @if (Projects != null && Projects.Any())
                    {
                        <select class="form-select form-select-sm xslt-file-select" @onchange="OnFilePathChangedFromDropdown">
                            <option value="">Select a file...</option>
                            @foreach (var project in Projects)
                            {
                                <optgroup label="@project.Name">
                                    @if (project.Files != null && project.Files.Any())
                                    {
                                        @foreach (var file in project.Files)
                                        {
                                            var fullPath = $"{project.Organization}/{project.ProjectId}/{file}";
                                            var isSelected = !string.IsNullOrEmpty(SelectedProjectId) &&
                                                           !string.IsNullOrEmpty(SelectedFileName) &&
                                                           SelectedProjectId == $"{project.Organization}/{project.ProjectId}" &&
                                                           SelectedFileName == file;
                                            <option value="@fullPath" selected="@isSelected">
                                                @file
                                            </option>
                                        }
                                    }
                                </optgroup>
                            }
                        </select>
                    }
                    else
                    {
                        <span class="text-muted small">@(SelectedFileName ?? "No file selected")</span>
                    }
                </div>
                <div class="panel-header-right">
                    <div class="panel-action-buttons">
                        <button class="btn btn-sm panel-action-btn"
                                @onclick="SaveXmlAsync"
                                disabled="@(!CanSaveXml || IsSavingXml)"
                                title="Save Source XML (Ctrl+S)"
                                data-bs-toggle="tooltip">
                            @if (IsSavingXml)
                            {
                                <span class="spinner-border spinner-border-sm"></span>
                            }
                            else
                            {
                                <i class="bi bi-floppy-fill"></i>
                            }
                        </button>
                        <button class="btn btn-sm panel-help-btn"
                                title="Source XML Help"
                                data-bs-toggle="modal"
                                data-bs-target="#xmlSteeringAttributesModal">
                            <i class="bi bi-question-circle"></i>
                        </button>
                    </div>
                </div>
            </div>
            <div class="panel-content">
                <!-- Keep Monaco viewer in DOM at all times to prevent detachment -->
                <!-- Use CSS display to show/hide based on state -->
                <div id="source-xml-viewer" style="width: 100%; height: 100%; display: @(IsLoadingXml || string.IsNullOrEmpty(XmlContent) ? "none" : "block");"></div>

                @if (IsLoadingXml)
                {
                    <LoadingSkeleton IsLoading="true" Type="SkeletonType.CodeEditor" Lines="25">
                    </LoadingSkeleton>
                }
                else if (string.IsNullOrEmpty(XmlContent))
                {
                    <div class="text-center p-5 text-muted">
                        <i class="bi bi-file-earmark-code" style="font-size: 3rem;"></i>
                        <p class="mt-3">Select a project and file to view the source XML</p>
                    </div>
                }
            </div>
        </div>

        <!-- Resize Handle 1 -->
        <div class="resize-handle" id="resize-handle-1"></div>

        <!-- Center Panel: XSLT Editor -->
        <div class="panel panel-center" id="panel-center">
            <div class="panel-header">
                <div class="panel-header-left">
                    @if (XsltFiles != null && XsltFiles.Any())
                    {
                        <select class="form-select form-select-sm xslt-file-select" @onchange="OnXsltFileChanged" value="@SelectedXsltFile">
                            @foreach (var file in XsltFiles)
                            {
                                <option value="@file">@file</option>
                            }
                        </select>
                    }
                    else
                    {
                        <span class="text-muted small">@(SelectedXsltFile ?? "transformation.xslt")</span>
                    }
                </div>
                <div class="panel-header-right">
                    <div class="panel-action-buttons">
                        <button class="btn btn-sm panel-action-btn" @onclick="TransformAsync" disabled="@(!CanTransform || IsTransforming)" title="Transform (Ctrl+Enter)" data-bs-toggle="tooltip">
                            @if (IsTransforming)
                            {
                                <span class="spinner-border spinner-border-sm"></span>
                            }
                            else
                            {
                                <i class="bi bi-play-fill"></i>
                            }
                        </button>
                        <button class="btn btn-sm panel-action-btn" @onclick="SaveXsltAsync" disabled="@(!CanSave || IsSaving)" title="Save XSLT (Ctrl+S)" data-bs-toggle="tooltip">
                            @if (IsSaving)
                            {
                                <span class="spinner-border spinner-border-sm"></span>
                            }
                            else
                            {
                                <i class="bi bi-floppy-fill"></i>
                            }
                        </button>
                        <button class="btn btn-sm panel-help-btn"
                                title="XSLT Transformation: Edit XSLT templates to transform Adobe XML to Taxxor XHTML"
                                data-bs-toggle="tooltip"
                                data-bs-placement="bottom">
                            <i class="bi bi-question-circle"></i>
                        </button>
                    </div>
                </div>
            </div>
            <div class="panel-content">
                <LoadingSkeleton IsLoading="@IsLoadingXslt" Type="SkeletonType.CodeEditor" Lines="30">
                    <div id="monaco-editor-container" style="width: 100%; height: 100%;"></div>
                </LoadingSkeleton>
            </div>
        </div>

        <!-- Resize Handle 2 -->
        <div class="resize-handle" id="resize-handle-2"></div>

        <!-- Right Panel: Preview -->
        <div class="panel panel-right" id="panel-right">
            <div class="panel-header">
                <div class="panel-header-left">
                    @if (!string.IsNullOrEmpty(OutputContent))
                    {
                        <div class="form-check form-switch">
                            <input class="form-check-input" type="checkbox" id="renderedToggle" @bind-value="ShowRendered" @bind-value:after="OnRenderedToggled">
                            <label class="form-check-label" for="renderedToggle">HTML mode</label>
                        </div>
                        @if (!ShowRendered)
                        {
                            <div class="form-check form-switch">
                                <input class="form-check-input" type="checkbox" id="formatToggle"
                                       checked="@ShowFormattedXml"
                                       @bind-value="ShowFormattedXml"
                                       @bind-value:after="OnFormatChanged">
                                <label class="form-check-label" for="formatToggle">Format</label>
                            </div>
                        }
                    }
                </div>
                <div class="panel-header-right">
                    @if (!string.IsNullOrEmpty(OutputContent))
                    {
                        @if (ShowRendered)
                        {
                            <span class="zoom-indicator">@ZoomLevel%</span>
                            <button class="btn btn-sm panel-action-btn" @onclick="ZoomIn" title="Zoom In" data-bs-toggle="tooltip" disabled="@(ZoomLevel >= 200)">
                                <i class="bi bi-zoom-in"></i>
                            </button>
                            <button class="btn btn-sm panel-action-btn" @onclick="ZoomOut" title="Zoom Out" data-bs-toggle="tooltip" disabled="@(ZoomLevel <= 50)">
                                <i class="bi bi-zoom-out"></i>
                            </button>
                        }
                        <button class="btn btn-sm panel-action-btn" @onclick="CopyToClipboard" title="Copy to clipboard" data-bs-toggle="tooltip">
                            <i class="bi bi-clipboard"></i>
                        </button>
                        <button class="btn btn-sm panel-action-btn" @onclick="DownloadOutput" title="Download output" data-bs-toggle="tooltip">
                            <i class="bi bi-download"></i>
                        </button>
                    }
                    <button class="btn btn-sm panel-help-btn"
                            title="Output Preview Help"
                            data-bs-toggle="modal"
                            data-bs-target="#outputPreviewHelpModal">
                        <i class="bi bi-question-circle"></i>
                    </button>
                </div>
            </div>
            <div class="panel-content">
                @if (IsTransforming)
                {
                    <div class="transformation-overlay">
                        <div class="transformation-indicator">
                            <div class="spinner-border text-success" role="status">
                                <span class="visually-hidden">Transforming...</span>
                            </div>
                            <p class="mt-3 fw-bold">Transforming XML...</p>
                            <p class="text-muted small">Please wait while the transformation is in progress</p>
                        </div>
                    </div>
                }
                @if (!string.IsNullOrEmpty(TransformationError))
                {
                    <div class="p-4">
                        <div class="alert alert-danger mb-0" role="alert">
                            <h5 class="alert-heading">
                                <i class="bi bi-exclamation-triangle-fill"></i> Transformation Error
                            </h5>
                            <hr />
                            <pre class="mb-0" style="white-space: pre-wrap; font-family: 'Monaco', 'Menlo', 'Consolas', monospace; font-size: 0.875rem;">@TransformationError</pre>
                        </div>
                    </div>
                }
                else if (!string.IsNullOrEmpty(OutputContent))
                {
                    <!-- Keep both views in DOM, use CSS to show/hide -->
                    <!-- This prevents Monaco editor from losing its DOM element -->
                    <div class="preview-rendered" style="font-size: @(ZoomLevel)%; display: @(ShowRendered ? "block" : "none");">
                        @((MarkupString)OutputContent)
                    </div>
                    <div id="output-xml-viewer" style="width: 100%; height: 100%; display: @(ShowRendered ? "none" : "block");"></div>
                    @if (TransformationStats != null)
                    {
                        <div class="preview-stats">
                            <div class="stats-content">
                                <div class="stats-left">
                                    <span class="badge bg-success">
                                        <i class="bi bi-clock"></i> @TransformationStats.ProcessingTimeMs ms
                                    </span>
                                    @if (TransformationStats.HeadersNormalized > 0)
                                    {
                                        <span class="badge bg-info">
                                            <i class="bi bi-type-h1"></i> @TransformationStats.HeadersNormalized headers normalized
                                        </span>
                                    }
                                    @if (TransformationStats.TablesProcessed > 0)
                                    {
                                        <span class="badge bg-primary">
                                            <i class="bi bi-table"></i> @TransformationStats.TablesProcessed tables processed
                                        </span>
                                    }
                                    @if (TransformationStats.WarningMessages.Any())
                                    {
                                        <span class="badge bg-warning text-dark">
                                            <i class="bi bi-exclamation-triangle"></i> @TransformationStats.WarningMessages.Count warnings
                                        </span>
                                    }
                                </div>
                                @if (ValidationResult != null && ValidationResult.TotalIssues > 0)
                                {
                                    <div class="stats-right">
                                        <button class="badge bg-danger text-white border-0"
                                                style="cursor: pointer;"
                                                data-bs-toggle="modal"
                                                data-bs-target="#validationErrorsModal"
                                                title="Click to view validation errors">
                                            <i class="bi bi-exclamation-triangle-fill"></i> @ValidationResult.TotalIssues validation @(ValidationResult.TotalIssues == 1 ? "error" : "errors")
                                        </button>
                                    </div>
                                }
                            </div>
                        </div>
                    }
                }
                else if (!IsTransforming)
                {
                    <div class="text-center p-5 text-muted">
                        <i class="bi bi-eye" style="font-size: 3rem;"></i>
                        <p class="mt-3">@(CanTransform ? "Click \"Transform\" to preview the output" : "Select a project and file to begin")</p>
                        @if (AutoTransform && CanTransform)
                        {
                            <p class="small">Auto-transform is enabled. Edit the XSLT to see live preview.</p>
                        }
                    </div>
                }
            </div>
        </div>
    </div>
</div>

@code {
    // LocalStorage models
    private class SavedSelection
    {
        public string? ProjectId { get; set; }
        public string? FileName { get; set; }
        public string? XsltFile { get; set; }
    }

    private class SavedSettings
    {
        public bool UseXslt3Service { get; set; }
        public bool NormalizeHeaders { get; set; }
        public bool AutoTransform { get; set; }
        public bool HasStoredSettings { get; set; }
    }

    // State
    private List<Project>? Projects;
    private List<string>? ProjectFiles;
    private string? SelectedProjectId;
    private string? SelectedFileName;
    private string? XmlContent;
    private string? XsltContent;
    private List<string>? XsltFiles;
    private string? SelectedXsltFile = "transformation.xslt";
    private string? OutputContent;
    private TransformationResult? TransformationStats;
    private string? TransformationError;
    private XhtmlValidationResult? ValidationResult;
    private string? SavedNormalizedXmlPath;

    // UI State
    private bool IsLoading = false;
    private bool IsLoadingXml = false;
    private bool IsLoadingXslt = false;
    private bool IsTransforming = false;
    private bool IsSaving = false;
    private bool IsSavingXml = false;
    private bool ShowSettings = false;
    private bool ShowRendered = false; // Default to source view
    private bool ShowFormattedXml = true;
    private bool isRestoringFromStorage = false;
    private bool isUpdatingFromExternalFile = false; // Prevents Monaco from triggering auto-transform during external updates
    private bool isUpdatingFromExternalXmlFile = false; // Prevents infinite loops when syncing XML from external file
    private bool isSavingXmlToFile = false; // True when actively saving XML to prevent reload loop

    // Settings (defaults will be overridden by localStorage if available)
    private bool UseXslt3Service = true;
    private bool NormalizeHeaders = true;
    private bool AutoTransform = false;

    // Preview Controls
    private int ZoomLevel = 100;

    // Computed Properties
    private bool CanTransform => !string.IsNullOrEmpty(SelectedProjectId)
                                && !string.IsNullOrEmpty(SelectedFileName)
                                && !string.IsNullOrEmpty(XmlContent)
                                && !string.IsNullOrEmpty(XsltContent);

    private bool CanSave => !string.IsNullOrEmpty(XsltContent);

    private bool CanSaveXml => !string.IsNullOrEmpty(XmlContent)
                             && !string.IsNullOrEmpty(SelectedProjectId)
                             && !string.IsNullOrEmpty(SelectedFileName);

    private async Task OnRenderedToggled()
    {
        // ShowRendered is already updated by @bind-value
        Logger.LogInformation("Rendered toggle changed: ShowRendered = {ShowRendered}", ShowRendered);

        // If Source view is now active (Rendered OFF), ensure Monaco viewer is initialized
        // Note: The viewer container stays in DOM (just hidden/shown with CSS), so we only
        // need to initialize once. No need to dispose/recreate on every toggle.
        if (!ShowRendered && !string.IsNullOrEmpty(OutputContent) && !_outputXmlViewerInitialized)
        {
            // Give Blazor time to render and make the container visible
            await Task.Delay(100);

            try
            {
                var outputTheme = ThemeService.GetMonacoTheme();
                await JSRuntime.InvokeVoidAsync("MonacoViewerInterop.createViewer",
                    "output-xml-viewer",
                    "outputXml",
                    new {
                        value = OutputContent ?? "",
                        language = "xml",
                        theme = outputTheme
                    });
                _outputXmlViewerInitialized = true;
                Logger.LogInformation("Output XML viewer initialized when toggling to source view");
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Error initializing Output XML viewer when toggling to source view");
                ToastNotification.ShowError("Failed to initialize viewer. Please try again.");
            }
        }

        StateHasChanged();
    }

    private async Task OnFormatChanged()
    {
        // ShowFormattedXml is already updated by @bind-value
        Logger.LogInformation("Format checkbox changed: ShowFormattedXml = {ShowFormatted}", ShowFormattedXml);

        // Monaco viewer handles formatting automatically
        // This method is kept for backwards compatibility but no longer needs to do anything
        StateHasChanged();
    }

    protected override async Task OnInitializedAsync()
    {
        // Wire up toolbar state
        ToolbarState.OnTransform = TransformAsync;
        ToolbarState.OnSave = SaveXsltAsync;
        ToolbarState.OnToggleSettings = ToggleSettings;
        // Note: OnToggleTransformationLog is handled in MainLayout

        // Register file watcher callbacks (replaces any existing callback to prevent double subscription)
        XsltFileWatcher.SetFileChangedCallback(OnXsltFileChangedExternally);
        XmlFileWatcher.SetFileChangedCallback(OnXmlFileChangedExternally);

        await LoadProjectsAsync();
        await LoadXsltAsync();

        UpdateToolbarState();
    }

    private void UpdateToolbarState()
    {
        ToolbarState.Projects = Projects;
        ToolbarState.IsLoading = IsLoading;
        ToolbarState.IsTransforming = IsTransforming;
        ToolbarState.IsSaving = IsSaving || IsSavingXml;
        ToolbarState.CanTransform = CanTransform;
        ToolbarState.CanSave = CanSave;
        ToolbarState.ShowSettings = ShowSettings;
        ToolbarState.NotifyStateChanged();
    }

    private async Task LoadProjectsAsync()
    {
        try
        {
            IsLoading = true;
            UpdateToolbarState();
            Projects = (await ProjectService.GetProjectsAsync()).ToList();

            // Load files for each project
            foreach (var project in Projects)
            {
                var fullProjectId = $"{project.Organization}/{project.ProjectId}";
                project.Files = (await ProjectService.GetProjectFilesAsync(fullProjectId)).ToList();
            }

            Logger.LogInformation("Loaded {Count} projects with files", Projects.Count);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading projects");
            ToastNotification.ShowError($"Failed to load projects: {ex.Message}");
        }
        finally
        {
            IsLoading = false;
            UpdateToolbarState();
        }
    }

    private async Task LoadXsltAsync()
    {
        try
        {
            IsLoadingXslt = true;

            // Load list of available XSLT files
            XsltFiles = FileService.GetXsltFiles().ToList();
            Logger.LogInformation("Loaded {Count} XSLT files", XsltFiles.Count);

            // Ensure selected file exists, default to transformation.xslt if not
            if (string.IsNullOrEmpty(SelectedXsltFile) || !XsltFiles.Contains(SelectedXsltFile))
            {
                SelectedXsltFile = XsltFiles.Contains("transformation.xslt")
                    ? "transformation.xslt"
                    : XsltFiles.FirstOrDefault();
            }

            if (!string.IsNullOrEmpty(SelectedXsltFile))
            {
                var xsltPath = $"/app/xslt/{SelectedXsltFile}";
                if (File.Exists(xsltPath))
                {
                    XsltContent = await File.ReadAllTextAsync(xsltPath);
                    Logger.LogInformation("Loaded XSLT file from {Path}", xsltPath);

                    // Update Monaco editor content if already initialized
                    if (monacoInitialized)
                    {
                        await JSRuntime.InvokeVoidAsync("MonacoEditorInterop.setValue", XsltContent);
                    }

                    // Start watching for file changes
                    try
                    {
                        XsltFileWatcher.StartWatching(xsltPath);
                        Logger.LogInformation("Started watching XSLT file for external changes");
                    }
                    catch (Exception watchEx)
                    {
                        Logger.LogError(watchEx, "Failed to start XSLT file watcher");
                        // Non-critical, continue without watcher
                    }
                }
                else
                {
                    Logger.LogWarning("XSLT file not found at {Path}", xsltPath);
                    ToastNotification.ShowWarning($"XSLT file not found: {SelectedXsltFile}");
                }
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading XSLT");
            ToastNotification.ShowError($"Failed to load XSLT: {ex.Message}");
        }
        finally
        {
            IsLoadingXslt = false;
        }
    }

    private async Task OnFilePathChangedFromDropdown(ChangeEventArgs e)
    {
        var filePath = e.Value?.ToString();
        if (!string.IsNullOrEmpty(filePath))
        {
            await OnFilePathChanged(filePath);
        }
    }

    private async Task OnFilePathChanged(string filePath)
    {
        try
        {
            // Parse: "org/project/file.xml" -> org, project, file
            var parts = filePath.Split('/', 3);
            if (parts.Length != 3) return;

            var organization = parts[0];
            var projectId = parts[1];
            var fileName = parts[2];

            SelectedProjectId = $"{organization}/{projectId}";
            SelectedFileName = fileName;
            XmlContent = null;
            OutputContent = null;

            IsLoadingXml = true;
            UpdateToolbarState();
            StateHasChanged();

            var xmlFilePath = Path.Combine("/app/data/input", organization, "projects", projectId, fileName);
            XmlContent = await ProjectService.ReadInputFileAsync(SelectedProjectId, fileName);
            Logger.LogInformation("Loaded file {FileName} from project {ProjectId}", fileName, SelectedProjectId);

            // Start watching the XML file
            try
            {
                XmlFileWatcher.StartWatching(xmlFilePath);
                Logger.LogInformation("Started watching XML file: {Path}", xmlFilePath);
            }
            catch (Exception watchEx)
            {
                Logger.LogError(watchEx, "Failed to start XML file watcher");
            }

            // Auto-transform if enabled
            if (AutoTransform && CanTransform)
            {
                await TransformAsync();
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading file from path {Path}", filePath);
            ToastNotification.ShowError($"Failed to load file: {ex.Message}");
        }
        finally
        {
            IsLoadingXml = false;
            UpdateToolbarState();
            StateHasChanged();

            // Initialize or update Monaco editor
            if (!string.IsNullOrEmpty(XmlContent))
            {
                Logger.LogInformation("OnFilePathChanged: Scheduling Source XML editor initialization/update (XmlContent length: {Length}, Editor initialized: {Initialized}, dotNetRef null: {DotNetRefNull})",
                    XmlContent?.Length ?? 0, _sourceXmlEditorInitialized, dotNetRef == null);

                _ = InvokeAsync(async () =>
                {
                    await Task.Delay(200);
                    try
                    {
                        Logger.LogInformation("OnFilePathChanged: Attempting to initialize/update Source XML editor (Editor initialized: {Initialized})", _sourceXmlEditorInitialized);

                        if (_sourceXmlEditorInitialized)
                        {
                            await JSRuntime.InvokeVoidAsync("MonacoXmlEditorInterop.setValue", XmlContent ?? "");
                            Logger.LogInformation("OnFilePathChanged: Source XML editor content updated via setValue");
                        }
                        else
                        {
                            // Validate dotNetRef before initializing
                            if (dotNetRef == null)
                            {
                                Logger.LogError("OnFilePathChanged: Cannot initialize Source XML editor - dotNetRef is null");
                                ToastNotification.ShowError("Failed to initialize XML editor (dotNetRef null). Please refresh the page.");
                                return;
                            }

                            var sourceXmlTheme = ThemeService.GetMonacoTheme();
                            Logger.LogInformation("OnFilePathChanged: Initializing Source XML editor (theme: {Theme})", sourceXmlTheme);

                            await JSRuntime.InvokeVoidAsync("MonacoXmlEditorInterop.initialize",
                                "source-xml-viewer",
                                XmlContent ?? "",
                                dotNetRef,
                                sourceXmlTheme);
                            _sourceXmlEditorInitialized = true;
                            Logger.LogInformation("OnFilePathChanged: Source XML editor initialized successfully");
                        }
                    }
                    catch (Exception ex)
                    {
                        Logger.LogError(ex, "OnFilePathChanged: Error initializing/updating Source XML editor");
                        ToastNotification.ShowError($"Failed to initialize XML editor: {ex.Message}");
                    }
                });
            }
            else
            {
                Logger.LogWarning("OnFilePathChanged: XmlContent is empty, skipping Source XML editor initialization");
            }

            // Save selection to localStorage
            if (!isRestoringFromStorage)
            {
                await JSRuntime.InvokeVoidAsync("developmentStorage.saveSelection", SelectedProjectId, SelectedFileName, SelectedXsltFile);

                // Save to server-side UserSelectionService
                // Extract project ID from "optiver/ar24-3" format
                var projectIdOnly = SelectedProjectId?.Split('/').LastOrDefault();
                await UserSelectionService.UpdateSelectionAsync(
                    projectId: projectIdOnly,
                    sourceXml: SelectedFileName,
                    xslt: SelectedXsltFile
                );
            }
        }
    }

    private async Task OnProjectChanged(ChangeEventArgs e)
    {
        try
        {
            SelectedProjectId = e.Value?.ToString();
            SelectedFileName = null;
            XmlContent = null;
            OutputContent = null;
            ProjectFiles = null;

            if (!string.IsNullOrEmpty(SelectedProjectId))
            {
                IsLoading = true;
                UpdateToolbarState();
                StateHasChanged();
                ProjectFiles = (await ProjectService.GetProjectFilesAsync(SelectedProjectId)).ToList();
                Logger.LogInformation("Loaded {Count} files for project {ProjectId}", ProjectFiles.Count, SelectedProjectId);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading project files");
            ToastNotification.ShowError($"Failed to load project files: {ex.Message}");
        }
        finally
        {
            IsLoading = false;
            UpdateToolbarState();
            StateHasChanged();

            // Save selection to localStorage (unless we're restoring)
            if (!isRestoringFromStorage)
            {
                await JSRuntime.InvokeVoidAsync("developmentStorage.saveSelection", SelectedProjectId, SelectedFileName, SelectedXsltFile);

                // Save to server-side UserSelectionService
                // Extract project ID from "optiver/ar24-3" format
                var projectIdOnly = SelectedProjectId?.Split('/').LastOrDefault();
                await UserSelectionService.UpdateSelectionAsync(
                    projectId: projectIdOnly,
                    sourceXml: SelectedFileName,
                    xslt: SelectedXsltFile
                );
            }
        }
    }

    private async Task OnFileChanged(ChangeEventArgs e)
    {
        try
        {
            SelectedFileName = e.Value?.ToString();
            XmlContent = null;
            OutputContent = null;
            UpdateToolbarState();
            StateHasChanged();

            if (!string.IsNullOrEmpty(SelectedProjectId) && !string.IsNullOrEmpty(SelectedFileName))
            {
                IsLoadingXml = true;
                StateHasChanged();

                var xmlFilePath = Path.Combine("/app/data/input/optiver/projects", SelectedProjectId, SelectedFileName);
                XmlContent = await ProjectService.ReadInputFileAsync(SelectedProjectId, SelectedFileName);
                Logger.LogInformation("Loaded file {FileName} from project {ProjectId}", SelectedFileName, SelectedProjectId);

                // Start watching the XML file for external changes
                try
                {
                    XmlFileWatcher.StartWatching(xmlFilePath);
                    Logger.LogInformation("Started watching XML file for external changes: {Path}", xmlFilePath);
                }
                catch (Exception watchEx)
                {
                    Logger.LogError(watchEx, "Failed to start XML file watcher");
                    // Non-critical, continue without watcher
                }

                // Auto-transform if enabled
                if (AutoTransform && CanTransform)
                {
                    await TransformAsync();
                }
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading XML file");
            ToastNotification.ShowError($"Failed to load XML file: {ex.Message}");
        }
        finally
        {
            IsLoadingXml = false;
            UpdateToolbarState();
            StateHasChanged();

            // Initialize or update Monaco editor
            if (!string.IsNullOrEmpty(XmlContent))
            {
                Logger.LogInformation("OnFileChanged: Scheduling Source XML editor initialization/update (XmlContent length: {Length}, Editor initialized: {Initialized}, dotNetRef null: {DotNetRefNull})",
                    XmlContent?.Length ?? 0, _sourceXmlEditorInitialized, dotNetRef == null);

                _ = InvokeAsync(async () =>
                {
                    await Task.Delay(200); // Give Blazor time to render the container
                    try
                    {
                        Logger.LogInformation("OnFileChanged: Attempting to initialize/update Source XML editor (Editor initialized: {Initialized})", _sourceXmlEditorInitialized);

                        if (_sourceXmlEditorInitialized)
                        {
                            // Update existing editor
                            await JSRuntime.InvokeVoidAsync("MonacoXmlEditorInterop.setValue",
                                XmlContent ?? "");
                            Logger.LogInformation("OnFileChanged: Source XML editor content updated via setValue");
                        }
                        else
                        {
                            // Validate dotNetRef before initializing
                            if (dotNetRef == null)
                            {
                                Logger.LogError("OnFileChanged: Cannot initialize Source XML editor - dotNetRef is null");
                                ToastNotification.ShowError("Failed to initialize XML editor (dotNetRef null). Please refresh the page.");
                                return;
                            }

                            // Initialize editor for the first time
                            var sourceXmlTheme = ThemeService.GetMonacoTheme();
                            Logger.LogInformation("OnFileChanged: Initializing Source XML editor (theme: {Theme})", sourceXmlTheme);

                            await JSRuntime.InvokeVoidAsync("MonacoXmlEditorInterop.initialize",
                                "source-xml-viewer",
                                XmlContent ?? "",
                                dotNetRef,
                                sourceXmlTheme);
                            _sourceXmlEditorInitialized = true;
                            Logger.LogInformation("OnFileChanged: Source XML editor initialized successfully after file load");
                        }
                    }
                    catch (Exception ex)
                    {
                        Logger.LogError(ex, "OnFileChanged: Error initializing/updating Source XML editor");
                        ToastNotification.ShowError($"Failed to initialize XML editor: {ex.Message}");
                    }
                });
            }
            else
            {
                Logger.LogWarning("OnFileChanged: XmlContent is empty, skipping Source XML editor initialization");
            }

            // Save selection to localStorage (unless we're restoring)
            if (!isRestoringFromStorage)
            {
                await JSRuntime.InvokeVoidAsync("developmentStorage.saveSelection", SelectedProjectId, SelectedFileName, SelectedXsltFile);

                // Save to server-side UserSelectionService
                // Extract project ID from "optiver/ar24-3" format
                var projectIdOnly = SelectedProjectId?.Split('/').LastOrDefault();
                await UserSelectionService.UpdateSelectionAsync(
                    projectId: projectIdOnly,
                    sourceXml: SelectedFileName,
                    xslt: SelectedXsltFile
                );
            }
        }
    }

    private async Task OnXsltFileChanged(ChangeEventArgs e)
    {
        try
        {
            SelectedXsltFile = e.Value?.ToString();
            if (string.IsNullOrEmpty(SelectedXsltFile)) return;

            Logger.LogInformation("XSLT file selection changed to {File}", SelectedXsltFile);

            IsLoadingXslt = true;
            StateHasChanged();

            var xsltPath = $"/app/xslt/{SelectedXsltFile}";
            if (File.Exists(xsltPath))
            {
                // Set flag to prevent auto-transform during file load
                isUpdatingFromExternalFile = true;

                XsltContent = await File.ReadAllTextAsync(xsltPath);
                Logger.LogInformation("Loaded XSLT file from {Path}", xsltPath);

                // Update file watcher to watch the new file
                try
                {
                    XsltFileWatcher.StartWatching(xsltPath);
                    Logger.LogInformation("Started watching XSLT file for external changes");
                }
                catch (Exception watchEx)
                {
                    Logger.LogError(watchEx, "Failed to start XSLT file watcher");
                }

                // Save selection to localStorage
                await JSRuntime.InvokeVoidAsync("developmentStorage.saveSelection", SelectedProjectId, SelectedFileName, SelectedXsltFile);

                // Save to server-side UserSelectionService
                // Extract project ID from "optiver/ar24-3" format
                var projectIdOnly = SelectedProjectId?.Split('/').LastOrDefault();
                await UserSelectionService.UpdateSelectionAsync(
                    projectId: projectIdOnly,
                    sourceXml: SelectedFileName,
                    xslt: SelectedXsltFile
                );
            }
            else
            {
                Logger.LogWarning("XSLT file not found at {Path}", xsltPath);
                ToastNotification.ShowWarning($"XSLT file not found: {SelectedXsltFile}");
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading XSLT file");
            ToastNotification.ShowError($"Failed to load XSLT file: {ex.Message}");
        }
        finally
        {
            isUpdatingFromExternalFile = false;
            IsLoadingXslt = false;
            StateHasChanged();

            // Re-initialize Monaco editor after skeleton disappears
            // The LoadingSkeleton component may have destroyed the Monaco DOM
            if (monacoInitialized && !string.IsNullOrEmpty(XsltContent))
            {
                _ = InvokeAsync(async () =>
                {
                    await Task.Delay(200); // Give Blazor time to render the container

                    try
                    {
                        // Check if Monaco editor needs re-initialization
                        var needsReinit = await JSRuntime.InvokeAsync<bool>("eval",
                            "document.querySelector('#monaco-editor-container').innerHTML === ''");

                        if (needsReinit)
                        {
                            Logger.LogWarning("Monaco editor container is empty, re-initializing");
                            monacoInitialized = false;

                            var theme = ThemeService.GetMonacoTheme();
                            await JSRuntime.InvokeVoidAsync("MonacoEditorInterop.initialize",
                                "monaco-editor-container",
                                XsltContent,
                                dotNetRef,
                                theme);
                            monacoInitialized = true;
                            Logger.LogInformation("Monaco editor re-initialized after file change");
                        }
                        else
                        {
                            // Monaco editor exists, just update content
                            await JSRuntime.InvokeVoidAsync("MonacoEditorInterop.setValue", XsltContent);
                            await Task.Delay(50);
                            await JSRuntime.InvokeVoidAsync("MonacoEditorInterop.resize");
                            Logger.LogInformation("Updated Monaco editor with new XSLT file content");
                        }
                    }
                    catch (Exception ex)
                    {
                        Logger.LogError(ex, "Error updating/re-initializing Monaco editor");
                        ToastNotification.ShowError("Failed to update editor. Please refresh the page.");
                    }
                });
            }
        }
    }

    private async Task OnXsltChanged()
    {
        // Don't trigger auto-transform if we're updating from external file
        // (external file handler will trigger transform itself)
        if (isUpdatingFromExternalFile)
        {
            Logger.LogDebug("OnXsltChanged: Skipping auto-transform (updating from external file)");
            return;
        }

        // Auto-transform if enabled
        if (AutoTransform && CanTransform && !IsTransforming)
        {
            Logger.LogInformation("OnXsltChanged: Auto-transform triggered by editor change");
            await TransformAsync();
        }
    }

    private async void OnXsltFileChangedExternally(object? sender, XsltFileChangedEventArgs e)
    {
        // This is called from file watcher thread, marshal to UI thread
        await InvokeAsync(async () =>
        {
            try
            {
                Logger.LogInformation("XSLT file updated externally at {Path}", e.FilePath);

                // Set flag to prevent Monaco from triggering auto-transform
                isUpdatingFromExternalFile = true;

                // Update XSLT content
                XsltContent = e.Content;

                // Update Monaco editor if initialized
                if (monacoInitialized)
                {
                    await JSRuntime.InvokeVoidAsync("MonacoEditorInterop.setValue", XsltContent);
                }

                StateHasChanged();

                // Auto-transform if enabled
                if (AutoTransform && CanTransform && !IsTransforming)
                {
                    Logger.LogInformation("Auto-transform triggered by external XSLT file change");
                    await TransformAsync();
                }
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Error handling external XSLT file change");
                ToastNotification.ShowError($"Failed to reload XSLT: {ex.Message}");
            }
            finally
            {
                // Clear flag (Monaco won't fire change event due to isSettingValueProgrammatically)
                isUpdatingFromExternalFile = false;
            }
        });
    }

    private async void OnXmlFileChangedExternally(object? sender, XmlFileChangedEventArgs e)
    {
        // This is called from file watcher thread, marshal to UI thread
        await InvokeAsync(async () =>
        {
            try
            {
                // IGNORE file change if WE just saved the file
                if (isSavingXmlToFile)
                {
                    Logger.LogInformation("XML file changed externally, but ignoring because we initiated the save");
                    return;
                }

                Logger.LogInformation("XML file updated externally at {Path}", e.FilePath);

                // Set flag to prevent Monaco from triggering auto-transform
                isUpdatingFromExternalXmlFile = true;

                // Update XML content
                XmlContent = e.Content;

                // Update Monaco editor if initialized
                if (_sourceXmlEditorInitialized)
                {
                    await JSRuntime.InvokeVoidAsync("MonacoXmlEditorInterop.setValue", XmlContent);
                    Logger.LogInformation("Updated Source XML editor with external file changes");
                }

                StateHasChanged();

                // Show notification to user
                ToastNotification.ShowInfo("Source XML reloaded from disk");

                // Auto-transform if enabled
                if (AutoTransform && CanTransform && !IsTransforming)
                {
                    Logger.LogInformation("Auto-transform triggered by external XML file change");
                    await TransformAsync();
                }
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Error handling external XML file change");
                ToastNotification.ShowError($"Failed to reload XML: {ex.Message}");
            }
            finally
            {
                // Clear flag
                isUpdatingFromExternalXmlFile = false;
            }
        });
    }

    private async Task TransformAsync()
    {
        if (!CanTransform) return;

        try
        {
            IsTransforming = true;
            TransformationError = null; // Clear any previous error
            ValidationResult = null; // Clear previous validation results
            SavedNormalizedXmlPath = null; // Clear saved path
            UpdateToolbarState();

            // ALWAYS use transformation.xslt as the main XSLT file for transformations
            var transformationXsltPath = "/app/xslt/transformation.xslt";
            string transformationXsltContent;

            if (File.Exists(transformationXsltPath))
            {
                transformationXsltContent = await File.ReadAllTextAsync(transformationXsltPath);
                Logger.LogInformation("Loaded transformation.xslt for transformation (length: {Length})", transformationXsltContent?.Length ?? 0);
            }
            else
            {
                Logger.LogError("transformation.xslt not found at {Path}", transformationXsltPath);
                TransformationError = "transformation.xslt not found. Cannot perform transformation.";
                return;
            }

            var options = new TransformationOptions
            {
                UseXslt3Service = UseXslt3Service,
                NormalizeHeaders = NormalizeHeaders
            };

            // Check if we're editing a module file (not transformation.xslt)
            var isEditingModule = !string.IsNullOrEmpty(SelectedXsltFile) &&
                                  !SelectedXsltFile.Equals("transformation.xslt", StringComparison.OrdinalIgnoreCase);

            TransformationResult result;

            if (isEditingModule && !string.IsNullOrEmpty(XsltContent))
            {
                // Use the new method that supports edited module content from Monaco
                Logger.LogInformation("Transforming with edited module file: {File}", SelectedXsltFile);
                result = await XsltService.TransformWithEditedModuleAsync(
                    XmlContent!,
                    transformationXsltContent,
                    SelectedXsltFile,
                    XsltContent,
                    options);
            }
            else
            {
                // Standard transformation (either transformation.xslt is selected, or no module editing)
                Logger.LogInformation("Standard transformation using transformation.xslt");
                result = await XsltService.TransformAsync(XmlContent!, transformationXsltContent, options);
            }

            if (result.IsSuccess)
            {
                TransformationError = null; // Clear error on success

                // Strip DOCTYPE declaration from output (user doesn't want it anywhere)
                var outputContent = result.OutputContent;
                if (!string.IsNullOrEmpty(outputContent))
                {
                    outputContent = System.Text.RegularExpressions.Regex.Replace(
                        outputContent,
                        @"<!DOCTYPE[^>]*>\s*",
                        string.Empty,
                        System.Text.RegularExpressions.RegexOptions.IgnoreCase);
                }

                OutputContent = outputContent;
                TransformationStats = result;
                Logger.LogInformation("Transformation successful in {Time}ms. OutputContent length: {Length}", result.ProcessingTimeMs, OutputContent?.Length ?? 0);

                // Save normalized XML to debug folder
                if (!string.IsNullOrEmpty(SelectedProjectId) && !string.IsNullOrEmpty(OutputContent))
                {
                    try
                    {
                        var parts = SelectedProjectId.Split('/');
                        if (parts.Length == 2)
                        {
                            var organization = parts[0];
                            var projectId = parts[1];
                            var debugPath = Path.Combine("/app/data/output", organization, "projects", projectId, "debug");

                            // Ensure debug directory exists
                            if (!Directory.Exists(debugPath))
                            {
                                Directory.CreateDirectory(debugPath);
                            }

                            var normalizedXmlPath = Path.Combine(debugPath, "normalized.xml");
                            await File.WriteAllTextAsync(normalizedXmlPath, OutputContent);
                            SavedNormalizedXmlPath = normalizedXmlPath;
                            Logger.LogInformation("Saved normalized XML to {Path}", normalizedXmlPath);
                        }
                    }
                    catch (Exception ex)
                    {
                        Logger.LogError(ex, "Failed to save normalized XML to debug folder");
                        // Non-critical error, continue
                    }
                }

                // Run XHTML validation
                if (!string.IsNullOrEmpty(OutputContent))
                {
                    try
                    {
                        ValidationResult = await ValidationService.ValidateXhtmlAsync(OutputContent);
                        Logger.LogInformation("XHTML validation completed: {TotalIssues} issues found",
                            ValidationResult.TotalIssues);
                    }
                    catch (Exception ex)
                    {
                        Logger.LogError(ex, "Failed to run XHTML validation");
                        ValidationResult = null; // Clear on error
                    }
                }

                // Trigger visual success feedback (green glow on Transform button)
                await TriggerTransformSuccessEffect();

                if (result.WarningMessages.Any())
                {
                    foreach (var warning in result.WarningMessages)
                    {
                        ToastNotification.ShowWarning(warning);
                    }
                }

                // Update or initialize Output XML viewer (only if Source view is active)
                if (!ShowRendered)
                {
                    _ = InvokeAsync(async () =>
                    {
                        await Task.Delay(100); // Give Blazor time to render the container
                        try
                        {
                            if (!_outputXmlViewerInitialized)
                            {
                                var outputTheme = ThemeService.GetMonacoTheme();
                                await JSRuntime.InvokeVoidAsync("MonacoViewerInterop.createViewer",
                                    "output-xml-viewer",
                                    "outputXml",
                                    new {
                                        value = OutputContent ?? "",
                                        language = "xml",
                                        theme = outputTheme
                                    });
                                _outputXmlViewerInitialized = true;
                                Logger.LogInformation("Output XML viewer initialized after transformation");
                            }
                            else
                            {
                                await JSRuntime.InvokeVoidAsync("MonacoViewerInterop.setValue",
                                    "outputXml",
                                    OutputContent ?? "");
                                Logger.LogInformation("Updated Output XML viewer content");
                            }
                        }
                        catch (Exception ex)
                        {
                            Logger.LogError(ex, "Error initializing/updating Output XML viewer");
                        }
                    });
                }
            }
            else
            {
                Logger.LogError("Transformation failed: {Error}", result.ErrorMessage);
                TransformationError = result.ErrorMessage;
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error during transformation");
            TransformationError = $"Transformation error: {ex.Message}";
        }
        finally
        {
            IsTransforming = false;
            UpdateToolbarState();
            StateHasChanged();
        }
    }

    private async Task SaveXsltAsync()
    {
        if (!CanSave || string.IsNullOrEmpty(SelectedXsltFile)) return;

        try
        {
            IsSaving = true;
            UpdateToolbarState();

            var xsltPath = $"/app/xslt/{SelectedXsltFile}";
            await File.WriteAllTextAsync(xsltPath, XsltContent!);

            ToastNotification.ShowSuccess($"XSLT file saved successfully: {SelectedXsltFile}");
            Logger.LogInformation("XSLT file saved to {Path}", xsltPath);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error saving XSLT file {File}", SelectedXsltFile);
            ToastNotification.ShowError($"Failed to save XSLT: {ex.Message}");
        }
        finally
        {
            IsSaving = false;
            UpdateToolbarState();
            StateHasChanged();
        }
    }

    private async Task SaveXmlAsync()
    {
        if (!CanSaveXml) return;

        try
        {
            IsSavingXml = true;
            isSavingXmlToFile = true;  // SET FLAG BEFORE SAVE
            UpdateToolbarState();
            StateHasChanged();

            Logger.LogInformation("SaveXmlAsync: Setting isSavingXmlToFile flag to TRUE");

            // Parse project path: "org/project"
            var parts = SelectedProjectId!.Split('/');
            if (parts.Length != 2)
            {
                Logger.LogError("Invalid project ID format: {ProjectId}", SelectedProjectId);
                ToastNotification.ShowError("Invalid project ID format");
                return;
            }

            var organization = parts[0];
            var projectId = parts[1];
            var xmlFilePath = Path.Combine("/app/data/input", organization, "projects", projectId, SelectedFileName!);

            await File.WriteAllTextAsync(xmlFilePath, XmlContent!);

            ToastNotification.ShowSuccess($"Source XML saved: {SelectedFileName}");
            Logger.LogInformation("Source XML saved to {Path}, waiting 2 seconds for file watcher...", xmlFilePath);

            // Wait longer to ensure file watcher processes the change with flag set
            // File watcher on macOS can have variable delays
            await Task.Delay(2000);

            Logger.LogInformation("SaveXmlAsync: Clearing isSavingXmlToFile flag to FALSE");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error saving Source XML file {File}", SelectedFileName);
            ToastNotification.ShowError($"Failed to save XML: {ex.Message}");
        }
        finally
        {
            isSavingXmlToFile = false;  // CLEAR FLAG AFTER SAVE
            IsSavingXml = false;
            UpdateToolbarState();
            StateHasChanged();
        }
    }

    private void ToggleSettings()
    {
        ShowSettings = !ShowSettings;
        UpdateToolbarState();
        StateHasChanged();
    }

    private void OnSettingsChanged()
    {
        // Save settings to localStorage asynchronously (fire-and-forget)
        _ = SaveSettingsAsync();
    }

    private async Task SaveSettingsAsync()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("developmentStorage.saveSettings", UseXslt3Service, NormalizeHeaders, AutoTransform);
            Logger.LogInformation("Settings saved: UseXslt3Service={UseXslt3}, NormalizeHeaders={Normalize}, AutoTransform={Auto}",
                UseXslt3Service, NormalizeHeaders, AutoTransform);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to save settings to localStorage");
        }
    }

    private async Task OnFilesUploaded()
    {
        // Refresh file list
        if (!string.IsNullOrEmpty(SelectedProjectId))
        {
            try
            {
                ProjectFiles = (await ProjectService.GetProjectFilesAsync(SelectedProjectId)).ToList();
                UpdateToolbarState();
                StateHasChanged();
                Logger.LogInformation("File list refreshed after upload");
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Error refreshing file list after upload");
                ToastNotification.ShowError($"Failed to refresh file list: {ex.Message}");
            }
        }
    }

    // Zoom controls
    private void ZoomIn()
    {
        if (ZoomLevel < 200)
        {
            ZoomLevel += 10;
            StateHasChanged();
        }
    }

    private void ZoomOut()
    {
        if (ZoomLevel > 50)
        {
            ZoomLevel -= 10;
            StateHasChanged();
        }
    }

    private void ResetZoom()
    {
        ZoomLevel = 100;
        StateHasChanged();
    }

    // Copy to clipboard
    private async Task CopyToClipboard()
    {
        try
        {
            if (!string.IsNullOrEmpty(OutputContent))
            {
                await JSRuntime.InvokeVoidAsync("navigator.clipboard.writeText", OutputContent);
                ToastNotification.ShowSuccess("Output copied to clipboard");
                Logger.LogInformation("Output copied to clipboard");
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error copying to clipboard");
            ToastNotification.ShowError($"Failed to copy to clipboard: {ex.Message}");
        }
    }

    // Copy file path to clipboard
    private async Task CopyPathToClipboard(string path)
    {
        try
        {
            if (!string.IsNullOrEmpty(path))
            {
                await JSRuntime.InvokeVoidAsync("navigator.clipboard.writeText", path);
                ToastNotification.ShowSuccess("Path copied to clipboard");
                Logger.LogInformation("File path copied to clipboard: {Path}", path);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error copying path to clipboard");
            ToastNotification.ShowError($"Failed to copy path: {ex.Message}");
        }
    }

    // Copy XPath to clipboard
    private async Task CopyToClipboardAsync(string text)
    {
        try
        {
            if (!string.IsNullOrEmpty(text))
            {
                await JSRuntime.InvokeVoidAsync("navigator.clipboard.writeText", text);
                ToastNotification.ShowSuccess("XPath copied to clipboard");
                Logger.LogInformation("XPath copied to clipboard");
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error copying XPath to clipboard");
            ToastNotification.ShowError($"Failed to copy XPath: {ex.Message}");
        }
    }

    // Navigate to element by XPath
    private async Task NavigateToElement(string xpath)
    {
        try
        {
            Logger.LogInformation("Navigating to element at XPath: {XPath}", xpath);

            // Close the validation modal using Bootstrap 5 API (no jQuery needed)
            await JSRuntime.InvokeVoidAsync("eval", @"
                const modal = document.getElementById('validationErrorsModal');
                if (modal && bootstrap && bootstrap.Modal) {
                    const modalInstance = bootstrap.Modal.getInstance(modal);
                    if (modalInstance) {
                        modalInstance.hide();
                    }
                }
            ");

            // Switch to XML source view if in HTML mode
            if (ShowRendered)
            {
                ShowRendered = false;
                StateHasChanged();
                await Task.Delay(200); // Give Blazor time to update the UI
            }

            // Ensure Output XML viewer is visible
            if (!_outputXmlViewerInitialized || string.IsNullOrEmpty(OutputContent))
            {
                Logger.LogWarning("Output XML viewer not initialized or no content available");
                ToastNotification.ShowWarning("XML viewer not ready. Please try again.");
                return;
            }

            // Find the element in the XML and get its line number
            var lineNumber = FindElementLineNumber(xpath);

            if (lineNumber > 0)
            {
                // Navigate to the line in Monaco editor
                await JSRuntime.InvokeVoidAsync("MonacoViewerInterop.navigateToLine", "outputXml", lineNumber);
                Logger.LogInformation("Navigated to line {LineNumber} for XPath {XPath}", lineNumber, xpath);
            }
            else
            {
                ToastNotification.ShowWarning($"Could not locate element in XML. XPath: {xpath}");
                Logger.LogWarning("Could not find line number for XPath: {XPath}", xpath);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error navigating to element");
            ToastNotification.ShowError($"Failed to navigate to element: {ex.Message}");
        }
    }

    // Navigate to a specific line number in the output XML viewer
    private async Task NavigateToLine(int lineNumber)
    {
        try
        {
            Logger.LogInformation("Navigating to line: {LineNumber}", lineNumber);

            // Close the validation modal using Bootstrap 5 API
            await JSRuntime.InvokeVoidAsync("eval", @"
                const modal = document.getElementById('validationErrorsModal');
                if (modal && bootstrap && bootstrap.Modal) {
                    const modalInstance = bootstrap.Modal.getInstance(modal);
                    if (modalInstance) {
                        modalInstance.hide();
                    }
                }
            ");

            // Switch to XML source view if in HTML mode
            if (ShowRendered)
            {
                ShowRendered = false;
                StateHasChanged();
                await Task.Delay(200); // Give Blazor time to update the UI
            }

            // Ensure Output XML viewer is visible and initialized
            if (!_outputXmlViewerInitialized || string.IsNullOrEmpty(OutputContent))
            {
                Logger.LogWarning("Output XML viewer not initialized or no content available");
                ToastNotification.ShowWarning("XML viewer not ready. Please try again.");
                return;
            }

            // Navigate to the line in Monaco editor
            await JSRuntime.InvokeVoidAsync("MonacoViewerInterop.navigateToLine", "outputXml", lineNumber);
            Logger.LogInformation("Navigated to line {LineNumber}", lineNumber);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error navigating to line");
            ToastNotification.ShowError($"Failed to navigate to line: {ex.Message}");
        }
    }

    private int FindElementLineNumber(string xpath)
    {
        try
        {
            if (string.IsNullOrEmpty(OutputContent))
            {
                return -1;
            }

            // Parse XPath to get element name (last segment)
            // Example: /html[1]/body[1]/div[1]/ul[7]/li[2]/L[1] -> L
            var xpathSegments = xpath.Split('/');
            var lastSegment = xpathSegments.LastOrDefault(s => !string.IsNullOrWhiteSpace(s));

            if (string.IsNullOrEmpty(lastSegment))
            {
                return -1;
            }

            // Remove index notation: L[1] -> L
            var elementName = System.Text.RegularExpressions.Regex.Replace(lastSegment, @"\[\d+\]", "");

            // Parse XML with line info
            var doc = System.Xml.Linq.XDocument.Parse(OutputContent, System.Xml.Linq.LoadOptions.SetLineInfo);
            var element = FindElementByXPath(doc.Root, xpath);

            if (element == null)
            {
                Logger.LogWarning("Element not found in XML for XPath: {XPath}", xpath);
                return -1;
            }

            // Get line number from IXmlLineInfo
            if (element is System.Xml.IXmlLineInfo lineInfo && lineInfo.HasLineInfo())
            {
                return lineInfo.LineNumber;
            }

            // Fallback: search for element in text
            var lines = OutputContent.Split('\n');
            var searchPattern = $"<{elementName}";

            for (int i = 0; i < lines.Length; i++)
            {
                if (lines[i].Contains(searchPattern))
                {
                    return i + 1; // Line numbers are 1-based
                }
            }

            Logger.LogWarning("Line number not found for element {ElementName}", elementName);
            return -1;
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error finding line number for XPath: {XPath}", xpath);
            return -1;
        }
    }

    private System.Xml.Linq.XElement? FindElementByXPath(System.Xml.Linq.XElement? root, string xpath)
    {
        if (root == null || string.IsNullOrEmpty(xpath))
        {
            return null;
        }

        try
        {
            // Simple XPath traversal for indexed paths like /html[1]/body[1]/div[1]/ul[7]/li[2]/L[1]
            var segments = xpath.Split('/')
                .Where(s => !string.IsNullOrWhiteSpace(s))
                .ToList();

            var current = root;

            foreach (var segment in segments.Skip(1)) // Skip first empty segment from leading /
            {
                // Parse segment: elementName[index]
                var match = System.Text.RegularExpressions.Regex.Match(segment, @"^([^\[]+)(?:\[(\d+)\])?$");
                if (!match.Success)
                {
                    return null;
                }

                var elementName = match.Groups[1].Value;
                var index = match.Groups[2].Success ? int.Parse(match.Groups[2].Value) : 1;

                // Find child elements with matching name
                var children = current.Elements()
                    .Where(e => e.Name.LocalName.Equals(elementName, StringComparison.OrdinalIgnoreCase))
                    .ToList();

                if (children.Count < index)
                {
                    return null;
                }

                current = children[index - 1]; // XPath uses 1-based indexing
            }

            return current;
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error traversing XPath: {XPath}", xpath);
            return null;
        }
    }

    // Download output
    private async Task DownloadOutput()
    {
        try
        {
            if (!string.IsNullOrEmpty(OutputContent))
            {
                var fileName = $"{SelectedProjectId ?? "output"}_{DateTime.Now:yyyyMMdd_HHmmss}.xhtml";
                var bytes = System.Text.Encoding.UTF8.GetBytes(OutputContent);
                var base64 = System.Convert.ToBase64String(bytes);

                await JSRuntime.InvokeVoidAsync("downloadFile", fileName, "application/xhtml+xml", base64);
                ToastNotification.ShowSuccess($"Downloaded {fileName}");
                Logger.LogInformation("Downloaded output as {FileName}", fileName);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error downloading output");
            ToastNotification.ShowError($"Failed to download output: {ex.Message}");
        }
    }

    // Monaco Editor Integration
    private DotNetObjectReference<Transform>? dotNetRef;
    private bool monacoInitialized = false;
    private bool keyboardShortcutsInitialized = false;
    private bool _sourceXmlEditorInitialized = false;
    private bool _outputXmlViewerInitialized = false;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // Wait a bit to ensure JavaScript files are fully loaded
            await Task.Delay(200);

            // Load saved settings from localStorage
            try
            {
                var savedSettings = await JSRuntime.InvokeAsync<SavedSettings>("developmentStorage.loadSettings");
                if (savedSettings != null && savedSettings.HasStoredSettings)
                {
                    UseXslt3Service = savedSettings.UseXslt3Service;
                    NormalizeHeaders = savedSettings.NormalizeHeaders;
                    AutoTransform = savedSettings.AutoTransform;

                    Logger.LogInformation("Restored settings from localStorage: UseXslt3Service={UseXslt3}, NormalizeHeaders={Normalize}, AutoTransform={Auto}",
                        UseXslt3Service, NormalizeHeaders, AutoTransform);

                    StateHasChanged();
                }
                else
                {
                    Logger.LogInformation("No stored settings found, using defaults: UseXslt3Service={UseXslt3}, NormalizeHeaders={Normalize}, AutoTransform={Auto}",
                        UseXslt3Service, NormalizeHeaders, AutoTransform);
                }
            }
            catch (Exception ex)
            {
                Logger.LogWarning(ex, "Could not restore settings from localStorage, using defaults");
            }

            // Initialize keyboard shortcuts
            if (!keyboardShortcutsInitialized)
            {
                try
                {
                    dotNetRef = DotNetObjectReference.Create(this);
                    await JSRuntime.InvokeVoidAsync("KeyboardShortcuts.initialize", dotNetRef);
                    keyboardShortcutsInitialized = true;
                    Logger.LogInformation("Keyboard shortcuts initialized");
                }
                catch (Exception ex)
                {
                    Logger.LogError(ex, "Failed to initialize keyboard shortcuts");
                }
            }

            // Initialize Bootstrap tooltips for panel help buttons
            try
            {
                await JSRuntime.InvokeVoidAsync("eval", @"
                    if (typeof bootstrap !== 'undefined') {
                        var tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle=""tooltip""]'));
                        tooltipTriggerList.map(function (tooltipTriggerEl) {
                            return new bootstrap.Tooltip(tooltipTriggerEl, {
                                trigger: 'hover focus',
                                container: 'body'
                            });
                        });
                    }
                ");
                Logger.LogInformation("Bootstrap tooltips initialized for panel help buttons");
            }
            catch (Exception ex)
            {
                Logger.LogWarning(ex, "Failed to initialize Bootstrap tooltips");
            }

            // Initialize draggable validation modal
            try
            {
                await JSRuntime.InvokeVoidAsync("eval", @"
                    if (typeof $ !== 'undefined' && $.fn.draggable) {
                        $('#validation-modal-dialog').draggable({
                            handle: '#validation-modal-header',
                            cursor: 'move',
                            containment: 'window'
                        });
                    }
                ");
                Logger.LogInformation("Validation modal draggability initialized");
            }
            catch (Exception ex)
            {
                Logger.LogWarning(ex, "Failed to initialize validation modal draggability (jQuery UI may not be available)");
            }

            // Initialize Monaco Editor for XSLT
            if (!string.IsNullOrEmpty(XsltContent) && !monacoInitialized)
            {
                try
                {
                    var theme = ThemeService.GetMonacoTheme();
                    await JSRuntime.InvokeVoidAsync("MonacoEditorInterop.initialize",
                        "monaco-editor-container",
                        XsltContent,
                        dotNetRef,
                        theme);
                    monacoInitialized = true;
                    Logger.LogInformation("Monaco Editor initialized successfully");
                }
                catch (Exception ex)
                {
                    Logger.LogError(ex, "Failed to initialize Monaco Editor");
                    ToastNotification.ShowError("Failed to initialize code editor. Using fallback mode.");
                }
            }

            // Initialize Source XML editor
            if (!string.IsNullOrEmpty(XmlContent) && !_sourceXmlEditorInitialized)
            {
                try
                {
                    var sourceXmlTheme = ThemeService.GetMonacoTheme();
                    await JSRuntime.InvokeVoidAsync("MonacoXmlEditorInterop.initialize",
                        "source-xml-viewer",
                        XmlContent ?? "",
                        dotNetRef,
                        sourceXmlTheme);
                    _sourceXmlEditorInitialized = true;
                    Logger.LogInformation("Source XML editor initialized successfully");
                }
                catch (Exception ex)
                {
                    Logger.LogError(ex, "Failed to initialize Source XML editor");
                    ToastNotification.ShowError("Failed to initialize XML editor. Using fallback mode.");
                }
            }

            // Load saved selections from UserSelectionService JSON first, with localStorage as fallback

            try
            {
                // First, try to load from UserSelectionService (server-side JSON)
                var selection = await UserSelectionService.GetSelectionAsync();
                SavedSelection savedSelection = null;

                if (selection != null && !string.IsNullOrEmpty(selection.LastSelectedProject))
                {
                    Logger.LogInformation("Loading selection from UserSelectionService JSON: Project={Project}, SourceXml={SourceXml}, Xslt={Xslt}",
                        selection.LastSelectedProject, selection.LastSelectedSourceXml, selection.LastSelectedXslt);

                    // Convert from UserSelection format to SavedSelection format
                    // UserSelection uses just project name (e.g., "ar24-3")
                    // Transform page needs full path format (e.g., "optiver/ar24-3")
                    savedSelection = new SavedSelection
                    {
                        ProjectId = $"optiver/{selection.LastSelectedProject}",
                        FileName = selection.LastSelectedSourceXml ?? string.Empty,
                        XsltFile = selection.LastSelectedXslt ?? "transformation.xslt"
                    };
                }
                else
                {
                    // Fallback to localStorage if UserSelectionService has no data
                    Logger.LogInformation("No selection found in UserSelectionService JSON, falling back to localStorage");
                    savedSelection = await JSRuntime.InvokeAsync<SavedSelection>("developmentStorage.loadSelection");

                    if (savedSelection != null && !string.IsNullOrEmpty(savedSelection.ProjectId))
                    {
                        Logger.LogInformation("Loaded selection from localStorage: Project={Project}, File={File}, XsltFile={XsltFile}",
                            savedSelection.ProjectId, savedSelection.FileName, savedSelection.XsltFile);
                    }
                }

                if (savedSelection != null && !string.IsNullOrEmpty(savedSelection.ProjectId))
                {
                    Logger.LogInformation("Restoring saved selection: Project={Project}, File={File}, XsltFile={XsltFile}",
                        savedSelection.ProjectId, savedSelection.FileName, savedSelection.XsltFile);

                    // Set flag to prevent saving during restoration
                    isRestoringFromStorage = true;

                    try
                    {
                        // Restore XSLT file selection first
                        if (!string.IsNullOrEmpty(savedSelection.XsltFile))
                        {
                            SelectedXsltFile = savedSelection.XsltFile;
                            // Reload XSLT to use the restored file
                            await LoadXsltAsync();
                        }

                        // Restore file selection if available (using the new combined path approach)
                        if (!string.IsNullOrEmpty(savedSelection.ProjectId) && !string.IsNullOrEmpty(savedSelection.FileName))
                        {
                            // Wait for projects to load
                            await Task.Delay(800);
                            var filePath = $"{savedSelection.ProjectId}/{savedSelection.FileName}";
                            await OnFilePathChanged(filePath);
                        }
                    }
                    finally
                    {
                        // Clear the flag after restoration is complete
                        isRestoringFromStorage = false;
                    }
                }
                else
                {
                    Logger.LogInformation("No saved selection found in UserSelectionService JSON or localStorage");
                }
            }
            catch (Exception ex)
            {
                Logger.LogWarning(ex, "Could not restore saved selection");
                isRestoringFromStorage = false;
            }
        }
    }

    [JSInvokable]
    public async Task OnEditorContentChanged(string content)
    {
        Logger.LogDebug("OnEditorContentChanged called (isUpdatingFromExternalFile={IsUpdating})", isUpdatingFromExternalFile);
        XsltContent = content;
        await OnXsltChanged();
    }

    [JSInvokable]
    public async Task OnXmlContentChanged(string content)
    {
        Logger.LogInformation("OnXmlContentChanged called - Flag: {Flag}, AutoTransform: {Auto}, CanTransform: {Can}, IsTransforming: {Trans}",
            isUpdatingFromExternalXmlFile, AutoTransform, CanTransform, IsTransforming);

        // Don't trigger updates if we're syncing from external file
        if (isUpdatingFromExternalXmlFile)
        {
            Logger.LogDebug("OnXmlContentChanged: Skipping (updating from external file)");
            return;
        }

        Logger.LogInformation("OnXmlContentChanged: Editor content changed (length: {Length})", content?.Length ?? 0);
        XmlContent = content;

        // Auto-transform if enabled
        if (AutoTransform && CanTransform && !IsTransforming)
        {
            Logger.LogInformation("Auto-transform triggered by XML editor change");
            await TransformAsync();
        }
        else if (!AutoTransform)
        {
            Logger.LogInformation("Auto-transform is DISABLED - enable it in settings to transform automatically");
        }
        else if (!CanTransform)
        {
            Logger.LogInformation("Auto-transform skipped - CanTransform is false (missing XML, XSLT, or selection)");
        }
        else if (IsTransforming)
        {
            Logger.LogInformation("Auto-transform skipped - transformation already in progress");
        }
    }

    [JSInvokable]
    public async Task OnSaveShortcut()
    {
        await SaveXsltAsync();
    }

    [JSInvokable]
    public async Task OnSaveXmlShortcut()
    {
        await SaveXmlAsync();
    }

    [JSInvokable]
    public async Task OnTransformShortcut()
    {
        await TransformAsync();
    }

    [JSInvokable]
    public void OnShowHelp()
    {
        // This would trigger help panel in MainLayout
        // For now, just show a toast
        ToastNotification.ShowInfo("Press ? to show help panel");
    }

    private async Task TriggerTransformSuccessEffect()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("VisualFeedback.triggerTransformSuccess");
        }
        catch (Exception ex)
        {
            Logger.LogWarning(ex, "Failed to trigger transform success effect");
        }
    }

    public async ValueTask DisposeAsync()
    {
        // Clear file watcher callbacks
        XsltFileWatcher.SetFileChangedCallback(null);
        XmlFileWatcher.SetFileChangedCallback(null);

        // Dispose Source XML editor
        if (_sourceXmlEditorInitialized)
        {
            try
            {
                await JSRuntime.InvokeVoidAsync("MonacoXmlEditorInterop.dispose");
                Logger.LogInformation("Disposed Source XML editor");
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Error disposing Source XML editor");
            }
        }

        // Dispose Output XML viewer
        if (_outputXmlViewerInitialized)
        {
            try
            {
                await JSRuntime.InvokeVoidAsync("MonacoViewerInterop.dispose", "outputXml");
                Logger.LogInformation("Disposed Output XML viewer");
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Error disposing Output XML viewer");
            }
        }

        // Dispose Monaco Editor
        if (monacoInitialized)
        {
            try
            {
                await JSRuntime.InvokeVoidAsync("MonacoEditorInterop.dispose");
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Error disposing Monaco Editor");
            }
        }

        dotNetRef?.Dispose();
    }
}

