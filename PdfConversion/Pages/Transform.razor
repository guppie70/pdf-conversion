@page "/transform/{customer}/{projectId}"
@using PdfConversion.Services
@using PdfConversion.Models
@using PdfConversion.Shared
@using PdfConversion.Utils
@using Microsoft.JSInterop
@using static PdfConversion.Shared.LoadingSkeleton
@implements IAsyncDisposable
@inject IProjectManagementService ProjectService
@inject IXsltTransformationService XsltService
@inject IFileService FileService
@inject IJSRuntime JSRuntime
@inject ILogger<Transform> Logger
@inject TransformToolbarState ToolbarState
@inject ThemeService ThemeService
@inject IXsltFileWatcherService XsltFileWatcher
@inject IXmlFileWatcherService XmlFileWatcher
@inject IXhtmlValidationService ValidationService
@inject IUserSelectionService UserSelectionService
@inject ProjectMetadataService MetadataService
@inject IFileGroupBuilderService FileGroupBuilder
@inject IProjectValidationService ProjectValidation
@inject NavigationManager NavigationManager
@inject IProjectLoadingService ProjectLoader
@inject ISourceDetectionService SourceDetectionService
@inject IHtmlToXhtmlConversionService HtmlToXhtmlConversionService
@inject WorkflowStateService WorkflowState

<PageTitle>Transform</PageTitle>

<!-- Settings Panel (floating overlay when settings button clicked) -->
@if (ShowSettings)
{
    <div class="settings-overlay">
        <div class="settings-panel">
            <div class="settings-header">
                <h6 class="mb-0">Transformation Settings</h6>
                <button type="button" class="btn-close" @onclick="ToggleSettings" aria-label="Close"></button>
            </div>
            <div class="settings-body">
                <div class="form-check mb-2">
                    <input class="form-check-input" type="checkbox" id="useXslt3" @bind="UseXslt3Service" @bind:after="OnSettingsChanged">
                    <label class="form-check-label" for="useXslt3">
                        Use XSLT3 Service (XSLT 2.0/3.0)
                    </label>
                </div>
                <div class="form-check mb-2">
                    <input class="form-check-input" type="checkbox" id="normalizeHeaders" @bind="NormalizeHeaders" @bind:after="OnSettingsChanged">
                    <label class="form-check-label" for="normalizeHeaders">
                        Normalize Headers
                    </label>
                </div>
                <div class="form-check mb-2">
                    <input class="form-check-input" type="checkbox" id="autoTransform" @bind="AutoTransform" @bind:after="OnSettingsChanged">
                    <label class="form-check-label" for="autoTransform">
                        Auto-transform on XML or XSLT change
                    </label>
                </div>

                <hr class="my-3" />

                <div class="settings-section">
                    <h6 class="mb-2">Layout</h6>
                    <button class="btn btn-outline-secondary w-100"
                            @onclick="ResetPanelLayout">
                        <i class="oi oi-action-undo me-2"></i>
                        Reset Panel Layout
                    </button>
                    <small class="text-muted d-block mt-1">
                        Restore default panel widths and clear saved layout
                    </small>
                </div>

                <hr class="my-3" />

                <div class="mt-3">
                    <FileUpload ProjectId="@SelectedProjectId" OnFilesUploaded="OnFilesUploaded" />
                </div>
            </div>
        </div>
    </div>
}

<!-- XML Steering Attributes Help Modal -->
<div class="modal fade" id="xmlSteeringAttributesModal" tabindex="-1" aria-labelledby="xmlSteeringAttributesModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg modal-dialog-centered modal-dialog-scrollable">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="xmlSteeringAttributesModalLabel">
                    <i class="bi bi-code-square me-2"></i>XML Steering Attributes
                </h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p class="lead">
                    Steering attributes allow you to control transformation behavior by adding special attributes to your input XML elements.
                </p>

                <div class="attribute-section">
                    <h6 class="attribute-title">
                        <i class="bi bi-scissors me-2"></i>Content Stripping
                    </h6>

                    <div class="attribute-details">
                        <div class="attribute-name">
                            <code>data-strip</code>
                        </div>
                        <p class="attribute-description">
                            Excludes content ranges from the transformation output. Elements marked with data-strip="true" start the exclusion range, and data-strip="false" ends it (inclusive).
                        </p>

                        <div class="attribute-usage">
                            <strong>Applied to:</strong> <code>&lt;p&gt;</code>, <code>&lt;h1&gt;</code>, <code>&lt;h2&gt;</code>, <code>&lt;h3&gt;</code>, <code>&lt;h4&gt;</code>, <code>&lt;h5&gt;</code>, <code>&lt;h6&gt;</code>, <code>&lt;img&gt;</code>, <code>&lt;table&gt;</code> elements
                        </div>

                        <div class="attribute-values">
                            <strong>Values:</strong>
                            <ul>
                                <li><code>true</code> - Start stripping content (this element and all following elements are excluded)</li>
                                <li><code>false</code> - Stop stripping content (this element is excluded, but following elements are included)</li>
                            </ul>
                        </div>

                        <div class="attribute-example">
                            <strong>Example:</strong>
                            <pre><code>&lt;p&gt;This content will be kept&lt;/p&gt;
&lt;p data-strip="true"&gt;This will be REMOVED&lt;/p&gt;
&lt;h2&gt;This will also be REMOVED&lt;/h2&gt;
&lt;img src="removed.jpg" /&gt;
&lt;p data-strip="false"&gt;This will also be REMOVED&lt;/p&gt;
&lt;p&gt;This content will be kept again&lt;/p&gt;</code></pre>
                        </div>

                        <div class="attribute-effect">
                            <strong>Effect:</strong>
                            <p>
                                All elements between data-strip="true" and data-strip="false" (inclusive) are removed from the output. This is useful for excluding cover pages, table of contents, or other sections that should not appear in the final document. Multiple strip ranges can be used in the same document.
                            </p>
                        </div>

                        <div class="attribute-use-case">
                            <strong>Use case:</strong>
                            <p>
                                When PDF documents contain sections that should be excluded from the final output (such as disclaimers, cover pages, or appendices), use data-strip to mark the start and end of content ranges to remove. The attribute is processed in the final transformation pass and completely removes the marked content.
                            </p>
                        </div>
                    </div>
                </div>

                <div class="attribute-section">
                    <h6 class="attribute-title">
                        <i class="bi bi-table me-2"></i>Table Cell Injection
                    </h6>

                    <div class="attribute-details">
                        <div class="attribute-name">
                            <code>data-injectcell-position</code>
                        </div>
                        <p class="attribute-description">
                            Controls where missing cells are inserted in asymmetric table rows.
                        </p>

                        <div class="attribute-usage">
                            <strong>Applied to:</strong> <code>&lt;TABLE&gt;</code> element
                        </div>

                        <div class="attribute-values">
                            <strong>Values:</strong>
                            <ul>
                                <li><code>Integer (1 to N)</code> - Insert cells before position N</li>
                                <li><code>0, negative, or missing</code> - Append cells at end (default behavior)</li>
                            </ul>
                        </div>

                        <div class="attribute-example">
                            <strong>Example:</strong>
                            <pre><code>&lt;TABLE data-injectcell-position="2"&gt;
  &lt;TR&gt;
    &lt;TD&gt;Cell 1&lt;/TD&gt;
    &lt;TD&gt;Cell 2&lt;/TD&gt;
    &lt;TD&gt;Cell 3&lt;/TD&gt;
  &lt;/TR&gt;
  &lt;TR&gt;
    &lt;TD&gt;Cell 1&lt;/TD&gt;
    &lt;!-- Missing cell will be inserted at position 2 --&gt;
    &lt;TD&gt;Cell 3&lt;/TD&gt;
  &lt;/TR&gt;
&lt;/TABLE&gt;</code></pre>
                        </div>

                        <div class="attribute-effect">
                            <strong>Effect:</strong>
                            <p>
                                In rows with fewer cells than the maximum, new cells are inserted at the specified position instead of being appended to the end.
                                This helps maintain proper column alignment in tables where cells are missing from the middle of rows.
                            </p>
                        </div>
                    </div>
                </div>

                <div class="attribute-section">
                    <h6 class="attribute-title">
                        <i class="bi bi-type-h1 me-2"></i>Force Header Conversion
                    </h6>

                    <div class="attribute-details">
                        <div class="attribute-name">
                            <code>data-forceheader</code>
                        </div>
                        <p class="attribute-description">
                            Forces a paragraph element to be converted to a specific header level during transformation.
                        </p>

                        <div class="attribute-usage">
                            <strong>Applied to:</strong> <code>&lt;P&gt;</code> element
                        </div>

                        <div class="attribute-values">
                            <strong>Values:</strong>
                            <ul>
                                <li><code>h1</code> - Convert to level 1 header</li>
                                <li><code>h2</code> - Convert to level 2 header</li>
                                <li><code>h3</code> - Convert to level 3 header</li>
                                <li><code>h4</code> - Convert to level 4 header</li>
                            </ul>
                        </div>

                        <div class="attribute-example">
                            <strong>Example:</strong>
                            <pre><code>&lt;P data-forceheader="h2"&gt;Important Section Title&lt;/P&gt;</code></pre>
                        </div>

                        <div class="attribute-effect">
                            <strong>Effect:</strong>
                            <p>
                                The paragraph is transformed into the specified header level (e.g., <code>&lt;h2&gt;</code>) with a default <code>(a),(b),(c)</code> numbering scheme.
                                This is useful when Adobe Acrobat incorrectly classifies a section title as a paragraph instead of a header.
                            </p>
                        </div>

                        <div class="attribute-use-case">
                            <strong>Use case:</strong>
                            <p>
                                When Adobe Acrobat misidentifies document structure and marks important section titles as paragraphs (<code>&lt;P&gt;</code>) instead of headers (<code>&lt;H2&gt;</code>, <code>&lt;H3&gt;</code>, etc.),
                                use this attribute to correct the document structure and ensure proper hierarchy in the output.
                            </p>
                        </div>
                    </div>
                </div>

                <div class="alert alert-info mt-4" role="alert">
                    <i class="bi bi-info-circle me-2"></i>
                    <strong>Note:</strong> Steering attributes are processed during XSLT transformation.
                    They are removed from the final output XML.
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
            </div>
        </div>
    </div>
</div>

<!-- Special Tools Modal -->
<div class="modal fade" id="specialToolsModal" tabindex="-1" aria-labelledby="specialToolsModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg modal-dialog-centered modal-dialog-scrollable">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="specialToolsModalLabel">
                    <i class="bi bi-tools me-2"></i>Special Tools
                </h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p class="lead">
                    Utility tools to help prepare and fix common issues in XML files before transformation.
                </p>

                <!-- Fix Characters Tool -->
                <div class="attribute-section">
                    <h6 class="attribute-title">
                        <i class="bi bi-type me-2"></i>Fix Characters
                    </h6>

                    <div class="attribute-details">
                        <p class="attribute-description">
                            Replace standalone '&' characters with '&amp;' XML entity to prevent validation errors.
                        </p>

                        <div class="attribute-usage">
                            <strong>What it does:</strong> Scans the current XML file and replaces any standalone '&' characters that are not already part of an entity (like &amp;, &lt;, &gt;, &#160;, etc.) with the proper '&amp;' entity.
                        </div>

                        <div class="mt-3">
                            <button class="btn btn-primary"
                                    @onclick="OnFixCharactersClickedAsync"
                                    disabled="@(IsFixingCharacters || string.IsNullOrEmpty(SelectedFileName))">
                                @if (IsFixingCharacters)
                                {
                                    <span class="spinner-border spinner-border-sm me-2"></span>
                                    <span>Fixing...</span>
                                }
                                else
                                {
                                    <i class="bi bi-play-fill me-2"></i>
                                    <span>Run Fix</span>
                                }
                            </button>
                        </div>

                        @if (!string.IsNullOrEmpty(FixCharactersResult))
                        {
                            <div class="alert @(FixCharactersSuccess ? "alert-success" : "alert-danger") mt-3 mb-0" role="alert">
                                <i class="bi @(FixCharactersSuccess ? "bi-check-circle" : "bi-exclamation-triangle") me-2"></i>
                                @FixCharactersResult
                            </div>
                        }
                    </div>
                </div>

                <!-- Sanitize Document Tool -->
                <div class="attribute-section mt-4">
                    <h6 class="attribute-title">
                        <i class="bi bi-shield-lock me-2"></i>Sanitize Document
                    </h6>

                    <div class="attribute-details">
                        <p class="attribute-description">
                            Create a lorem ipsum version with bogus data for safe sharing.
                        </p>

                        <div class="attribute-usage">
                            <strong>What it does:</strong> Creates a copy of the XML file with all text replaced by lorem ipsum placeholder text while preserving the document structure. The sanitized file will be saved as [filename]-lorem.xml in the same directory.
                        </div>

                        <div class="mt-3">
                            <button class="btn btn-primary"
                                    @onclick="OnSanitizeXmlClickedAsync"
                                    disabled="@(IsSanitizing || string.IsNullOrEmpty(SelectedFileName))">
                                @if (IsSanitizing)
                                {
                                    <span class="spinner-border spinner-border-sm me-2"></span>
                                    <span>Sanitizing...</span>
                                }
                                else
                                {
                                    <i class="bi bi-play-fill me-2"></i>
                                    <span>Run Sanitize</span>
                                }
                            </button>
                        </div>

                        @if (!string.IsNullOrEmpty(SanitizeResult))
                        {
                            <div class="alert @(SanitizeSuccess ? "alert-success" : "alert-danger") mt-3 mb-0" role="alert">
                                <i class="bi @(SanitizeSuccess ? "bi-check-circle" : "bi-exclamation-triangle") me-2"></i>
                                @SanitizeResult
                            </div>
                        }
                    </div>
                </div>

                <!-- Fix Header Caps Tool -->
                <div class="attribute-section mt-4">
                    <h6 class="attribute-title">
                        <i class="bi bi-type me-2"></i>Fix Header Caps
                    </h6>

                    <div class="attribute-details">
                        <p class="attribute-description">
                            Convert ALL CAPS headers to Smart Title Case.
                        </p>

                        <div class="attribute-usage">
                            <strong>What it does:</strong> Scans header elements (h1-h6) in the current XML file. If a header's text is mostly uppercase (&gt;80% of letters), it converts it to Smart Title Case â€” capitalizing each word except small words like "of", "the", "and", etc.
                        </div>

                        <div class="mt-3">
                            <button class="btn btn-primary"
                                    @onclick="OnFixHeaderCapsClickedAsync"
                                    disabled="@(IsFixingHeaderCaps || string.IsNullOrEmpty(SelectedFileName))">
                                @if (IsFixingHeaderCaps)
                                {
                                    <span class="spinner-border spinner-border-sm me-2"></span>
                                    <span>Fixing...</span>
                                }
                                else
                                {
                                    <i class="bi bi-play-fill me-2"></i>
                                    <span>Run Fix</span>
                                }
                            </button>
                        </div>

                        @if (!string.IsNullOrEmpty(FixHeaderCapsResult))
                        {
                            <div class="alert @(FixHeaderCapsSuccess ? "alert-success" : "alert-danger") mt-3 mb-0" role="alert">
                                <i class="bi @(FixHeaderCapsSuccess ? "bi-check-circle" : "bi-exclamation-triangle") me-2"></i>
                                @FixHeaderCapsResult
                            </div>
                        }
                    </div>
                </div>

                <div class="alert alert-info mt-4" role="alert">
                    <i class="bi bi-info-circle me-2"></i>
                    <strong>Note:</strong> After running any tool, the XML file will be automatically reloaded to reflect the changes.
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
            </div>
        </div>
    </div>
</div>

<!-- Output Preview Help Modal -->
<div class="modal fade" id="outputPreviewHelpModal" tabindex="-1" aria-labelledby="outputPreviewHelpModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="outputPreviewHelpModalLabel">
                    <i class="bi bi-eye me-2"></i>Output Preview
                </h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                @if (!string.IsNullOrEmpty(SavedNormalizedXmlPath))
                {
                    <div class="alert alert-info mb-0" role="alert">
                        <div class="d-flex align-items-start">
                            <i class="bi bi-folder-open me-3" style="font-size: 1.5rem;"></i>
                            <div class="flex-grow-1">
                                <h6 class="alert-heading mb-2">Normalized XML saved to:</h6>
                                <code class="d-block mb-3 p-2 bg-light rounded">@SavedNormalizedXmlPath</code>
                                <button type="button" class="btn btn-sm btn-outline-primary" @onclick="() => CopyPathToClipboard(SavedNormalizedXmlPath)">
                                    <i class="bi bi-clipboard me-1"></i>Copy Path
                                </button>
                            </div>
                        </div>
                    </div>
                }
                else
                {
                    <div class="text-muted text-center py-3">
                        <i class="bi bi-info-circle me-2"></i>
                        Transform the XML to see the saved file path
                    </div>
                }
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
            </div>
        </div>
    </div>
</div>

<!-- Validation Errors Modal (Draggable) -->
@if (ValidationResult != null)
{
    <div class="modal fade" id="validationErrorsModal" tabindex="-1" aria-labelledby="validationErrorsModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-lg modal-dialog-scrollable" id="validation-modal-dialog">
            <div class="modal-content">
                <div class="modal-header" id="validation-modal-header">
                    <h5 class="modal-title" id="validationErrorsModalLabel">
                        <i class="bi bi-exclamation-triangle-fill text-danger me-2"></i>XHTML Validation Errors
                    </h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    @if (ValidationResult.Issues.Any())
                    {
                        <div class="alert alert-warning mb-3" role="alert">
                            <i class="bi bi-info-circle me-2"></i>
                            Found <strong>@ValidationResult.TotalIssues</strong> validation @(ValidationResult.TotalIssues == 1 ? "issue" : "issues")
                            with <strong>@ValidationResult.TotalOccurrences</strong> total @(ValidationResult.TotalOccurrences == 1 ? "occurrence" : "occurrences")
                        </div>

                        @* Unified Validation Issues List *@
                        <div class="list-group">
                            @foreach (var issue in ValidationResult.Issues)
                            {
                                var isInvalid = issue.Type == ValidationIssueType.InvalidElement;
                                var isUppercase = issue.Type == ValidationIssueType.UppercaseInElementName;
                                var isSchemaOnly = issue.Type == ValidationIssueType.SchemaValidationError;
                                var hasSchemaMessage = !string.IsNullOrEmpty(issue.SchemaMessage);

                                <div class="list-group-item">
                                    <div class="d-flex align-items-start gap-3 mb-2">
                                        @* Icon *@
                                        <div class="flex-shrink-0">
                                            @if (isInvalid || isSchemaOnly)
                                            {
                                                <i class="bi bi-x-circle text-danger" title="Invalid element" style="font-size: 1.5rem;"></i>
                                            }
                                            else if (isUppercase)
                                            {
                                                <i class="bi bi-type text-warning" title="Uppercase in element name" style="font-size: 1.5rem;"></i>
                                            }
                                        </div>

                                        @* Element Name & Count *@
                                        <div class="flex-grow-1">
                                            <div class="mb-2">
                                                <code class="@(isInvalid || isSchemaOnly ? "text-danger" : "text-warning") fs-6">&lt;@issue.ElementName&gt;</code>
                                                <span class="badge bg-secondary ms-2">@issue.OccurrenceCount @(issue.OccurrenceCount == 1 ? "occurrence" : "occurrences")</span>
                                            </div>

                                            @* Issue Description *@
                                            @if (hasSchemaMessage)
                                            {
                                                <div class="text-muted small mb-2">
                                                    @issue.SchemaMessage
                                                </div>
                                            }
                                            else
                                            {
                                                <div class="text-muted small mb-2">
                                                    @issue.Description
                                                </div>
                                            }

                                            @* Location Information *@
                                            @if (issue.LineNumbers != null && issue.LineNumbers.Any())
                                            {
                                                <div class="mt-2">
                                                    <small class="text-muted d-block mb-1">
                                                        @(issue.LineNumbers.Count == 1 ? "Location:" : $"First {Math.Min(5, issue.LineNumbers.Count)} locations:")
                                                    </small>
                                                    @for (int i = 0; i < Math.Min(5, issue.LineNumbers.Count); i++)
                                                    {
                                                        var lineNum = issue.LineNumbers[i];
                                                        var linePos = issue.LinePositions != null && i < issue.LinePositions.Count ? issue.LinePositions[i] : 0;
                                                        var locationText = $"Line {lineNum}:{linePos}";

                                                        <div class="d-flex align-items-center gap-2 mb-1">
                                                            <code class="small text-muted">@locationText</code>
                                                            <button class="btn btn-sm btn-outline-secondary"
                                                                    @onclick="() => CopyToClipboardAsync(locationText)"
                                                                    title="Copy location">
                                                                <i class="bi bi-clipboard"></i>
                                                            </button>
                                                            <button class="btn btn-sm btn-primary"
                                                                    @onclick="() => NavigateToLine(lineNum)"
                                                                    title="Navigate to line">
                                                                <i class="bi bi-arrow-right-circle"></i>
                                                            </button>
                                                        </div>
                                                    }

                                                    @if (issue.LineNumbers.Count > 5)
                                                    {
                                                        <small class="text-muted">+ @(issue.LineNumbers.Count - 5) more @(issue.LineNumbers.Count - 5 == 1 ? "occurrence" : "occurrences")</small>
                                                    }
                                                </div>
                                            }
                                            else if (issue.XPaths != null && issue.XPaths.Any())
                                            {
                                                <div class="mt-2">
                                                    <small class="text-muted d-block mb-1">First occurrence XPath:</small>
                                                    <div class="d-flex align-items-center gap-2">
                                                        <code class="small flex-grow-1 text-muted text-break">@issue.XPaths.First()</code>
                                                        <button class="btn btn-sm btn-outline-secondary"
                                                                @onclick="() => CopyToClipboardAsync(issue.XPaths.First())"
                                                                title="Copy XPath">
                                                            <i class="bi bi-clipboard"></i>
                                                        </button>
                                                        <button class="btn btn-sm btn-primary"
                                                                @onclick="() => NavigateToElement(issue.XPaths.First())"
                                                                title="Navigate to element">
                                                            <i class="bi bi-arrow-right-circle"></i>
                                                        </button>
                                                    </div>
                                                </div>
                                            }
                                        </div>
                                    </div>
                                </div>
                            }
                        </div>

                        @* Legend *@
                        <div class="mt-3 p-3 bg-light rounded">
                            <div class="d-flex align-items-center gap-3 flex-wrap small">
                                <div>
                                    <i class="bi bi-x-circle text-danger me-1"></i>
                                    <span>Invalid element (not in HTML5 spec or fails W3C XHTML validation)</span>
                                </div>
                                <div>
                                    <i class="bi bi-type text-warning me-1"></i>
                                    <span>Uppercase in element name (HTML requires lowercase)</span>
                                </div>
                            </div>
                        </div>
                    }
                    else
                    {
                        <div class="alert alert-success mb-0" role="alert">
                            <i class="bi bi-check-circle me-2"></i>
                            No validation errors found! The XHTML output is valid.
                        </div>
                    }
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                </div>
            </div>
        </div>
    </div>
}

<!-- Three-Panel Layout -->
<div class="development-workspace">
    <div class="panels-container" id="panels-container">
        <!-- Left Panel: Source XML Viewer -->
        <div class="panel panel-left" id="panel-left">
            <div class="panel-header">
                <div class="panel-header-left">
                    @if (Projects != null && Projects.Any())
                    {
                        <ProjectFileSelectionToolbar
                            FileGroups="@ProjectFileGroups"
                            @bind-ProjectId="@SelectedProjectId"
                            @bind-FileName="@SelectedFileName"
                            OnSelectionChanged="@HandleFileSelection"
                            ShowLabel="false"
                            CssClass="form-select form-select-sm xslt-file-select"
                            PlaceholderText="Select a file..."
                            InputOutputType="input" />
                    }
                    else
                    {
                        <span class="text-muted small">@(SelectedFileName ?? "No file selected")</span>
                    }
                </div>
                <div class="panel-header-right">
                    <div class="panel-action-buttons">
                        <button class="btn btn-sm panel-action-btn"
                                @onclick="SaveXmlAsync"
                                disabled="@(!CanSaveXml || IsSavingXml)"
                                title="Save Source XML (Ctrl+S)"
                                data-bs-toggle="tooltip">
                            @if (IsSavingXml)
                            {
                                <span class="spinner-border spinner-border-sm"></span>
                            }
                            else
                            {
                                <i class="bi bi-floppy-fill"></i>
                            }
                        </button>
                        <button class="btn btn-sm panel-action-btn"
                                title="Special Tools"
                                data-bs-toggle="modal"
                                data-bs-target="#specialToolsModal">
                            <i class="bi bi-tools"></i>
                        </button>
                        <button class="btn btn-sm panel-help-btn"
                                title="Source XML Help"
                                data-bs-toggle="modal"
                                data-bs-target="#xmlSteeringAttributesModal">
                            <i class="bi bi-question-circle"></i>
                        </button>
                    </div>
                </div>
            </div>
            <div class="panel-content">
                <!-- Keep Monaco viewer in DOM at all times to prevent detachment -->
                <!-- Use CSS display to show/hide based on state -->
                <div id="source-xml-viewer" style="width: 100%; height: 100%; display: @(IsLoadingXml || string.IsNullOrEmpty(XmlContent) ? "none" : "block");"></div>

                @if (IsLoadingXml)
                {
                    <LoadingSkeleton IsLoading="true" Type="SkeletonType.CodeEditor" Lines="25">
                    </LoadingSkeleton>
                }
                else if (string.IsNullOrEmpty(XmlContent))
                {
                    <div class="text-center p-5 text-muted">
                        <i class="bi bi-file-earmark-code" style="font-size: 3rem;"></i>
                        <p class="mt-3">Select a project and file to view the source XML</p>
                    </div>
                }
            </div>
        </div>

        <!-- Resize Handle 1 -->
        <div class="resize-handle" id="resize-handle-1"></div>

        <!-- Center Panel: XSLT Editor -->
        <div class="panel panel-center" id="panel-center">
            <div class="panel-header">
                <div class="panel-header-left">
                    @if (XsltFiles != null && XsltFiles.Any())
                    {
                        <select class="form-select form-select-sm xslt-file-select" @onchange="OnXsltFileChanged" value="@SelectedXsltFile">
                            @foreach (var file in XsltFiles)
                            {
                                <option value="@file">@file</option>
                            }
                        </select>
                    }
                    else
                    {
                        <span class="text-muted small">@(SelectedXsltFile ?? "transformation.xslt")</span>
                    }
                </div>
                <div class="panel-header-right">
                    <div class="panel-action-buttons">
                        <button class="btn btn-sm panel-action-btn" @onclick="TransformAsync" disabled="@(!CanTransform || IsTransforming)" title="Transform (Ctrl+Enter)" data-bs-toggle="tooltip">
                            @if (IsTransforming)
                            {
                                <span class="spinner-border spinner-border-sm"></span>
                            }
                            else
                            {
                                <i class="bi bi-play-fill"></i>
                            }
                        </button>
                        <button class="btn btn-sm panel-action-btn" @onclick="SaveXsltAsync" disabled="@(!CanSave || IsSaving)" title="Save XSLT (Ctrl+S)" data-bs-toggle="tooltip">
                            @if (IsSaving)
                            {
                                <span class="spinner-border spinner-border-sm"></span>
                            }
                            else
                            {
                                <i class="bi bi-floppy-fill"></i>
                            }
                        </button>
                        <button class="btn btn-sm panel-help-btn"
                                title="XSLT Transformation: Edit XSLT templates to transform Adobe XML to Taxxor XHTML"
                                data-bs-toggle="tooltip"
                                data-bs-placement="bottom">
                            <i class="bi bi-question-circle"></i>
                        </button>
                    </div>
                </div>
            </div>
            <div class="panel-content">
                <LoadingSkeleton IsLoading="@IsLoadingXslt" Type="SkeletonType.CodeEditor" Lines="30">
                    <div id="monaco-editor-container" style="width: 100%; height: 100%;"></div>
                </LoadingSkeleton>
            </div>
        </div>

        <!-- Resize Handle 2 -->
        <div class="resize-handle" id="resize-handle-2"></div>

        <!-- Right Panel: Preview -->
        <div class="panel panel-right" id="panel-right">
            <div class="panel-header">
                <div class="panel-header-left">
                    @if (!string.IsNullOrEmpty(OutputContent))
                    {
                        <div class="form-check form-switch">
                            <input class="form-check-input" type="checkbox" id="renderedToggle" @bind-value="ShowRendered" @bind-value:after="OnRenderedToggled">
                            <label class="form-check-label" for="renderedToggle">HTML mode</label>
                        </div>
                        @if (!ShowRendered)
                        {
                            <div class="form-check form-switch">
                                <input class="form-check-input" type="checkbox" id="formatToggle"
                                       checked="@ShowFormattedXml"
                                       @bind-value="ShowFormattedXml"
                                       @bind-value:after="OnFormatChanged">
                                <label class="form-check-label" for="formatToggle">Format</label>
                            </div>
                        }
                    }
                </div>
                <div class="panel-header-right">
                    @if (!string.IsNullOrEmpty(OutputContent))
                    {
                        @if (ShowRendered)
                        {
                            <span class="zoom-indicator">@ZoomLevel%</span>
                            <button class="btn btn-sm panel-action-btn" @onclick="ZoomIn" title="Zoom In" data-bs-toggle="tooltip" disabled="@(ZoomLevel >= 200)">
                                <i class="bi bi-zoom-in"></i>
                            </button>
                            <button class="btn btn-sm panel-action-btn" @onclick="ZoomOut" title="Zoom Out" data-bs-toggle="tooltip" disabled="@(ZoomLevel <= 50)">
                                <i class="bi bi-zoom-out"></i>
                            </button>
                        }
                        <button class="btn btn-sm panel-action-btn" @onclick="CopyToClipboard" title="Copy to clipboard" data-bs-toggle="tooltip">
                            <i class="bi bi-clipboard"></i>
                        </button>
                        <button class="btn btn-sm panel-action-btn" @onclick="DownloadOutput" title="Download output" data-bs-toggle="tooltip">
                            <i class="bi bi-download"></i>
                        </button>
                    }
                    <button class="btn btn-sm panel-help-btn"
                            title="Output Preview Help"
                            data-bs-toggle="modal"
                            data-bs-target="#outputPreviewHelpModal">
                        <i class="bi bi-question-circle"></i>
                    </button>
                </div>
            </div>
            <div class="panel-content">
                @if (IsTransforming)
                {
                    <div class="transformation-overlay">
                        <div class="transformation-indicator">
                            <div class="spinner-border text-success" role="status">
                                <span class="visually-hidden">Transforming...</span>
                            </div>
                            <p class="mt-3 fw-bold">Transforming XML...</p>
                            <p class="text-muted small">Please wait while the transformation is in progress</p>
                        </div>
                    </div>
                }
                @if (!string.IsNullOrEmpty(TransformationError))
                {
                    <div class="p-4">
                        <div class="alert alert-danger mb-0" role="alert">
                            <h5 class="alert-heading">
                                <i class="bi bi-exclamation-triangle-fill"></i> Transformation Error
                            </h5>
                            <hr />
                            <pre class="mb-0" style="white-space: pre-wrap; font-family: 'Monaco', 'Menlo', 'Consolas', monospace; font-size: 0.875rem;">@TransformationError</pre>
                        </div>
                    </div>
                }
                else if (!string.IsNullOrEmpty(OutputContent))
                {
                    <!-- Keep both views in DOM, use CSS to show/hide -->
                    <!-- This prevents Monaco editor from losing its DOM element -->
                    <div class="preview-rendered" style="font-size: @(ZoomLevel)%; display: @(ShowRendered ? "block" : "none");">
                        @((MarkupString)OutputContent)
                    </div>
                    <div id="output-xml-viewer" style="width: 100%; height: 100%; display: @(ShowRendered ? "none" : "block");"></div>
                    @if (TransformationStats != null)
                    {
                        <div class="preview-stats">
                            <div class="stats-content">
                                <div class="stats-left">
                                    <span class="badge bg-success">
                                        <i class="bi bi-clock"></i> @TransformationStats.ProcessingTimeMs ms
                                    </span>
                                    @if (TransformationStats.HeadersNormalized > 0)
                                    {
                                        <span class="badge bg-info">
                                            <i class="bi bi-type-h1"></i> @TransformationStats.HeadersNormalized headers normalized
                                        </span>
                                    }
                                    @if (TransformationStats.TablesProcessed > 0)
                                    {
                                        <span class="badge bg-primary">
                                            <i class="bi bi-table"></i> @TransformationStats.TablesProcessed tables processed
                                        </span>
                                    }
                                    @if (TransformationStats.WarningMessages.Any())
                                    {
                                        <span class="badge bg-warning text-dark">
                                            <i class="bi bi-exclamation-triangle"></i> @TransformationStats.WarningMessages.Count warnings
                                        </span>
                                    }
                                </div>
                                @if (ValidationResult != null && ValidationResult.TotalIssues > 0)
                                {
                                    <div class="stats-right">
                                        <button class="badge bg-danger text-white border-0"
                                                style="cursor: pointer;"
                                                data-bs-toggle="modal"
                                                data-bs-target="#validationErrorsModal"
                                                title="Click to view validation errors">
                                            <i class="bi bi-exclamation-triangle-fill"></i> @ValidationResult.TotalIssues validation @(ValidationResult.TotalIssues == 1 ? "error" : "errors")
                                        </button>
                                    </div>
                                }
                            </div>
                        </div>
                    }
                }
                else if (!IsTransforming)
                {
                    <div class="text-center p-5 text-muted">
                        <i class="bi bi-eye" style="font-size: 3rem;"></i>
                        <p class="mt-3">@(CanTransform ? "Click \"Transform\" to preview the output" : "Select a project and file to begin")</p>
                        @if (AutoTransform && CanTransform)
                        {
                            <p class="small">Auto-transform is enabled. Edit the XSLT to see live preview.</p>
                        }
                    </div>
                }
            </div>
        </div>
    </div>
</div>

@code {
    // Route Parameters
    [Parameter]
    public string Customer { get; set; } = string.Empty;

    [Parameter]
    public string ProjectId { get; set; } = string.Empty;

    // Query Parameters - URL is the single source of truth
    [Parameter, SupplyParameterFromQuery(Name = "inputFile")]
    public string? InputFileParam { get; set; }

    [Parameter, SupplyParameterFromQuery(Name = "xsltFile")]
    public string? XsltFileParam { get; set; }

    [Parameter, SupplyParameterFromQuery(Name = "view")]
    public string? ViewParam { get; set; }  // "source" or "rendered"

    // LocalStorage models
    private class SavedSelection
    {
        public string? ProjectId { get; set; }
        public string? FileName { get; set; }
        public string? XsltFile { get; set; }
    }

    private class SavedSettings
    {
        public bool UseXslt3Service { get; set; }
        public bool NormalizeHeaders { get; set; }
        public bool AutoTransform { get; set; }
        public bool HasStoredSettings { get; set; }
    }

    // State
    private List<Project>? Projects;
    private List<string>? ProjectFiles;
    private string? SelectedProjectId;
    private string? SelectedFileName;
    private string? XmlContent;
    private string? XsltContent;
    private List<string>? XsltFiles;
    private string? SelectedXsltFile = "transformation.xslt";
    private string? OutputContent;
    private TransformationResult? TransformationStats;
    private string? TransformationError;
    private XhtmlValidationResult? ValidationResult;
    private string? SavedNormalizedXmlPath;

    // Phase 0 Safety Infrastructure
    private bool _hasUnsavedChanges = false;
    private string? _originalXmlContent;
    private int _navigationLoopCount = 0;
    private const int MAX_NAVIGATIONS = 5;

    // Query parameter tracking (for detecting changes)
    private string? _currentInputFile;
    private string? _currentXsltFile;
    private string? _currentView;

    // UI State
    private bool IsLoading = false;
    private bool IsLoadingXml = false;
    private bool IsLoadingXslt = false;
    private bool IsTransforming = false;
    private bool IsSaving = false;
    private bool IsSavingXml = false;
    private bool ShowSettings = false;
    private bool ShowRendered = false; // Default to source view
    private bool ShowFormattedXml = true;
    private bool isUpdatingFromExternalFile = false; // Prevents Monaco from triggering auto-transform during external updates
    private bool isUpdatingFromExternalXmlFile = false; // Prevents infinite loops when syncing XML from external file
    private bool isSavingXmlToFile = false; // True when actively saving XML to prevent reload loop

    // Special Tools State
    private bool IsFixingCharacters = false;
    private string? FixCharactersResult = null;
    private bool FixCharactersSuccess = false;

    // Sanitization State
    private bool IsSanitizing = false;
    private string? SanitizeResult = null;
    private bool SanitizeSuccess = false;

    // Header Caps State
    private bool IsFixingHeaderCaps = false;
    private string? FixHeaderCapsResult = null;
    private bool FixHeaderCapsSuccess = false;

    // Settings (defaults will be overridden by localStorage if available)
    private bool UseXslt3Service = true;
    private bool NormalizeHeaders = true;
    private bool AutoTransform = false;

    // Preview Controls
    private int ZoomLevel = 100;

    // Computed Properties
    private bool CanTransform => !string.IsNullOrEmpty(SelectedProjectId)
                                && !string.IsNullOrEmpty(SelectedFileName)
                                && !string.IsNullOrEmpty(XmlContent)
                                && !string.IsNullOrEmpty(XsltContent);

    private bool CanSave => !string.IsNullOrEmpty(XsltContent);

    private bool CanSaveXml => !string.IsNullOrEmpty(XmlContent)
                             && !string.IsNullOrEmpty(SelectedProjectId)
                             && !string.IsNullOrEmpty(SelectedFileName);

    // ProjectFileSelector helper properties
    private List<ProjectFileGroup> ProjectFileGroups { get; set; } = new();

    private async Task OnRenderedToggled()
    {
        // ShowRendered is already updated by @bind-value
        Logger.LogInformation("Rendered toggle changed: ShowRendered = {ShowRendered}", ShowRendered);

        // Update URL with new view parameter (use replace: true to not add history)
        var viewMode = ShowRendered ? "rendered" : "source";
        var url = BuildUrlWithParams(
            inputFile: _currentInputFile,
            xsltFile: _currentXsltFile,
            view: viewMode
        );
        NavigationManager.NavigateTo(url, replace: true);

        // If Source view is now active (Rendered OFF), ensure Monaco viewer is initialized or updated
        // Note: The viewer container stays in DOM (just hidden/shown with CSS), so we only
        // need to initialize once. However, we must update content if viewer already exists,
        // as transformations while in HTML mode don't update the Monaco viewer.
        if (!ShowRendered && !string.IsNullOrEmpty(OutputContent))
        {
            // Give Blazor time to render and make the container visible
            await Task.Delay(100);

            try
            {
                if (!_outputXmlViewerInitialized)
                {
                    // Initialize viewer first time
                    var outputTheme = ThemeService.GetMonacoTheme();
                    await JSRuntime.InvokeVoidAsync("MonacoViewerInterop.createViewer",
                        "output-xml-viewer",
                        "outputXml",
                        new {
                            value = OutputContent ?? "",
                            language = "xml",
                            theme = outputTheme
                        });
                    _outputXmlViewerInitialized = true;
                    Logger.LogInformation("Output XML viewer initialized when toggling to source view");
                }
                else
                {
                    // Update existing viewer content (fixes bug where switching files in HTML mode
                    // doesn't update Monaco viewer, so toggling back to XML shows stale content)
                    await JSRuntime.InvokeVoidAsync("MonacoViewerInterop.setValue",
                        "outputXml",
                        OutputContent ?? "");
                    Logger.LogInformation("Output XML viewer content updated when toggling to source view");
                }
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Error initializing/updating Output XML viewer when toggling to source view");
                ToastNotification.ShowError("Failed to initialize viewer. Please try again.");
            }
        }

        StateHasChanged();
    }

    private async Task OnFormatChanged()
    {
        // ShowFormattedXml is already updated by @bind-value
        Logger.LogInformation("Format checkbox changed: ShowFormattedXml = {ShowFormatted}", ShowFormattedXml);

        // Monaco viewer handles formatting automatically
        // This method is kept for backwards compatibility but no longer needs to do anything
        StateHasChanged();
    }

    protected override async Task OnInitializedAsync()
    {
        // Validate project parameters
        if (!ProjectValidation.IsValidProjectParameters(Customer, ProjectId))
        {
            Logger.LogWarning("Invalid project parameters in Transform page: {Customer}/{ProjectId}", Customer, ProjectId);
            NavigationManager.NavigateTo("/");
            return;
        }

        if (!ProjectValidation.ProjectExists(Customer, ProjectId))
        {
            Logger.LogWarning("Project not found in Transform page: {Customer}/{ProjectId}", Customer, ProjectId);
            // TODO: Show toast notification
            NavigationManager.NavigateTo("/");
            return;
        }

        // Wire up toolbar state
        ToolbarState.OnTransform = TransformAsync;
        ToolbarState.OnSave = SaveXsltAsync;
        ToolbarState.OnToggleSettings = ToggleSettings;
        ToolbarState.OnProjectChanged = async (projectId) =>
        {
            await OnProjectChanged(new ChangeEventArgs { Value = projectId });
        };
        ToolbarState.OnFileChanged = async (fileName) =>
        {
            await OnFileChanged(new ChangeEventArgs { Value = fileName });
        };
        // Note: OnToggleTransformationLog is handled in MainLayout

        // Register file watcher callbacks (replaces any existing callback to prevent double subscription)
        XsltFileWatcher.SetFileChangedCallback(OnXsltFileChangedExternally);
        XmlFileWatcher.SetFileChangedCallback(OnXmlFileChangedExternally);

        await LoadProjectsAsync();
        await LoadXsltAsync();

        UpdateToolbarState();
    }

    protected override async Task OnParametersSetAsync()
    {
        // Phase 0 Safety: Navigation loop detection
        if (_navigationLoopCount++ > MAX_NAVIGATIONS)
        {
            Logger.LogError("Navigation loop detected! OnParametersSetAsync called {Count} times. Aborting to prevent infinite loop.", _navigationLoopCount);
            _navigationLoopCount = 0;
            return;
        }

        Logger.LogInformation("OnParametersSetAsync: Detected navigation to {Customer}/{ProjectId} (loop count: {Count})", Customer, ProjectId, _navigationLoopCount);

        // Validate project parameters (same as OnInitializedAsync)
        if (!ProjectValidation.IsValidProjectParameters(Customer, ProjectId))
        {
            Logger.LogWarning("Invalid project parameters in Transform page: {Customer}/{ProjectId}", Customer, ProjectId);
            NavigationManager.NavigateTo("/");
            return;
        }

        if (!ProjectValidation.ProjectExists(Customer, ProjectId))
        {
            Logger.LogWarning("Project not found in Transform page: {Customer}/{ProjectId}", Customer, ProjectId);
            NavigationManager.NavigateTo("/");
            return;
        }

        // Build the expected SelectedProjectId
        var expectedProjectId = $"{Customer}/{ProjectId}";

        // Track project context in WorkflowStateService (clears state if project changed)
        WorkflowState.SetProject(Customer, ProjectId);

        // Detect which parameters changed
        var projectChanged = (SelectedProjectId != expectedProjectId);
        var inputFileChanged = (InputFileParam != _currentInputFile);
        var xsltFileChanged = (XsltFileParam != _currentXsltFile);
        var viewChanged = (ViewParam != _currentView);

        // Log parameter changes for debugging
        if (projectChanged || inputFileChanged || xsltFileChanged || viewChanged)
        {
            Logger.LogInformation(
                "Parameters changed - Project: {ProjectChanged}, InputFile: {InputFileChanged}, XSLT: {XsltChanged}, View: {ViewChanged}",
                projectChanged, inputFileChanged, xsltFileChanged, viewChanged
            );

            // Clear all in-memory state
            SelectedProjectId = expectedProjectId;
            SelectedFileName = null;
            XmlContent = null;
            OutputContent = null;
            ProjectFiles = null;
            XsltContent = null;
            SelectedXsltFile = null;
            TransformationStats = null;
            TransformationError = null;
            ValidationResult = null;
            SavedNormalizedXmlPath = null;

            // Update tracking variables
            _currentInputFile = InputFileParam;
            _currentXsltFile = XsltFileParam;
            _currentView = ViewParam;

            // Apply URL parameters BEFORE loading
            // This ensures LoadXsltAsync respects the URL-specified XSLT file
            if (!string.IsNullOrEmpty(XsltFileParam))
            {
                SelectedXsltFile = XsltFileParam;
            }
            else if (!string.IsNullOrEmpty(InputFileParam))
            {
                // Auto-detect XSLT based on input filename when no XSLT param specified
                try
                {
                    var xsltPath = SourceDetectionService.GetXsltPathForSource(InputFileParam);
                    var relativePath = xsltPath.Replace("/app/xslt/", "");
                    SelectedXsltFile = relativePath;
                    _currentXsltFile = relativePath; // Update tracking to prevent re-detection
                    Logger.LogInformation("Auto-detected XSLT '{Xslt}' for input file '{Input}'", relativePath, InputFileParam);
                }
                catch (ArgumentException ex)
                {
                    Logger.LogWarning(ex, "Could not auto-detect XSLT for input file '{Input}'", InputFileParam);
                    // Fall through to LoadXsltAsync default behavior
                }
            }

            if (!string.IsNullOrEmpty(InputFileParam))
            {
                SelectedFileName = InputFileParam;
            }

            // Reload from disk based on URL parameters
            await LoadProjectsAsync();
            await LoadXsltAsync();  // Now respects SelectedXsltFile if pre-set from XsltFileParam

            // Load selected files content
            if (!string.IsNullOrEmpty(InputFileParam))
            {
                await LoadFileContent(InputFileParam);
            }

            // Note: LoadXsltAsync already loads the content, no need to call LoadXsltContent again

            // Apply view mode parameter
            if (!string.IsNullOrEmpty(ViewParam))
            {
                ShowRendered = (ViewParam.ToLowerInvariant() == "rendered");
            }
            else
            {
                ShowRendered = false; // Default to source view
            }

            UpdateToolbarState();
            StateHasChanged();

            // Reset navigation loop counter on successful load
            _navigationLoopCount = 0;
        }
        else
        {
            Logger.LogDebug("No parameter changes detected, keeping existing state");
            // Reset navigation loop counter on successful load
            _navigationLoopCount = 0;
        }
    }

    private void UpdateToolbarState()
    {
        ToolbarState.Projects = Projects;
        ToolbarState.ProjectFiles = ProjectFiles;
        ToolbarState.SelectedProjectId = SelectedProjectId;
        ToolbarState.SelectedFileName = SelectedFileName;
        ToolbarState.IsLoading = IsLoading;
        ToolbarState.IsTransforming = IsTransforming;
        ToolbarState.IsSaving = IsSaving || IsSavingXml;
        ToolbarState.CanTransform = CanTransform;
        ToolbarState.CanSave = CanSave;
        ToolbarState.ShowSettings = ShowSettings;
        ToolbarState.NotifyStateChanged();
    }

    // Helper to build URLs with query parameters
    private string BuildUrlWithParams(string? inputFile, string? xsltFile, string? view)
    {
        var baseUrl = $"/transform/{Customer}/{ProjectId}";
        var queryParams = new List<string>();

        if (!string.IsNullOrEmpty(inputFile))
            queryParams.Add($"inputFile={Uri.EscapeDataString(inputFile)}");

        if (!string.IsNullOrEmpty(xsltFile))
            queryParams.Add($"xsltFile={Uri.EscapeDataString(xsltFile)}");

        if (!string.IsNullOrEmpty(view))
            queryParams.Add($"view={Uri.EscapeDataString(view)}");

        return queryParams.Count > 0
            ? $"{baseUrl}?{string.Join("&", queryParams)}"
            : baseUrl;
    }

    // Phase 1: Helper to load XML file content from disk
    private async Task LoadFileContent(string fileName)
    {
        if (string.IsNullOrEmpty(SelectedProjectId) || string.IsNullOrEmpty(fileName))
            return;

        try
        {
            IsLoadingXml = true;
            StateHasChanged();

            var xmlFilePath = Path.Combine("/app/data/input/optiver/projects", SelectedProjectId, fileName);
            XmlContent = await ProjectService.ReadInputFileAsync(SelectedProjectId, fileName);
            _originalXmlContent = XmlContent;
            _hasUnsavedChanges = false;
            Logger.LogInformation("Loaded file {FileName} from project {ProjectId}", fileName, SelectedProjectId);

            // If HTML source file, convert to XHTML
            if (fileName.EndsWith(".source.html", StringComparison.OrdinalIgnoreCase))
            {
                try
                {
                    XmlContent = await HtmlToXhtmlConversionService.ConvertHtmlToXhtmlAsync(XmlContent);
                    Logger.LogInformation("Converted HTML source to XHTML for file {FileName}", fileName);
                }
                catch (Exception convEx)
                {
                    Logger.LogError(convEx, "Failed to convert HTML to XHTML for file {FileName}", fileName);
                    ToastNotification.ShowError($"Failed to convert HTML to XHTML: {convEx.Message}");
                }
            }

            // Start watching file for external changes
            try
            {
                XmlFileWatcher.StartWatching(xmlFilePath);
                Logger.LogInformation("Started watching XML file: {Path}", xmlFilePath);
            }
            catch (Exception watchEx)
            {
                Logger.LogError(watchEx, "Failed to start XML file watcher");
            }

            // Auto-transform if enabled
            if (AutoTransform && CanTransform)
            {
                await TransformAsync();
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading XML file");
            ToastNotification.ShowError($"Failed to load XML file: {ex.Message}");
        }
        finally
        {
            IsLoadingXml = false;
            StateHasChanged();
        }
    }

    // Phase 1: Helper to load XSLT file content from disk
    private async Task LoadXsltContent(string xsltFileName)
    {
        if (string.IsNullOrEmpty(xsltFileName))
            return;

        try
        {
            IsLoadingXslt = true;
            StateHasChanged();

            var xsltPath = $"/app/xslt/{xsltFileName}";
            if (File.Exists(xsltPath))
            {
                isUpdatingFromExternalFile = true;
                XsltContent = await File.ReadAllTextAsync(xsltPath);
                Logger.LogInformation("Loaded XSLT file from {Path}", xsltPath);

                // Update Monaco editor if already initialized
                // (If not initialized, OnAfterRenderAsync will handle it)
                if (monacoInitialized)
                {
                    try
                    {
                        await JSRuntime.InvokeVoidAsync("MonacoEditorInterop.setValue", XsltContent);
                        Logger.LogInformation("Updated Monaco editor with XSLT content");
                    }
                    catch (Exception monacoEx)
                    {
                        Logger.LogWarning(monacoEx, "Could not update Monaco editor - will retry on render");
                    }
                }

                // Start watching XSLT file
                try
                {
                    XsltFileWatcher.StartWatching(xsltPath);
                    Logger.LogInformation("Started watching XSLT file: {Path}", xsltPath);
                }
                catch (Exception watchEx)
                {
                    Logger.LogError(watchEx, "Failed to start XSLT file watcher");
                }

                // Auto-transform if enabled
                if (AutoTransform && CanTransform)
                {
                    await TransformAsync();
                }

                isUpdatingFromExternalFile = false;
            }
            else
            {
                Logger.LogWarning("XSLT file not found: {Path}", xsltPath);
                ToastNotification.ShowError($"XSLT file not found: {xsltFileName}");
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading XSLT file");
            ToastNotification.ShowError($"Failed to load XSLT file: {ex.Message}");
            isUpdatingFromExternalFile = false;
        }
        finally
        {
            IsLoadingXslt = false;
            StateHasChanged();
        }
    }

    private async Task LoadProjectsAsync()
    {
        try
        {
            IsLoading = true;
            UpdateToolbarState();

            // Use centralized ProjectLoadingService
            Projects = await ProjectLoader.LoadActiveProjectsWithLabelsAsync();

            // Load files for each project
            foreach (var project in Projects)
            {
                var fullProjectId = $"{project.Organization}/{project.ProjectId}";
                project.Files = (await ProjectService.GetProjectFilesAsync(fullProjectId)).ToList();
            }

            // Build file groups for dropdowns
            // For Transform page, only show source/ files, not normalized/ (which are outputs from previous runs)
            // Using the new convention where all source files should be in the source/ folder
            ProjectFileGroups = await FileGroupBuilder.CreateQuery()
                .UseInputBase(true)
                .SourceXmlFiles()          // XML files from source/ folder only
                // NOTE: Not including RootXmlFiles() to avoid duplicates (files should be in source/)
                // NOTE: Not including NormalizedFiles() since we don't want normalized/ folder files
                .OnlyActiveProjects(false)
                .ForCustomer(Customer)
                .ForProject(ProjectId)
                .BuildAsync();

            Logger.LogInformation("Loaded {Count} active projects with files", Projects.Count);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading projects");
            ToastNotification.ShowError($"Failed to load projects: {ex.Message}");
        }
        finally
        {
            IsLoading = false;
            UpdateToolbarState();
        }
    }

    private async Task LoadXsltAsync()
    {
        try
        {
            IsLoadingXslt = true;

            // Load list of available XSLT files
            XsltFiles = FileService.GetXsltFiles().ToList();
            Logger.LogInformation("Loaded {Count} XSLT files", XsltFiles.Count);

            // Ensure selected file exists, default to transformation.xslt if not
            if (string.IsNullOrEmpty(SelectedXsltFile) || !XsltFiles.Contains(SelectedXsltFile))
            {
                SelectedXsltFile = XsltFiles.Contains("transformation.xslt")
                    ? "transformation.xslt"
                    : XsltFiles.FirstOrDefault();
            }

            if (!string.IsNullOrEmpty(SelectedXsltFile))
            {
                var xsltPath = $"/app/xslt/{SelectedXsltFile}";
                if (File.Exists(xsltPath))
                {
                    XsltContent = await File.ReadAllTextAsync(xsltPath);
                    Logger.LogInformation("Loaded XSLT file from {Path}", xsltPath);

                    // Update Monaco editor content if already initialized
                    if (monacoInitialized)
                    {
                        await JSRuntime.InvokeVoidAsync("MonacoEditorInterop.setValue", XsltContent);
                    }

                    // Start watching for file changes
                    try
                    {
                        XsltFileWatcher.StartWatching(xsltPath);
                        Logger.LogInformation("Started watching XSLT file for external changes");
                    }
                    catch (Exception watchEx)
                    {
                        Logger.LogError(watchEx, "Failed to start XSLT file watcher");
                        // Non-critical, continue without watcher
                    }
                }
                else
                {
                    Logger.LogWarning("XSLT file not found at {Path}", xsltPath);
                    ToastNotification.ShowWarning($"XSLT file not found: {SelectedXsltFile}");
                }
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading XSLT");
            ToastNotification.ShowError($"Failed to load XSLT: {ex.Message}");
        }
        finally
        {
            IsLoadingXslt = false;
        }
    }

    private async Task OnFileDropdownFocusedAsync()
    {
        // Reload projects to reflect any file changes (added/deleted files)
        Logger.LogInformation("File dropdown focused - reloading projects to refresh file list");
        await LoadProjectsAsync();
    }

    private async Task OnFilePathChangedFromDropdown(ChangeEventArgs e)
    {
        var filePath = e.Value?.ToString();
        if (!string.IsNullOrEmpty(filePath))
        {
            await OnFilePathChanged(filePath);
        }
    }

    private async Task HandleFileSelection(ProjectPathComponents parsed)
    {
        // Note: SelectedProjectId and SelectedFileName already updated via two-way binding
        // Build the full path and call existing file loading logic
        var filePath = ProjectPathParser.BuildPathFromFullId("input", parsed.FullProjectId!, parsed.FileName!);
        if (!string.IsNullOrEmpty(filePath))
        {
            await OnFilePathChanged(filePath);
        }
    }

    private async Task OnFilePathChangedFromComponent(string filePath)
    {
        if (!string.IsNullOrEmpty(filePath))
        {
            await OnFilePathChanged(filePath);
        }
    }

    private async Task OnFilePathChanged(string filePath)
    {
        // Phase 0 Safety: Check for unsaved changes before navigating
        if (_hasUnsavedChanges)
        {
            var confirmed = await JSRuntime.InvokeAsync<bool>(
                "confirm",
                "You have unsaved changes to the current XML file. Discard them?"
            );

            if (!confirmed)
            {
                // User cancelled - stay on current file
                Logger.LogInformation("User cancelled file change due to unsaved changes");
                return;
            }

            Logger.LogInformation("User confirmed discarding unsaved changes");
        }

        try
        {
            // Use centralized ProjectPathParser
            var parsed = ProjectPathParser.Parse(filePath);

            if (!parsed.Success)
            {
                Logger.LogWarning("Failed to parse file path: {Path}", filePath);
                return;
            }

            SelectedProjectId = parsed.FullProjectId;
            SelectedFileName = parsed.FileName;
            XmlContent = null;
            OutputContent = null;

            // Auto-select XSLT file based on source filename using SourceDetectionService
            try
            {
                var xsltPath = SourceDetectionService.GetXsltPathForSource(SelectedFileName);
                Logger.LogInformation("SourceDetectionService returned '{XsltPath}' for file '{FileName}'", xsltPath, SelectedFileName);

                // Convert to relative path for XsltFiles list (e.g., "/app/xslt/adobe/transformation.xslt" â†’ "adobe/transformation.xslt")
                var relativePath = xsltPath.Replace("/app/xslt/", "");
                Logger.LogInformation("Relative path: '{RelativePath}', Current XSLT: '{CurrentXslt}'", relativePath, SelectedXsltFile);

                // Always update the XSLT to match the source file type
                if (XsltFiles != null && XsltFiles.Contains(relativePath))
                {
                    if (SelectedXsltFile != relativePath)
                    {
                        Logger.LogInformation("Auto-selecting XSLT file '{Xslt}' based on source filename '{FileName}'", relativePath, SelectedFileName);
                    }
                    else
                    {
                        Logger.LogInformation("XSLT file '{Xslt}' already correctly selected for source '{FileName}'", relativePath, SelectedFileName);
                    }
                    SelectedXsltFile = relativePath;

                    // Load the XSLT content immediately
                    if (File.Exists(xsltPath))
                    {
                        XsltContent = await File.ReadAllTextAsync(xsltPath);
                        Logger.LogInformation("Auto-loaded XSLT file from {Path}", xsltPath);

                        // Update Monaco editor if initialized
                        if (monacoInitialized)
                        {
                            await JSRuntime.InvokeVoidAsync("MonacoEditorInterop.setValue", XsltContent);
                        }

                        // Update file watcher
                        try
                        {
                            XsltFileWatcher.StartWatching(xsltPath);
                        }
                        catch (Exception watchEx)
                        {
                            Logger.LogError(watchEx, "Failed to start XSLT file watcher during auto-selection");
                        }
                    }
                }
            }
            catch (ArgumentException argEx)
            {
                // Source filename doesn't match known patterns - log and continue without auto-selection
                Logger.LogWarning(argEx, "Could not auto-determine XSLT for source file '{FileName}'", SelectedFileName);
            }
            catch (Exception xsltEx)
            {
                Logger.LogError(xsltEx, "Error auto-loading XSLT file during source file selection");
            }

            IsLoadingXml = true;
            UpdateToolbarState();
            StateHasChanged();

            // Use the provided absolute path directly (no need to construct)
            var xmlFilePath = filePath;
            XmlContent = await ProjectService.ReadInputFileAsync(SelectedProjectId, SelectedFileName);
            _originalXmlContent = XmlContent; // Phase 0 Safety: Store original content for dirty tracking
            _hasUnsavedChanges = false; // Phase 0 Safety: Reset dirty flag on load
            Logger.LogInformation("Loaded file {FileName} from project {ProjectId}", SelectedFileName, SelectedProjectId);

            // If HTML source file, convert to XHTML before processing
            if (SelectedFileName.EndsWith(".source.html", StringComparison.OrdinalIgnoreCase))
            {
                try
                {
                    XmlContent = await HtmlToXhtmlConversionService.ConvertHtmlToXhtmlAsync(XmlContent);
                    Logger.LogInformation("Converted HTML source to XHTML for file {FileName}", SelectedFileName);
                }
                catch (Exception convEx)
                {
                    Logger.LogError(convEx, "Failed to convert HTML to XHTML for file {FileName}", SelectedFileName);
                    ToastNotification.ShowError($"Failed to convert HTML to XHTML: {convEx.Message}");
                }
            }

            // Start watching the XML file
            try
            {
                XmlFileWatcher.StartWatching(xmlFilePath);
                Logger.LogInformation("Started watching XML file: {Path}", xmlFilePath);
            }
            catch (Exception watchEx)
            {
                Logger.LogError(watchEx, "Failed to start XML file watcher");
            }

            // Auto-transform if enabled
            if (AutoTransform && CanTransform)
            {
                await TransformAsync();
            }

            // Update tracking variable and URL
            _currentInputFile = SelectedFileName;
            var viewMode = ShowRendered ? "rendered" : "source";
            var url = BuildUrlWithParams(SelectedFileName, SelectedXsltFile, viewMode);
            NavigationManager.NavigateTo(url, forceLoad: false);
            Logger.LogInformation("Updated URL to reflect file selection: {Url}", url);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading file from path {Path}", filePath);
            ToastNotification.ShowError($"Failed to load file: {ex.Message}");
        }
        finally
        {
            IsLoadingXml = false;
            UpdateToolbarState();
            StateHasChanged();

            // Initialize or update Monaco editor
            if (!string.IsNullOrEmpty(XmlContent))
            {
                Logger.LogInformation("OnFilePathChanged: Scheduling Source XML editor initialization/update (XmlContent length: {Length}, Editor initialized: {Initialized}, dotNetRef null: {DotNetRefNull})",
                    XmlContent?.Length ?? 0, _sourceXmlEditorInitialized, dotNetRef == null);

                _ = InvokeAsync(async () =>
                {
                    await Task.Delay(200);
                    try
                    {
                        Logger.LogInformation("OnFilePathChanged: Attempting to initialize/update Source XML editor (Editor initialized: {Initialized})", _sourceXmlEditorInitialized);

                        if (_sourceXmlEditorInitialized)
                        {
                            await JSRuntime.InvokeVoidAsync("MonacoXmlEditorInterop.setValue", XmlContent ?? "");
                            Logger.LogInformation("OnFilePathChanged: Source XML editor content updated via setValue");
                        }
                        else
                        {
                            // Validate dotNetRef before initializing
                            if (dotNetRef == null)
                            {
                                Logger.LogError("OnFilePathChanged: Cannot initialize Source XML editor - dotNetRef is null");
                                ToastNotification.ShowError("Failed to initialize XML editor (dotNetRef null). Please refresh the page.");
                                return;
                            }

                            var sourceXmlTheme = ThemeService.GetMonacoTheme();
                            Logger.LogInformation("OnFilePathChanged: Initializing Source XML editor (theme: {Theme})", sourceXmlTheme);

                            await JSRuntime.InvokeVoidAsync("MonacoXmlEditorInterop.initialize",
                                "source-xml-viewer",
                                XmlContent ?? "",
                                dotNetRef,
                                sourceXmlTheme);
                            _sourceXmlEditorInitialized = true;
                            Logger.LogInformation("OnFilePathChanged: Source XML editor initialized successfully");
                        }
                    }
                    catch (Exception ex)
                    {
                        Logger.LogError(ex, "OnFilePathChanged: Error initializing/updating Source XML editor");
                        ToastNotification.ShowError($"Failed to initialize XML editor: {ex.Message}");
                    }
                });
            }
            else
            {
                Logger.LogWarning("OnFilePathChanged: XmlContent is empty, skipping Source XML editor initialization");
            }
        }
    }

    private async Task OnProjectChanged(ChangeEventArgs e)
    {
        // Phase 0 Safety: Check for unsaved changes before changing projects
        if (_hasUnsavedChanges)
        {
            var confirmed = await JSRuntime.InvokeAsync<bool>(
                "confirm",
                "You have unsaved changes to the current XML file. Discard them?"
            );

            if (!confirmed)
            {
                // User cancelled - stay on current project
                Logger.LogInformation("User cancelled project change due to unsaved changes");
                return;
            }

            Logger.LogInformation("User confirmed discarding unsaved changes");
        }

        try
        {
            SelectedProjectId = e.Value?.ToString();
            SelectedFileName = null;
            XmlContent = null;
            OutputContent = null;
            ProjectFiles = null;
            _hasUnsavedChanges = false; // Phase 0 Safety: Reset dirty flag when switching projects
            _originalXmlContent = null; // Phase 0 Safety: Clear original content

            if (!string.IsNullOrEmpty(SelectedProjectId))
            {
                IsLoading = true;
                UpdateToolbarState();
                StateHasChanged();
                ProjectFiles = (await ProjectService.GetProjectFilesAsync(SelectedProjectId)).ToList();
                Logger.LogInformation("Loaded {Count} files for project {ProjectId}", ProjectFiles.Count, SelectedProjectId);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading project files");
            ToastNotification.ShowError($"Failed to load project files: {ex.Message}");
        }
        finally
        {
            IsLoading = false;
            UpdateToolbarState();
            StateHasChanged();

            // Save selection to localStorage (for development convenience only)
            await JSRuntime.InvokeVoidAsync("developmentStorage.saveSelection", SelectedProjectId, SelectedFileName, SelectedXsltFile);
        }
    }

    private async Task OnFileChanged(ChangeEventArgs e)
    {
        // Phase 0 Safety: Check for unsaved changes before navigating
        if (_hasUnsavedChanges)
        {
            var confirmed = await JSRuntime.InvokeAsync<bool>(
                "confirm",
                "You have unsaved changes to the current XML file. Discard them?"
            );

            if (!confirmed)
            {
                // User cancelled - stay on current file
                Logger.LogInformation("User cancelled file change due to unsaved changes");
                return;
            }

            Logger.LogInformation("User confirmed discarding unsaved changes");
        }

        // Phase 1: Update URL with new sourceFile parameter, preserve others
        var fileName = e.Value?.ToString();
        if (!string.IsNullOrEmpty(fileName))
        {
            _currentInputFile = fileName;
            var url = BuildUrlWithParams(
                inputFile: fileName,
                xsltFile: _currentXsltFile,
                view: _currentView
            );
            NavigationManager.NavigateTo(url);

            // OnParametersSetAsync will trigger and reload from disk
            return;
        }

        try
        {
            SelectedFileName = e.Value?.ToString();
            XmlContent = null;
            OutputContent = null;
            _hasUnsavedChanges = false; // Phase 0 Safety: Reset flag when switching files
            _originalXmlContent = null; // Phase 0 Safety: Clear original content

            UpdateToolbarState();
            StateHasChanged();

            if (!string.IsNullOrEmpty(SelectedProjectId) && !string.IsNullOrEmpty(SelectedFileName))
            {
                IsLoadingXml = true;
                StateHasChanged();

                var xmlFilePath = Path.Combine("/app/data/input/optiver/projects", SelectedProjectId, SelectedFileName);
                XmlContent = await ProjectService.ReadInputFileAsync(SelectedProjectId, SelectedFileName);
                _originalXmlContent = XmlContent; // Phase 0 Safety: Store original content for dirty tracking
                _hasUnsavedChanges = false; // Phase 0 Safety: Reset dirty flag on load
                Logger.LogInformation("Loaded file {FileName} from project {ProjectId}", SelectedFileName, SelectedProjectId);

                // If HTML source file, convert to XHTML before processing
                if (SelectedFileName.EndsWith(".source.html", StringComparison.OrdinalIgnoreCase))
                {
                    try
                    {
                        XmlContent = await HtmlToXhtmlConversionService.ConvertHtmlToXhtmlAsync(XmlContent);
                        Logger.LogInformation("Converted HTML source to XHTML for file {FileName}", SelectedFileName);
                    }
                    catch (Exception convEx)
                    {
                        Logger.LogError(convEx, "Failed to convert HTML to XHTML for file {FileName}", SelectedFileName);
                        ToastNotification.ShowError($"Failed to convert HTML to XHTML: {convEx.Message}");
                    }
                }

                // Start watching the XML file for external changes
                try
                {
                    XmlFileWatcher.StartWatching(xmlFilePath);
                    Logger.LogInformation("Started watching XML file for external changes: {Path}", xmlFilePath);
                }
                catch (Exception watchEx)
                {
                    Logger.LogError(watchEx, "Failed to start XML file watcher");
                    // Non-critical, continue without watcher
                }

                // Auto-transform if enabled
                if (AutoTransform && CanTransform)
                {
                    await TransformAsync();
                }
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading XML file");
            ToastNotification.ShowError($"Failed to load XML file: {ex.Message}");
        }
        finally
        {
            IsLoadingXml = false;
            UpdateToolbarState();
            StateHasChanged();

            // Initialize or update Monaco editor
            if (!string.IsNullOrEmpty(XmlContent))
            {
                Logger.LogInformation("OnFileChanged: Scheduling Source XML editor initialization/update (XmlContent length: {Length}, Editor initialized: {Initialized}, dotNetRef null: {DotNetRefNull})",
                    XmlContent?.Length ?? 0, _sourceXmlEditorInitialized, dotNetRef == null);

                _ = InvokeAsync(async () =>
                {
                    await Task.Delay(200); // Give Blazor time to render the container
                    try
                    {
                        Logger.LogInformation("OnFileChanged: Attempting to initialize/update Source XML editor (Editor initialized: {Initialized})", _sourceXmlEditorInitialized);

                        if (_sourceXmlEditorInitialized)
                        {
                            // Update existing editor
                            await JSRuntime.InvokeVoidAsync("MonacoXmlEditorInterop.setValue",
                                XmlContent ?? "");
                            Logger.LogInformation("OnFileChanged: Source XML editor content updated via setValue");
                        }
                        else
                        {
                            // Validate dotNetRef before initializing
                            if (dotNetRef == null)
                            {
                                Logger.LogError("OnFileChanged: Cannot initialize Source XML editor - dotNetRef is null");
                                ToastNotification.ShowError("Failed to initialize XML editor (dotNetRef null). Please refresh the page.");
                                return;
                            }

                            // Initialize editor for the first time
                            var sourceXmlTheme = ThemeService.GetMonacoTheme();
                            Logger.LogInformation("OnFileChanged: Initializing Source XML editor (theme: {Theme})", sourceXmlTheme);

                            await JSRuntime.InvokeVoidAsync("MonacoXmlEditorInterop.initialize",
                                "source-xml-viewer",
                                XmlContent ?? "",
                                dotNetRef,
                                sourceXmlTheme);
                            _sourceXmlEditorInitialized = true;
                            Logger.LogInformation("OnFileChanged: Source XML editor initialized successfully after file load");
                        }
                    }
                    catch (Exception ex)
                    {
                        Logger.LogError(ex, "OnFileChanged: Error initializing/updating Source XML editor");
                        ToastNotification.ShowError($"Failed to initialize XML editor: {ex.Message}");
                    }
                });
            }
            else
            {
                Logger.LogWarning("OnFileChanged: XmlContent is empty, skipping Source XML editor initialization");
            }

            // Save selection to localStorage (for development convenience only)
            await JSRuntime.InvokeVoidAsync("developmentStorage.saveSelection", SelectedProjectId, SelectedFileName, SelectedXsltFile);
        }
    }

    private void OnXsltFileChanged(ChangeEventArgs e)
    {
        // Navigate immediately - DO NOT update local state first!
        // OnParametersSetAsync will detect the change and reload from disk
        var xsltFileName = e.Value?.ToString();
        if (!string.IsNullOrEmpty(xsltFileName) && xsltFileName != _currentXsltFile)
        {
            var url = BuildUrlWithParams(
                inputFile: _currentInputFile,
                xsltFile: xsltFileName,
                view: _currentView
            );
            NavigationManager.NavigateTo(url);
        }
    }

    private async Task OnXsltChanged()
    {
        // Don't trigger auto-transform if we're updating from external file
        // (external file handler will trigger transform itself)
        if (isUpdatingFromExternalFile)
        {
            Logger.LogDebug("OnXsltChanged: Skipping auto-transform (updating from external file)");
            return;
        }

        // Auto-transform if enabled
        if (AutoTransform && CanTransform && !IsTransforming)
        {
            Logger.LogInformation("OnXsltChanged: Auto-transform triggered by editor change");
            await TransformAsync();
        }
    }

    private async void OnXsltFileChangedExternally(object? sender, XsltFileChangedEventArgs e)
    {
        // This is called from file watcher thread, marshal to UI thread
        await InvokeAsync(async () =>
        {
            try
            {
                Logger.LogInformation("XSLT file updated externally at {Path}", e.FilePath);

                // Set flag to prevent Monaco from triggering auto-transform
                isUpdatingFromExternalFile = true;

                // Update XSLT content
                XsltContent = e.Content;

                // Update Monaco editor if initialized
                if (monacoInitialized)
                {
                    await JSRuntime.InvokeVoidAsync("MonacoEditorInterop.setValue", XsltContent);
                }

                StateHasChanged();

                // Auto-transform if enabled
                if (AutoTransform && CanTransform && !IsTransforming)
                {
                    Logger.LogInformation("Auto-transform triggered by external XSLT file change");
                    await TransformAsync();
                }
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Error handling external XSLT file change");
                ToastNotification.ShowError($"Failed to reload XSLT: {ex.Message}");
            }
            finally
            {
                // Clear flag (Monaco won't fire change event due to isSettingValueProgrammatically)
                isUpdatingFromExternalFile = false;
            }
        });
    }

    private async void OnXmlFileChangedExternally(object? sender, XmlFileChangedEventArgs e)
    {
        // This is called from file watcher thread, marshal to UI thread
        await InvokeAsync(async () =>
        {
            try
            {
                // IGNORE file change if WE just saved the file
                if (isSavingXmlToFile)
                {
                    Logger.LogInformation("XML file changed externally, but ignoring because we initiated the save");
                    return;
                }

                Logger.LogInformation("XML file updated externally at {Path}", e.FilePath);

                // Set flag to prevent Monaco from triggering auto-transform
                isUpdatingFromExternalXmlFile = true;

                // Update XML content
                XmlContent = e.Content;

                // Update Monaco editor if initialized
                if (_sourceXmlEditorInitialized)
                {
                    await JSRuntime.InvokeVoidAsync("MonacoXmlEditorInterop.setValue", XmlContent);
                    Logger.LogInformation("Updated Source XML editor with external file changes");
                }

                StateHasChanged();

                // Show notification to user
                ToastNotification.ShowInfo("Source XML reloaded from disk");

                // Auto-transform if enabled
                if (AutoTransform && CanTransform && !IsTransforming)
                {
                    Logger.LogInformation("Auto-transform triggered by external XML file change");
                    await TransformAsync();
                }
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Error handling external XML file change");
                ToastNotification.ShowError($"Failed to reload XML: {ex.Message}");
            }
            finally
            {
                // Clear flag
                isUpdatingFromExternalXmlFile = false;
            }
        });
    }

    private async Task TransformAsync()
    {
        if (!CanTransform) return;

        try
        {
            IsTransforming = true;
            TransformationError = null; // Clear any previous error
            ValidationResult = null; // Clear previous validation results
            SavedNormalizedXmlPath = null; // Clear saved path
            UpdateToolbarState();

            // Determine root XSLT file based on selected file path
            string rootXsltFile;
            if (!string.IsNullOrEmpty(SelectedXsltFile))
            {
                if (SelectedXsltFile.StartsWith("adobe/", StringComparison.OrdinalIgnoreCase))
                {
                    rootXsltFile = "adobe/transformation.xslt";
                }
                else if (SelectedXsltFile.StartsWith("docling/", StringComparison.OrdinalIgnoreCase))
                {
                    rootXsltFile = "docling/transformation.xslt";
                }
                else
                {
                    // Fallback: assume it's a module file, look for root in same directory
                    var directory = Path.GetDirectoryName(SelectedXsltFile)?.Replace("\\", "/");
                    rootXsltFile = !string.IsNullOrEmpty(directory)
                        ? $"{directory}/transformation.xslt"
                        : "transformation.xslt";
                }
            }
            else
            {
                // Default to adobe pipeline (most common)
                rootXsltFile = "adobe/transformation.xslt";
            }

            var transformationXsltPath = Path.Combine("/app/xslt", rootXsltFile);
            string transformationXsltContent;

            if (File.Exists(transformationXsltPath))
            {
                transformationXsltContent = await File.ReadAllTextAsync(transformationXsltPath);
                Logger.LogInformation("Loaded {RootXsltFile} for transformation (length: {Length})", rootXsltFile, transformationXsltContent?.Length ?? 0);
            }
            else
            {
                Logger.LogError("{RootXsltFile} not found at {Path}", rootXsltFile, transformationXsltPath);
                TransformationError = $"{rootXsltFile} not found. Cannot perform transformation.";
                return;
            }

            var options = new TransformationOptions
            {
                UseXslt3Service = UseXslt3Service,
                NormalizeHeaders = NormalizeHeaders
            };

            // Check if we're editing a module file (not the root transformation.xslt)
            var isEditingModule = !string.IsNullOrEmpty(SelectedXsltFile) &&
                                  !SelectedXsltFile.Equals(rootXsltFile, StringComparison.OrdinalIgnoreCase);

            TransformationResult result;

            if (isEditingModule && !string.IsNullOrEmpty(XsltContent))
            {
                // Use the new method that supports edited module content from Monaco
                Logger.LogInformation("Transforming with edited module file: {File}", SelectedXsltFile);
                result = await XsltService.TransformWithEditedModuleAsync(
                    XmlContent!,
                    transformationXsltContent,
                    SelectedXsltFile,
                    XsltContent,
                    options,
                    transformationXsltPath);
            }
            else
            {
                // Standard transformation (root XSLT file is selected, or no module editing)
                Logger.LogInformation("Standard transformation using {RootXsltFile}", rootXsltFile);
                result = await XsltService.TransformAsync(XmlContent!, transformationXsltContent, options, transformationXsltPath);
            }

            if (result.IsSuccess)
            {
                TransformationError = null; // Clear error on success

                // Strip DOCTYPE declaration from output (user doesn't want it anywhere)
                var outputContent = result.OutputContent;
                if (!string.IsNullOrEmpty(outputContent))
                {
                    outputContent = System.Text.RegularExpressions.Regex.Replace(
                        outputContent,
                        @"<!DOCTYPE[^>]*>\s*",
                        string.Empty,
                        System.Text.RegularExpressions.RegexOptions.IgnoreCase);
                }

                OutputContent = outputContent;
                TransformationStats = result;
                Logger.LogInformation("Transformation successful in {Time}ms. OutputContent length: {Length}", result.ProcessingTimeMs, OutputContent?.Length ?? 0);

                // Save normalized XML to normalized/ folder with derived name
                if (!string.IsNullOrEmpty(SelectedProjectId) && !string.IsNullOrEmpty(OutputContent))
                {
                    try
                    {
                        var parts = SelectedProjectId.Split('/');
                        if (parts.Length == 2)
                        {
                            var organization = parts[0];
                            var projectId = parts[1];
                            var projectPath = Path.Combine("/app/data/input", organization, "projects", projectId);

                            // Ensure normalized folder exists
                            PdfConversion.Services.FileService.EnsureProjectFoldersExist(projectPath);

                            // Derive normalized filename from source filename
                            var derivedName = SourceDetectionService.GetNormalizedXmlName(SelectedFileName);
                            var normalizedDir = Path.Combine(projectPath, "normalized");
                            var normalizedXmlPath = Path.Combine(normalizedDir, derivedName);

                            // Save to normalized folder
                            await File.WriteAllTextAsync(normalizedXmlPath, OutputContent);
                            SavedNormalizedXmlPath = normalizedXmlPath;
                            Logger.LogInformation("Saved normalized XML to {Path}", normalizedXmlPath);

                            // Track output in WorkflowState for cross-page navigation
                            // Use relative path format: normalized/filename.xml
                            var relativePath = $"normalized/{derivedName}";
                            WorkflowState.SetTransformOutput(relativePath);
                            Logger.LogInformation("Registered normalized output in WorkflowState: {RelativePath}", relativePath);

                            // Also write to _work directory for development context (keep this)
                            try
                            {
                                var workPath = "/app/data/_work";
                                if (!Directory.Exists(workPath))
                                {
                                    Directory.CreateDirectory(workPath);
                                }
                                var contextNormalizedPath = Path.Combine(workPath, "_normalized.xml");
                                await File.WriteAllTextAsync(contextNormalizedPath, OutputContent);
                                Logger.LogInformation("Saved context normalized XML to {Path}", contextNormalizedPath);
                            }
                            catch (Exception workEx)
                            {
                                Logger.LogWarning(workEx, "Failed to save context normalized XML to _work folder");
                                // Non-critical, continue
                            }
                        }
                    }
                    catch (Exception ex)
                    {
                        Logger.LogError(ex, "Failed to save normalized XML to normalized/ folder");
                        // Non-critical error, continue
                    }
                }

                // Run XHTML validation
                if (!string.IsNullOrEmpty(OutputContent))
                {
                    try
                    {
                        ValidationResult = await ValidationService.ValidateXhtmlAsync(OutputContent);
                        Logger.LogInformation("XHTML validation completed: {TotalIssues} issues found",
                            ValidationResult.TotalIssues);

                        // If validation found issues, initialize draggable modal after render
                        if (ValidationResult != null && ValidationResult.TotalIssues > 0)
                        {
                            try
                            {
                                // Use JavaScript to poll for modal existence and initialize when found
                                await JSRuntime.InvokeVoidAsync("eval", @"
                                    let pollCount = 0;
                                    const maxPolls = 20; // Try for 2 seconds (20 * 100ms)

                                    const pollForModal = () => {
                                        pollCount++;
                                        const modal = document.getElementById('validationErrorsModal');

                                        if (modal) {
                                            // Check if already initialized
                                            if (!modal.dataset.dragInitialized) {
                                                modal.dataset.dragInitialized = 'true';

                                                // Try the normal initialization first
                                                if (window.initValidationModalDraggable) {
                                                    window.initValidationModalDraggable();
                                                }

                                                // Also directly initialize dragging
                                                setTimeout(() => {
                                                    const dotNetRef = window.transformPageDotNetRef;
                                                    if (dotNetRef) {
                                                        window.initDraggableModal('validation-modal-dialog', 'validation-modal-header', dotNetRef);

                                                        // Load saved position
                                                        dotNetRef.invokeMethodAsync('GetSavedModalPosition')
                                                            .then(position => {
                                                                if (position && position.x !== null && position.y !== null) {
                                                                    window.setModalPosition('validation-modal-dialog', position.x, position.y);
                                                                }
                                                            })
                                                            .catch(err => {
                                                                // Silently fail - position restoration is non-critical
                                                            });
                                                    }
                                                }, 100); // Small delay to ensure modal is fully rendered
                                            }
                                        } else if (pollCount < maxPolls) {
                                            setTimeout(pollForModal, 100);
                                        }
                                    };

                                    // Start polling
                                    pollForModal();
                                ");
                            }
                            catch (Exception ex)
                            {
                                Logger.LogWarning(ex, "Failed to initialize draggable modal polling");
                            }
                        }
                    }
                    catch (Exception ex)
                    {
                        Logger.LogError(ex, "Failed to run XHTML validation");
                        ValidationResult = null; // Clear on error
                    }
                }

                // Trigger visual success feedback (green glow on Transform button)
                await TriggerTransformSuccessEffect();

                if (result.WarningMessages.Any())
                {
                    foreach (var warning in result.WarningMessages)
                    {
                        ToastNotification.ShowWarning(warning);
                    }
                }

                // Update or initialize Output XML viewer (only if Source view is active)
                if (!ShowRendered)
                {
                    _ = InvokeAsync(async () =>
                    {
                        await Task.Delay(100); // Give Blazor time to render the container
                        try
                        {
                            if (!_outputXmlViewerInitialized)
                            {
                                var outputTheme = ThemeService.GetMonacoTheme();
                                await JSRuntime.InvokeVoidAsync("MonacoViewerInterop.createViewer",
                                    "output-xml-viewer",
                                    "outputXml",
                                    new {
                                        value = OutputContent ?? "",
                                        language = "xml",
                                        theme = outputTheme
                                    });
                                _outputXmlViewerInitialized = true;
                                Logger.LogInformation("Output XML viewer initialized after transformation");
                            }
                            else
                            {
                                await JSRuntime.InvokeVoidAsync("MonacoViewerInterop.setValue",
                                    "outputXml",
                                    OutputContent ?? "");
                                Logger.LogInformation("Updated Output XML viewer content");
                            }
                        }
                        catch (Exception ex)
                        {
                            Logger.LogError(ex, "Error initializing/updating Output XML viewer");
                        }
                    });
                }
            }
            else
            {
                Logger.LogError("Transformation failed: {Error}", result.ErrorMessage);
                TransformationError = result.ErrorMessage;
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error during transformation");
            TransformationError = $"Transformation error: {ex.Message}";
        }
        finally
        {
            IsTransforming = false;
            UpdateToolbarState();
            StateHasChanged();
        }
    }

    private async Task SaveXsltAsync()
    {
        if (!CanSave || string.IsNullOrEmpty(SelectedXsltFile)) return;

        try
        {
            IsSaving = true;
            UpdateToolbarState();

            var xsltPath = $"/app/xslt/{SelectedXsltFile}";
            await File.WriteAllTextAsync(xsltPath, XsltContent!);

            // Success toast removed - file save is logged
            Logger.LogInformation("XSLT file saved to {Path}", xsltPath);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error saving XSLT file {File}", SelectedXsltFile);
            ToastNotification.ShowError($"Failed to save XSLT: {ex.Message}");
        }
        finally
        {
            IsSaving = false;
            UpdateToolbarState();
            StateHasChanged();
        }
    }

    private async Task SaveXmlAsync()
    {
        if (!CanSaveXml) return;

        try
        {
            IsSavingXml = true;
            isSavingXmlToFile = true;  // SET FLAG BEFORE SAVE
            UpdateToolbarState();
            StateHasChanged();

            Logger.LogInformation("SaveXmlAsync: Setting isSavingXmlToFile flag to TRUE");

            // Parse project path: "org/project"
            var parts = SelectedProjectId!.Split('/');
            if (parts.Length != 2)
            {
                Logger.LogError("Invalid project ID format: {ProjectId}", SelectedProjectId);
                ToastNotification.ShowError("Invalid project ID format");
                return;
            }

            var organization = parts[0];
            var projectId = parts[1];
            var xmlFilePath = Path.Combine("/app/data/input", organization, "projects", projectId, SelectedFileName!);

            await File.WriteAllTextAsync(xmlFilePath, XmlContent!);

            // Phase 0 Safety: Reset dirty flag and update original content after successful save
            _originalXmlContent = XmlContent;
            _hasUnsavedChanges = false;

            // Success toast removed - file save is logged
            Logger.LogInformation("Source XML saved to {Path}, waiting 5 seconds for file watcher...", xmlFilePath);

            // Wait longer to ensure file watcher processes the change with flag set
            // File watcher on macOS Docker can have variable delays (increased to 5s for Docker filesystem virtualization)
            await Task.Delay(5000);

            Logger.LogInformation("SaveXmlAsync: Clearing isSavingXmlToFile flag to FALSE");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error saving Source XML file {File}", SelectedFileName);
            ToastNotification.ShowError($"Failed to save XML: {ex.Message}");
        }
        finally
        {
            isSavingXmlToFile = false;  // CLEAR FLAG AFTER SAVE
            IsSavingXml = false;
            UpdateToolbarState();
            StateHasChanged();
        }
    }

    private async Task OnFixCharactersClickedAsync()
    {
        if (string.IsNullOrEmpty(SelectedProjectId) || string.IsNullOrEmpty(SelectedFileName))
        {
            FixCharactersResult = "No file selected";
            FixCharactersSuccess = false;
            StateHasChanged();
            return;
        }

        try
        {
            IsFixingCharacters = true;
            FixCharactersResult = null;
            StateHasChanged();

            Logger.LogInformation("Running Fix Characters tool on {FileName} in project {ProjectId}", SelectedFileName, SelectedProjectId);

            var (success, message, ampersandCount, lessThanCount, greaterThanCount) = await FileService.FixInvalidXmlCharactersAsync(SelectedProjectId, SelectedFileName);

            FixCharactersResult = message;
            FixCharactersSuccess = success;

            if (success)
            {
                // Success toast removed - success indicated by FixCharactersSuccess flag and alert message
                Logger.LogInformation("Fix Characters completed: {Message}", message);

                // Reload XML content to reflect changes
                var totalFixed = ampersandCount + lessThanCount + greaterThanCount;
                if (totalFixed > 0)
                {
                    Logger.LogInformation("Reloading XML content after fixing {Count} characters", totalFixed);
                    await Task.Delay(500); // Brief delay to ensure file is written

                    // Reload the XML file
                    var filePath = ProjectPathParser.BuildPathFromFullId("input", SelectedProjectId, SelectedFileName);
                    if (!string.IsNullOrEmpty(filePath))
                        await OnFilePathChanged(filePath);
                }
            }
            else
            {
                ToastNotification.ShowError(message);
                Logger.LogError("Fix Characters failed: {Message}", message);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error running Fix Characters tool");
            FixCharactersResult = $"Error: {ex.Message}";
            FixCharactersSuccess = false;
            ToastNotification.ShowError($"Failed to fix characters: {ex.Message}");
        }
        finally
        {
            IsFixingCharacters = false;
            StateHasChanged();
        }
    }

    private async Task OnSanitizeXmlClickedAsync()
    {
        if (string.IsNullOrEmpty(SelectedProjectId) || string.IsNullOrEmpty(SelectedFileName))
        {
            SanitizeResult = "No file selected";
            SanitizeSuccess = false;
            StateHasChanged();
            return;
        }

        try
        {
            IsSanitizing = true;
            SanitizeResult = null;
            StateHasChanged();

            Logger.LogInformation("Running Sanitize tool on {FileName} in project {ProjectId}", SelectedFileName, SelectedProjectId);

            var (success, message) = await FileService.SanitizeXmlFileAsync(SelectedProjectId, SelectedFileName);

            SanitizeResult = message;
            SanitizeSuccess = success;

            if (success)
            {
                // Success toast removed - success indicated by SanitizeSuccess flag and alert message
                Logger.LogInformation("Sanitize completed: {Message}", message);

                // Brief delay to ensure file is written to disk
                await Task.Delay(500);

                // Reload all projects to make new lorem file available in dropdown
                Logger.LogInformation("Reloading projects to show new lorem file");
                await LoadProjectsAsync();
            }
            else
            {
                ToastNotification.ShowError(message);
                Logger.LogError("Sanitize failed: {Message}", message);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error running Sanitize tool");
            SanitizeResult = $"Error: {ex.Message}";
            SanitizeSuccess = false;
            ToastNotification.ShowError($"Failed to sanitize document: {ex.Message}");
        }
        finally
        {
            IsSanitizing = false;
            StateHasChanged();
        }
    }

    private async Task OnFixHeaderCapsClickedAsync()
    {
        if (string.IsNullOrEmpty(SelectedProjectId) || string.IsNullOrEmpty(SelectedFileName))
        {
            FixHeaderCapsResult = "No file selected";
            FixHeaderCapsSuccess = false;
            StateHasChanged();
            return;
        }

        try
        {
            IsFixingHeaderCaps = true;
            FixHeaderCapsResult = null;
            StateHasChanged();

            Logger.LogInformation("Running Fix Header Caps tool on {FileName} in project {ProjectId}", SelectedFileName, SelectedProjectId);

            var (success, message, convertedCount) = await FileService.FixHeaderCapsAsync(SelectedProjectId, SelectedFileName);

            FixHeaderCapsResult = message;
            FixHeaderCapsSuccess = success;

            if (success)
            {
                Logger.LogInformation("Fix Header Caps completed: {Message}", message);

                if (convertedCount > 0)
                {
                    Logger.LogInformation("Reloading XML content after converting {Count} headers", convertedCount);
                    await Task.Delay(500);

                    var filePath = ProjectPathParser.BuildPathFromFullId("input", SelectedProjectId, SelectedFileName);
                    if (!string.IsNullOrEmpty(filePath))
                        await OnFilePathChanged(filePath);
                }
            }
            else
            {
                ToastNotification.ShowError(message);
                Logger.LogError("Fix Header Caps failed: {Message}", message);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error running Fix Header Caps tool");
            FixHeaderCapsResult = $"Error: {ex.Message}";
            FixHeaderCapsSuccess = false;
            ToastNotification.ShowError($"Failed to fix header caps: {ex.Message}");
        }
        finally
        {
            IsFixingHeaderCaps = false;
            StateHasChanged();
        }
    }

    private void ToggleSettings()
    {
        ShowSettings = !ShowSettings;
        UpdateToolbarState();
        StateHasChanged();
    }

    private async Task ResetPanelLayout()
    {
        await JSRuntime.InvokeVoidAsync("PanelResize.reset");
        ShowSettings = false; // Close modal
        StateHasChanged();
    }

    private void OnSettingsChanged()
    {
        // Save settings to localStorage asynchronously (fire-and-forget)
        _ = SaveSettingsAsync();
    }

    private async Task SaveSettingsAsync()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("developmentStorage.saveSettings", UseXslt3Service, NormalizeHeaders, AutoTransform);
            Logger.LogInformation("Settings saved: UseXslt3Service={UseXslt3}, NormalizeHeaders={Normalize}, AutoTransform={Auto}",
                UseXslt3Service, NormalizeHeaders, AutoTransform);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to save settings to localStorage");
        }
    }

    private async Task OnFilesUploaded()
    {
        // Refresh file list
        if (!string.IsNullOrEmpty(SelectedProjectId))
        {
            try
            {
                ProjectFiles = (await ProjectService.GetProjectFilesAsync(SelectedProjectId)).ToList();
                UpdateToolbarState();
                StateHasChanged();
                Logger.LogInformation("File list refreshed after upload");
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Error refreshing file list after upload");
                ToastNotification.ShowError($"Failed to refresh file list: {ex.Message}");
            }
        }
    }

    // Zoom controls
    private void ZoomIn()
    {
        if (ZoomLevel < 200)
        {
            ZoomLevel += 10;
            StateHasChanged();
        }
    }

    private void ZoomOut()
    {
        if (ZoomLevel > 50)
        {
            ZoomLevel -= 10;
            StateHasChanged();
        }
    }

    private void ResetZoom()
    {
        ZoomLevel = 100;
        StateHasChanged();
    }

    // Copy to clipboard
    private async Task CopyToClipboard()
    {
        try
        {
            if (!string.IsNullOrEmpty(OutputContent))
            {
                await JSRuntime.InvokeVoidAsync("navigator.clipboard.writeText", OutputContent);
                // Success toast removed - clipboard operation is instant
                Logger.LogInformation("Output copied to clipboard");
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error copying to clipboard");
            ToastNotification.ShowError($"Failed to copy to clipboard: {ex.Message}");
        }
    }

    // Copy file path to clipboard
    private async Task CopyPathToClipboard(string path)
    {
        try
        {
            if (!string.IsNullOrEmpty(path))
            {
                await JSRuntime.InvokeVoidAsync("navigator.clipboard.writeText", path);
                // Success toast removed - clipboard operation is instant
                Logger.LogInformation("File path copied to clipboard: {Path}", path);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error copying path to clipboard");
            ToastNotification.ShowError($"Failed to copy path: {ex.Message}");
        }
    }

    // Copy XPath to clipboard
    private async Task CopyToClipboardAsync(string text)
    {
        try
        {
            if (!string.IsNullOrEmpty(text))
            {
                await JSRuntime.InvokeVoidAsync("navigator.clipboard.writeText", text);
                // Success toast removed - clipboard operation is instant
                Logger.LogInformation("XPath copied to clipboard");
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error copying XPath to clipboard");
            ToastNotification.ShowError($"Failed to copy XPath: {ex.Message}");
        }
    }

    // Navigate to element by XPath
    private async Task NavigateToElement(string xpath)
    {
        try
        {
            Logger.LogInformation("Navigating to element at XPath: {XPath}", xpath);

            // Close the validation modal using Bootstrap 5 API (no jQuery needed)
            await JSRuntime.InvokeVoidAsync("eval", @"
                const modal = document.getElementById('validationErrorsModal');
                if (modal && bootstrap && bootstrap.Modal) {
                    const modalInstance = bootstrap.Modal.getInstance(modal);
                    if (modalInstance) {
                        modalInstance.hide();
                    }
                }
            ");

            // Switch to XML source view if in HTML mode
            if (ShowRendered)
            {
                ShowRendered = false;
                StateHasChanged();
                await Task.Delay(200); // Give Blazor time to update the UI
            }

            // Ensure Output XML viewer is visible
            if (!_outputXmlViewerInitialized || string.IsNullOrEmpty(OutputContent))
            {
                Logger.LogWarning("Output XML viewer not initialized or no content available");
                ToastNotification.ShowWarning("XML viewer not ready. Please try again.");
                return;
            }

            // Find the element in the XML and get its line number
            var lineNumber = FindElementLineNumber(xpath);

            if (lineNumber > 0)
            {
                // Navigate to the line in Monaco editor
                await JSRuntime.InvokeVoidAsync("MonacoViewerInterop.navigateToLine", "outputXml", lineNumber);
                Logger.LogInformation("Navigated to line {LineNumber} for XPath {XPath}", lineNumber, xpath);
            }
            else
            {
                ToastNotification.ShowWarning($"Could not locate element in XML. XPath: {xpath}");
                Logger.LogWarning("Could not find line number for XPath: {XPath}", xpath);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error navigating to element");
            ToastNotification.ShowError($"Failed to navigate to element: {ex.Message}");
        }
    }

    // Navigate to a specific line number in the output XML viewer
    private async Task NavigateToLine(int lineNumber)
    {
        try
        {
            Logger.LogInformation("Navigating to line: {LineNumber}", lineNumber);

            // Close the validation modal using Bootstrap 5 API
            await JSRuntime.InvokeVoidAsync("eval", @"
                const modal = document.getElementById('validationErrorsModal');
                if (modal && bootstrap && bootstrap.Modal) {
                    const modalInstance = bootstrap.Modal.getInstance(modal);
                    if (modalInstance) {
                        modalInstance.hide();
                    }
                }
            ");

            // Switch to XML source view if in HTML mode
            if (ShowRendered)
            {
                ShowRendered = false;
                StateHasChanged();
                await Task.Delay(200); // Give Blazor time to update the UI
            }

            // Ensure Output XML viewer is visible and initialized
            if (!_outputXmlViewerInitialized || string.IsNullOrEmpty(OutputContent))
            {
                Logger.LogWarning("Output XML viewer not initialized or no content available");
                ToastNotification.ShowWarning("XML viewer not ready. Please try again.");
                return;
            }

            // Navigate to the line in Monaco editor
            await JSRuntime.InvokeVoidAsync("MonacoViewerInterop.navigateToLine", "outputXml", lineNumber);
            Logger.LogInformation("Navigated to line {LineNumber}", lineNumber);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error navigating to line");
            ToastNotification.ShowError($"Failed to navigate to line: {ex.Message}");
        }
    }

    private int FindElementLineNumber(string xpath)
    {
        try
        {
            if (string.IsNullOrEmpty(OutputContent))
            {
                return -1;
            }

            // Parse XPath to get element name (last segment)
            // Example: /html[1]/body[1]/div[1]/ul[7]/li[2]/L[1] -> L
            var xpathSegments = xpath.Split('/');
            var lastSegment = xpathSegments.LastOrDefault(s => !string.IsNullOrWhiteSpace(s));

            if (string.IsNullOrEmpty(lastSegment))
            {
                return -1;
            }

            // Remove index notation: L[1] -> L
            var elementName = System.Text.RegularExpressions.Regex.Replace(lastSegment, @"\[\d+\]", "");

            // Parse XML with line info
            var doc = System.Xml.Linq.XDocument.Parse(OutputContent, System.Xml.Linq.LoadOptions.SetLineInfo);
            var element = FindElementByXPath(doc.Root, xpath);

            if (element == null)
            {
                Logger.LogWarning("Element not found in XML for XPath: {XPath}", xpath);
                return -1;
            }

            // Get line number from IXmlLineInfo
            if (element is System.Xml.IXmlLineInfo lineInfo && lineInfo.HasLineInfo())
            {
                return lineInfo.LineNumber;
            }

            // Fallback: search for element in text
            var lines = OutputContent.Split('\n');
            var searchPattern = $"<{elementName}";

            for (int i = 0; i < lines.Length; i++)
            {
                if (lines[i].Contains(searchPattern))
                {
                    return i + 1; // Line numbers are 1-based
                }
            }

            Logger.LogWarning("Line number not found for element {ElementName}", elementName);
            return -1;
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error finding line number for XPath: {XPath}", xpath);
            return -1;
        }
    }

    private System.Xml.Linq.XElement? FindElementByXPath(System.Xml.Linq.XElement? root, string xpath)
    {
        if (root == null || string.IsNullOrEmpty(xpath))
        {
            return null;
        }

        try
        {
            // Simple XPath traversal for indexed paths like /html[1]/body[1]/div[1]/ul[7]/li[2]/L[1]
            var segments = xpath.Split('/')
                .Where(s => !string.IsNullOrWhiteSpace(s))
                .ToList();

            var current = root;

            foreach (var segment in segments.Skip(1)) // Skip first empty segment from leading /
            {
                // Parse segment: elementName[index]
                var match = System.Text.RegularExpressions.Regex.Match(segment, @"^([^\[]+)(?:\[(\d+)\])?$");
                if (!match.Success)
                {
                    return null;
                }

                var elementName = match.Groups[1].Value;
                var index = match.Groups[2].Success ? int.Parse(match.Groups[2].Value) : 1;

                // Find child elements with matching name
                var children = current.Elements()
                    .Where(e => e.Name.LocalName.Equals(elementName, StringComparison.OrdinalIgnoreCase))
                    .ToList();

                if (children.Count < index)
                {
                    return null;
                }

                current = children[index - 1]; // XPath uses 1-based indexing
            }

            return current;
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error traversing XPath: {XPath}", xpath);
            return null;
        }
    }

    // Download output
    private async Task DownloadOutput()
    {
        try
        {
            if (!string.IsNullOrEmpty(OutputContent))
            {
                var fileName = $"{SelectedProjectId ?? "output"}_{DateTime.Now:yyyyMMdd_HHmmss}.xhtml";
                var bytes = System.Text.Encoding.UTF8.GetBytes(OutputContent);
                var base64 = System.Convert.ToBase64String(bytes);

                await JSRuntime.InvokeVoidAsync("downloadFile", fileName, "application/xhtml+xml", base64);
                // Success toast removed - browser download notification is sufficient
                Logger.LogInformation("Downloaded output as {FileName}", fileName);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error downloading output");
            ToastNotification.ShowError($"Failed to download output: {ex.Message}");
        }
    }

    // Monaco Editor Integration
    private DotNetObjectReference<Transform>? dotNetRef;
    private bool monacoInitialized = false;
    private bool keyboardShortcutsInitialized = false;
    private bool _sourceXmlEditorInitialized = false;
    private bool _outputXmlViewerInitialized = false;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // Wait a bit to ensure JavaScript files are fully loaded
            await Task.Delay(200);

            // Load saved settings from localStorage
            try
            {
                var savedSettings = await JSRuntime.InvokeAsync<SavedSettings>("developmentStorage.loadSettings");
                if (savedSettings != null && savedSettings.HasStoredSettings)
                {
                    UseXslt3Service = savedSettings.UseXslt3Service;
                    NormalizeHeaders = savedSettings.NormalizeHeaders;
                    AutoTransform = savedSettings.AutoTransform;

                    Logger.LogInformation("Restored settings from localStorage: UseXslt3Service={UseXslt3}, NormalizeHeaders={Normalize}, AutoTransform={Auto}",
                        UseXslt3Service, NormalizeHeaders, AutoTransform);

                    StateHasChanged();
                }
                else
                {
                    Logger.LogInformation("No stored settings found, using defaults: UseXslt3Service={UseXslt3}, NormalizeHeaders={Normalize}, AutoTransform={Auto}",
                        UseXslt3Service, NormalizeHeaders, AutoTransform);
                }
            }
            catch (Exception ex)
            {
                Logger.LogWarning(ex, "Could not restore settings from localStorage, using defaults");
            }

            // Initialize keyboard shortcuts
            if (!keyboardShortcutsInitialized)
            {
                try
                {
                    dotNetRef = DotNetObjectReference.Create(this);
                    await JSRuntime.InvokeVoidAsync("KeyboardShortcuts.initialize", dotNetRef);
                    keyboardShortcutsInitialized = true;
                    Logger.LogInformation("Keyboard shortcuts initialized");
                }
                catch (Exception ex)
                {
                    Logger.LogError(ex, "Failed to initialize keyboard shortcuts");
                }
            }

            // Initialize Bootstrap tooltips for panel help buttons
            try
            {
                await JSRuntime.InvokeVoidAsync("eval", @"
                    if (typeof bootstrap !== 'undefined') {
                        var tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle=""tooltip""]'));
                        tooltipTriggerList.map(function (tooltipTriggerEl) {
                            return new bootstrap.Tooltip(tooltipTriggerEl, {
                                trigger: 'hover focus',
                                container: 'body'
                            });
                        });
                    }
                ");
                Logger.LogInformation("Bootstrap tooltips initialized for panel help buttons");
            }
            catch (Exception ex)
            {
                Logger.LogWarning(ex, "Failed to initialize Bootstrap tooltips");
            }

            // Store .NET reference globally for modal draggable init (called by Bootstrap modal shown event)
            try
            {
                await JSRuntime.InvokeVoidAsync("storeDotNetReference", dotNetRef);
                Logger.LogInformation("Stored .NET reference for validation modal draggability");

                // Try to initialize draggable modal now (in case modal already rendered)
                await JSRuntime.InvokeVoidAsync("initValidationModalDraggable");
            }
            catch (Exception ex)
            {
                Logger.LogWarning(ex, "Failed to store .NET reference for validation modal");
            }

            // NOTE: Removed user-selections.json restoration code.
            // URL is now the single source of truth for page state.
            // WorkflowStateService handles cross-page navigation state.
        }

        // Initialize Monaco editors on any render (not just firstRender)
        // This handles the case where content is loaded asynchronously after first render
        if (!string.IsNullOrEmpty(XsltContent) && !monacoInitialized && dotNetRef != null)
        {
            try
            {
                var theme = ThemeService.GetMonacoTheme();
                await JSRuntime.InvokeVoidAsync("MonacoEditorInterop.initialize",
                    "monaco-editor-container",
                    XsltContent,
                    dotNetRef,
                    theme);
                monacoInitialized = true;
                Logger.LogInformation("Monaco Editor initialized successfully");
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Failed to initialize Monaco Editor");
                ToastNotification.ShowError("Failed to initialize code editor. Using fallback mode.");
            }
        }

        // Initialize Source XML editor
        if (!string.IsNullOrEmpty(XmlContent) && !_sourceXmlEditorInitialized && dotNetRef != null)
        {
            try
            {
                var sourceXmlTheme = ThemeService.GetMonacoTheme();
                await JSRuntime.InvokeVoidAsync("MonacoXmlEditorInterop.initialize",
                    "source-xml-viewer",
                    XmlContent ?? "",
                    dotNetRef,
                    sourceXmlTheme);
                _sourceXmlEditorInitialized = true;
                Logger.LogInformation("Source XML editor initialized successfully");
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Failed to initialize Source XML editor");
                ToastNotification.ShowError("Failed to initialize XML editor. Using fallback mode.");
            }
        }
    }

    [JSInvokable]
    public async Task OnEditorContentChanged(string content)
    {
        Logger.LogDebug("OnEditorContentChanged called (isUpdatingFromExternalFile={IsUpdating})", isUpdatingFromExternalFile);
        XsltContent = content;
        await OnXsltChanged();
    }

    [JSInvokable]
    public async Task OnXmlContentChanged(string content)
    {
        Logger.LogInformation("OnXmlContentChanged called - Flag: {Flag}, AutoTransform: {Auto}, CanTransform: {Can}, IsTransforming: {Trans}",
            isUpdatingFromExternalXmlFile, AutoTransform, CanTransform, IsTransforming);

        // Phase 0 Safety: Track dirty flag when content changes
        if (!isUpdatingFromExternalXmlFile && !string.IsNullOrEmpty(_originalXmlContent))
        {
            _hasUnsavedChanges = (content != _originalXmlContent);
            Logger.LogDebug("Dirty flag updated: {HasUnsavedChanges} (content length: {Length}, original length: {OriginalLength})",
                _hasUnsavedChanges, content?.Length ?? 0, _originalXmlContent?.Length ?? 0);
        }

        // Don't trigger updates if we're syncing from external file
        if (isUpdatingFromExternalXmlFile)
        {
            Logger.LogDebug("OnXmlContentChanged: Skipping (updating from external file)");
            return;
        }

        Logger.LogInformation("OnXmlContentChanged: Editor content changed (length: {Length})", content?.Length ?? 0);
        XmlContent = content;

        // Auto-transform if enabled
        if (AutoTransform && CanTransform && !IsTransforming)
        {
            Logger.LogInformation("Auto-transform triggered by XML editor change");
            await TransformAsync();
        }
        else if (!AutoTransform)
        {
            Logger.LogInformation("Auto-transform is DISABLED - enable it in settings to transform automatically");
        }
        else if (!CanTransform)
        {
            Logger.LogInformation("Auto-transform skipped - CanTransform is false (missing XML, XSLT, or selection)");
        }
        else if (IsTransforming)
        {
            Logger.LogInformation("Auto-transform skipped - transformation already in progress");
        }
    }

    [JSInvokable]
    public async Task OnSaveShortcut()
    {
        await SaveXsltAsync();
    }

    [JSInvokable]
    public async Task OnSaveXmlShortcut()
    {
        await SaveXmlAsync();
    }

    [JSInvokable]
    public async Task OnTransformShortcut()
    {
        await TransformAsync();
    }

    [JSInvokable]
    public void OnShowHelp()
    {
        // This would trigger help panel in MainLayout
        // For now, just show a toast
        ToastNotification.ShowInfo("Press ? to show help panel");
    }

    private async Task TriggerTransformSuccessEffect()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("VisualFeedback.triggerTransformSuccess");
        }
        catch (Exception ex)
        {
            Logger.LogWarning(ex, "Failed to trigger transform success effect");
        }
    }

    public async ValueTask DisposeAsync()
    {
        // Phase 0 Safety: Warn if component disposed with unsaved changes
        if (_hasUnsavedChanges)
        {
            Logger.LogWarning("Transform component disposed with unsaved XML changes! File: {File}, Project: {Project}",
                SelectedFileName ?? "unknown", SelectedProjectId ?? "unknown");
        }

        // Clear file watcher callbacks
        XsltFileWatcher.SetFileChangedCallback(null);
        XmlFileWatcher.SetFileChangedCallback(null);

        // Dispose Source XML editor
        if (_sourceXmlEditorInitialized)
        {
            try
            {
                await JSRuntime.InvokeVoidAsync("MonacoXmlEditorInterop.dispose");
                Logger.LogInformation("Disposed Source XML editor");
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Error disposing Source XML editor");
            }
        }

        // Dispose Output XML viewer
        if (_outputXmlViewerInitialized)
        {
            try
            {
                await JSRuntime.InvokeVoidAsync("MonacoViewerInterop.dispose", "outputXml");
                Logger.LogInformation("Disposed Output XML viewer");
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Error disposing Output XML viewer");
            }
        }

        // Dispose Monaco Editor
        if (monacoInitialized)
        {
            try
            {
                await JSRuntime.InvokeVoidAsync("MonacoEditorInterop.dispose");
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Error disposing Monaco Editor");
            }
        }

        dotNetRef?.Dispose();
    }

    [JSInvokable]
    public async Task SaveModalPosition(int x, int y)
    {
        try
        {
            await UserSelectionService.UpdateModalPositionAsync(x, y);
            Logger.LogInformation("Saved modal position: X={X}, Y={Y}", x, y);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to save modal position");
        }
    }

    [JSInvokable]
    public async Task<object> GetSavedModalPosition()
    {
        try
        {
            var selection = await UserSelectionService.GetSelectionAsync();
            return new
            {
                x = selection.ValidationModalX,
                y = selection.ValidationModalY
            };
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to get saved modal position");
            return new { x = (int?)null, y = (int?)null };
        }
    }
}

<script>
    window.initDraggableModal = (dialogId, handleId, dotNetRef) => {
        const dialog = document.getElementById(dialogId);
        const handle = document.getElementById(handleId);

        if (!dialog || !handle) {
            return;
        }

        // Prevent duplicate initialization
        if (dialog.dataset.dragHandlersAttached === 'true') {
            return;
        }
        dialog.dataset.dragHandlersAttached = 'true';

        let isDragging = false;
        let currentX, currentY, initialX, initialY;

        const onMouseDown = (e) => {
            // Don't drag if clicking close button or button elements
            if (e.target.closest('.btn-close') || e.target.closest('button')) {
                return;
            }

            isDragging = true;

            // Get current position or calculate from center
            const rect = dialog.getBoundingClientRect();
            initialX = e.clientX - rect.left;
            initialY = e.clientY - rect.top;

            dialog.style.position = 'fixed';
            dialog.classList.add('dragging');
            e.preventDefault();
        };

        const onMouseMove = (e) => {
            if (!isDragging) return;

            e.preventDefault();
            currentX = e.clientX - initialX;
            currentY = e.clientY - initialY;

            // Keep within viewport
            const maxX = window.innerWidth - dialog.offsetWidth;
            const maxY = window.innerHeight - dialog.offsetHeight;
            currentX = Math.max(0, Math.min(currentX, maxX));
            currentY = Math.max(0, Math.min(currentY, maxY));

            dialog.style.left = currentX + 'px';
            dialog.style.top = currentY + 'px';
            dialog.style.transform = 'none';
            dialog.style.margin = '0';
        };

        const onMouseUp = (e) => {
            if (isDragging) {
                isDragging = false;
                dialog.classList.remove('dragging');

                // Save position to server
                if (currentX !== undefined && currentY !== undefined) {
                    dotNetRef.invokeMethodAsync('SaveModalPosition', Math.round(currentX), Math.round(currentY))
                        .catch(err => {
                            // Silently fail - position saving is non-critical
                        });
                }
            }
        };

        // Remove existing listeners if any
        handle.removeEventListener('mousedown', onMouseDown);
        document.removeEventListener('mousemove', onMouseMove);
        document.removeEventListener('mouseup', onMouseUp);

        // Attach new listeners
        handle.addEventListener('mousedown', onMouseDown);
        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mouseup', onMouseUp);
    };

    window.setModalPosition = (dialogId, x, y) => {
        const dialog = document.getElementById(dialogId);
        if (!dialog) {
            return;
        }

        // Ensure position is within viewport
        const maxX = window.innerWidth - dialog.offsetWidth;
        const maxY = window.innerHeight - dialog.offsetHeight;
        const safeX = Math.max(0, Math.min(x, maxX));
        const safeY = Math.max(0, Math.min(y, maxY));

        dialog.style.position = 'fixed';
        dialog.style.left = safeX + 'px';
        dialog.style.top = safeY + 'px';
        dialog.style.transform = 'none';
        dialog.style.margin = '0';
    };

    window.storeDotNetReference = (dotNetRef) => {
        window.transformPageDotNetRef = dotNetRef;
    };

    // Initialize draggable modal when it's shown (modal exists in DOM)
    // Use a function that can be called multiple times
    window.initValidationModalDraggable = () => {
        const modal = document.getElementById('validationErrorsModal');
        if (!modal) {
            // Modal not in DOM yet, will retry when modal is shown
            return false;
        }

        // Check if already initialized
        if (modal.dataset.draggableInitialized === 'true') {
            return true;
        }

        // Mark as initialized to avoid duplicate listeners
        modal.dataset.draggableInitialized = 'true';

        modal.addEventListener('shown.bs.modal', () => {
            // Get .NET reference from window if available
            const dotNetRef = window.transformPageDotNetRef;

            if (!dotNetRef) {
                return;
            }

            initDraggableModal('validation-modal-dialog', 'validation-modal-header', dotNetRef);

            // Load and restore saved position
            dotNetRef.invokeMethodAsync('GetSavedModalPosition')
                .then(position => {
                    if (position && position.x !== null && position.y !== null) {
                        setModalPosition('validation-modal-dialog', position.x, position.y);
                    }
                })
                .catch(err => {
                    // Silently fail - position restoration is non-critical
                });
        });

        return true;
    };

    // Try to initialize immediately (if modal already exists)
    document.addEventListener('DOMContentLoaded', () => {
        window.initValidationModalDraggable();
    });

    // Also try after a short delay to catch Blazor-rendered modals
    setTimeout(() => {
        window.initValidationModalDraggable();
    }, 500);
</script>

